import { __decorate } from "tslib";
import { serialize } from "../../Misc/decorators";
import { CameraInputTypes } from "../../Cameras/cameraInputsManager";
import { PointerEventTypes } from "../../Events/pointerEvents";
import { Scalar } from '../../Maths/math.scalar';
import { Tools } from '../../Misc/tools';
/**
 * Manage the mouse wheel inputs to control an arc rotate camera.
 * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
 */
var ArcRotateCameraMouseWheelInput = /** @class */ (function () {
    function ArcRotateCameraMouseWheelInput() {
        /**
         * Gets or Set the mouse wheel precision or how fast is the camera zooming.
         */
        this.wheelPrecision = 3.0;
        /**
         * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when wheel is used.
         */
        this.wheelDeltaPercentage = 0;
    }
    ArcRotateCameraMouseWheelInput.prototype.computeDeltaFromMouseWheelLegacyEvent = function (mouseWheelDelta, radius) {
        var delta = 0;
        var wheelDelta = (mouseWheelDelta * 0.01 * this.wheelDeltaPercentage) * radius;
        if (mouseWheelDelta > 0) {
            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);
        }
        else {
            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);
        }
        return delta;
    };
    /**
     * Attach the input controls to a specific dom element to get the input from.
     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
     */
    ArcRotateCameraMouseWheelInput.prototype.attachControl = function (noPreventDefault) {
        var _this = this;
        // was there a second variable defined?
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this._wheel = function (p, s) {
            //sanity check - this should be a PointerWheel event.
            if (p.type !== PointerEventTypes.POINTERWHEEL) {
                return;
            }
            var event = p.event;
            var delta = 0;
            var mouseWheelLegacyEvent = event;
            var wheelDelta = 0;
            if (mouseWheelLegacyEvent.wheelDelta) {
                wheelDelta = mouseWheelLegacyEvent.wheelDelta;
            }
            else {
                wheelDelta = -(event.deltaY || event.detail) * 60;
            }
            if (_this.wheelDeltaPercentage) {
                delta = _this.computeDeltaFromMouseWheelLegacyEvent(wheelDelta, _this.camera.radius);
                // If zooming in, estimate the target radius and use that to compute the delta for inertia
                // this will stop multiple scroll events zooming in from adding too much inertia
                if (delta > 0) {
                    var estimatedTargetRadius = _this.camera.radius;
                    var targetInertia = _this.camera.inertialRadiusOffset + delta;
                    for (var i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {
                        estimatedTargetRadius -= targetInertia;
                        targetInertia *= _this.camera.inertia;
                    }
                    estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);
                    delta = _this.computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);
                }
            }
            else {
                delta = wheelDelta / (_this.wheelPrecision * 40);
            }
            if (delta) {
                _this.camera.inertialRadiusOffset += delta;
            }
            if (event.preventDefault) {
                if (!noPreventDefault) {
                    event.preventDefault();
                }
            }
        };
        this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);
    };
    /**
     * Detach the current controls from the specified dom element.
     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl
     */
    ArcRotateCameraMouseWheelInput.prototype.detachControl = function (ignored) {
        if (this._observer) {
            this.camera.getScene().onPointerObservable.remove(this._observer);
            this._observer = null;
            this._wheel = null;
        }
    };
    /**
     * Gets the class name of the current intput.
     * @returns the class name
     */
    ArcRotateCameraMouseWheelInput.prototype.getClassName = function () {
        return "ArcRotateCameraMouseWheelInput";
    };
    /**
     * Get the friendly name associated with the input class.
     * @returns the input friendly name
     */
    ArcRotateCameraMouseWheelInput.prototype.getSimpleName = function () {
        return "mousewheel";
    };
    __decorate([
        serialize()
    ], ArcRotateCameraMouseWheelInput.prototype, "wheelPrecision", void 0);
    __decorate([
        serialize()
    ], ArcRotateCameraMouseWheelInput.prototype, "wheelDeltaPercentage", void 0);
    return ArcRotateCameraMouseWheelInput;
}());
export { ArcRotateCameraMouseWheelInput };
CameraInputTypes["ArcRotateCameraMouseWheelInput"] = ArcRotateCameraMouseWheelInput;
//# sourceMappingURL=arcRotateCameraMouseWheelInput.js.map