import { DeviceInputSystem } from '../deviceInputSystem';
import { DeviceType } from './deviceEnums';
import { Observable } from '../../Misc/observable';
/**
 * Class that handles all input for a specific device
 */
var DeviceSource = /** @class */ (function () {
    /**
     * Default Constructor
     * @param deviceInputSystem Reference to DeviceInputSystem
     * @param deviceType Type of device
     * @param deviceSlot "Slot" or index that device is referenced in
     */
    function DeviceSource(deviceInputSystem, 
    /** Type of device */
    deviceType, 
    /** "Slot" or index that device is referenced in */
    deviceSlot) {
        if (deviceSlot === void 0) { deviceSlot = 0; }
        this.deviceType = deviceType;
        this.deviceSlot = deviceSlot;
        // Public Members
        /**
         * Observable to handle device input changes per device
         */
        this.onInputChangedObservable = new Observable();
        this._deviceInputSystem = deviceInputSystem;
    }
    /**
     * Get input for specific input
     * @param inputIndex index of specific input on device
     * @returns Input value from DeviceInputSystem
     */
    DeviceSource.prototype.getInput = function (inputIndex) {
        return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, inputIndex);
    };
    return DeviceSource;
}());
export { DeviceSource };
/**
 * Class to keep track of devices
 */
var DeviceSourceManager = /** @class */ (function () {
    /**
     * Default Constructor
     * @param engine engine to pull input element from
     */
    function DeviceSourceManager(engine) {
        var _this = this;
        // Public Members
        /**
         * Observable to be triggered when after a device is connected, any new observers added will be triggered against already connected devices
         */
        this.onDeviceConnectedObservable = new Observable(function (observer) {
            _this.getDevices().forEach(function (device) {
                _this.onDeviceConnectedObservable.notifyObserver(observer, device);
            });
        });
        /**
         * Observable to be triggered when after a device is disconnected
         */
        this.onDeviceDisconnectedObservable = new Observable();
        var numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
        this._devices = new Array(numberOfDeviceTypes);
        this._firstDevice = new Array(numberOfDeviceTypes);
        this._deviceInputSystem = DeviceInputSystem.Create(engine);
        this._deviceInputSystem.onDeviceConnected = function (deviceType, deviceSlot) {
            _this._addDevice(deviceType, deviceSlot);
            _this.onDeviceConnectedObservable.notifyObservers(_this.getDeviceSource(deviceType, deviceSlot));
        };
        this._deviceInputSystem.onDeviceDisconnected = function (deviceType, deviceSlot) {
            var device = _this.getDeviceSource(deviceType, deviceSlot); // Grab local reference to use before removing from devices
            _this._removeDevice(deviceType, deviceSlot);
            _this.onDeviceDisconnectedObservable.notifyObservers(device);
        };
        if (!this._deviceInputSystem.onInputChanged) {
            this._deviceInputSystem.onInputChanged = function (deviceType, deviceSlot, inputIndex, previousState, currentState) {
                var _a;
                (_a = _this.getDeviceSource(deviceType, deviceSlot)) === null || _a === void 0 ? void 0 : _a.onInputChangedObservable.notifyObservers({ inputIndex: inputIndex, previousState: previousState, currentState: currentState });
            };
        }
    }
    // Public Functions
    /**
     * Gets a DeviceSource, given a type and slot
     * @param deviceType Enum specifying device type
     * @param deviceSlot "Slot" or index that device is referenced in
     * @returns DeviceSource object
     */
    DeviceSourceManager.prototype.getDeviceSource = function (deviceType, deviceSlot) {
        if (deviceSlot === undefined) {
            if (this._firstDevice[deviceType] === undefined) {
                return null;
            }
            deviceSlot = this._firstDevice[deviceType];
        }
        if (!this._devices[deviceType] || this._devices[deviceType][deviceSlot] === undefined) {
            return null;
        }
        return this._devices[deviceType][deviceSlot];
    };
    /**
     * Gets an array of DeviceSource objects for a given device type
     * @param deviceType Enum specifying device type
     * @returns Array of DeviceSource objects
     */
    DeviceSourceManager.prototype.getDeviceSources = function (deviceType) {
        return this._devices[deviceType].filter(function (source) { return !!source; });
    };
    /**
     * Returns a read-only list of all available devices
     * @returns Read-only array with active devices
     */
    DeviceSourceManager.prototype.getDevices = function () {
        var deviceArray = new Array();
        this._devices.forEach(function (deviceSet) {
            deviceArray.push.apply(deviceArray, deviceSet);
        });
        return deviceArray;
    };
    /**
     * Dispose of DeviceInputSystem and other parts
     */
    DeviceSourceManager.prototype.dispose = function () {
        this.onDeviceConnectedObservable.clear();
        this.onDeviceDisconnectedObservable.clear();
        this._deviceInputSystem.dispose();
    };
    // Private Functions
    /**
     * Function to add device name to device list
     * @param deviceType Enum specifying device type
     * @param deviceSlot "Slot" or index that device is referenced in
     */
    DeviceSourceManager.prototype._addDevice = function (deviceType, deviceSlot) {
        if (!this._devices[deviceType]) {
            this._devices[deviceType] = new Array();
        }
        if (!this._devices[deviceType][deviceSlot]) {
            this._devices[deviceType][deviceSlot] = new DeviceSource(this._deviceInputSystem, deviceType, deviceSlot);
            this._updateFirstDevices(deviceType);
        }
    };
    /**
     * Function to remove device name to device list
     * @param deviceType Enum specifying device type
     * @param deviceSlot "Slot" or index that device is referenced in
     */
    DeviceSourceManager.prototype._removeDevice = function (deviceType, deviceSlot) {
        delete this._devices[deviceType][deviceSlot];
        this._updateFirstDevices(deviceType);
    };
    /**
     * Updates array storing first connected device of each type
     * @param type Type of Device
     */
    DeviceSourceManager.prototype._updateFirstDevices = function (type) {
        switch (type) {
            case DeviceType.Keyboard:
            case DeviceType.Mouse:
                this._firstDevice[type] = 0;
                break;
            case DeviceType.Touch:
            case DeviceType.DualShock:
            case DeviceType.Xbox:
            case DeviceType.Switch:
            case DeviceType.Generic:
                var devices = this._devices[type];
                delete this._firstDevice[type];
                for (var i = 0; i < devices.length; i++) {
                    if (devices[i]) {
                        this._firstDevice[type] = i;
                        break;
                    }
                }
                break;
        }
    };
    return DeviceSourceManager;
}());
export { DeviceSourceManager };
//# sourceMappingURL=deviceSourceManager.js.map