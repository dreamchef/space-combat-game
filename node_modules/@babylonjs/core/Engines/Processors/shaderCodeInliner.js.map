{"version":3,"file":"shaderCodeInliner.js","sourceRoot":"","sources":["../../../../sourceES6/core/Engines/Processors/shaderCodeInliner.ts"],"names":[],"mappings":"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","sourcesContent":["interface IInlineFunctionDescr {\r\n    name: string;\r\n    type: string;\r\n    parameters: string[];\r\n    body: string;\r\n    callIndex: number;\r\n}\r\n\r\n/**\r\n * Class used to inline functions in shader code\r\n*/\r\nexport class ShaderCodeInliner {\r\n\r\n    private static readonly _RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\r\n\r\n    private _sourceCode: string;\r\n    private _functionDescr: IInlineFunctionDescr[];\r\n    private _numMaxIterations: number;\r\n\r\n    /** Gets or sets the token used to mark the functions to inline */\r\n    public inlineToken: string;\r\n\r\n    /** Gets or sets the debug mode */\r\n    public debug: boolean = false;\r\n\r\n    /** Gets the code after the inlining process */\r\n    public get code(): string {\r\n        return this._sourceCode;\r\n    }\r\n\r\n    /**\r\n     * Initializes the inliner\r\n     * @param sourceCode shader code source to inline\r\n     * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n     */\r\n    constructor(sourceCode: string, numMaxIterations = 20) {\r\n        this._sourceCode = sourceCode;\r\n        this._numMaxIterations = numMaxIterations;\r\n        this._functionDescr = [];\r\n        this.inlineToken = \"#define inline\";\r\n    }\r\n\r\n    /**\r\n     * Start the processing of the shader code\r\n     */\r\n    public processCode() {\r\n        if (this.debug) {\r\n            console.log(`Start inlining process (code size=${this._sourceCode.length})...`);\r\n        }\r\n        this._collectFunctions();\r\n        this._processInlining(this._numMaxIterations);\r\n        if (this.debug) {\r\n            console.log(\"End of inlining process.\");\r\n        }\r\n    }\r\n\r\n    private _collectFunctions() {\r\n        let startIndex = 0;\r\n\r\n        while (startIndex < this._sourceCode.length) {\r\n            // locate the function to inline and extract its name\r\n            const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\r\n            if (inlineTokenIndex < 0) {\r\n                break;\r\n            }\r\n\r\n            const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\r\n            if (funcParamsStartIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));\r\n            if (!funcNameMatch) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\r\n\r\n            // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\r\n            const funcParamsEndIndex = this._extractBetweenMarkers('(', ')', this._sourceCode, funcParamsStartIndex);\r\n            if (funcParamsEndIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\r\n\r\n            // extract the body of the function (with the curly brackets)\r\n            const funcBodyStartIndex = this._skipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\r\n            if (funcBodyStartIndex === this._sourceCode.length) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcBodyEndIndex = this._extractBetweenMarkers('{', '}', this._sourceCode, funcBodyStartIndex);\r\n            if (funcBodyEndIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\r\n\r\n            // process the parameters: extract each names\r\n            const params = this._removeComments(funcParams).split(\",\");\r\n            const paramNames = [];\r\n\r\n            for (let p = 0; p < params.length; ++p) {\r\n                const param = params[p].trim();\r\n                const idx = param.lastIndexOf(\" \");\r\n\r\n                if (idx >= 0) {\r\n                    paramNames.push(param.substring(idx + 1));\r\n                }\r\n            }\r\n\r\n            if (funcType !== 'void') {\r\n                // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\r\n                paramNames.push('return');\r\n            }\r\n\r\n            // collect the function\r\n            this._functionDescr.push({\r\n                \"name\": funcName,\r\n                \"type\": funcType,\r\n                \"parameters\": paramNames,\r\n                \"body\": funcBody,\r\n                \"callIndex\": 0,\r\n            });\r\n\r\n            startIndex = funcBodyEndIndex + 1;\r\n\r\n            // remove the function from the source code\r\n            const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\r\n            const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\r\n\r\n            this._sourceCode = partBefore + partAfter;\r\n\r\n            startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\r\n        }\r\n\r\n        if (this.debug) {\r\n            console.log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=`, this._functionDescr);\r\n        }\r\n    }\r\n\r\n    private _processInlining(numMaxIterations: number = 20): boolean {\r\n        while (numMaxIterations-- >= 0) {\r\n            if (!this._replaceFunctionCallsByCode()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.debug) {\r\n            console.log(`numMaxIterations is ${numMaxIterations} after inlining process`);\r\n        }\r\n\r\n        return numMaxIterations >= 0;\r\n    }\r\n\r\n    private _extractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n        let currPos = startIndex,\r\n            openMarkers = 0,\r\n            waitForChar = '';\r\n\r\n        while (currPos < block.length) {\r\n            let currChar = block.charAt(currPos);\r\n\r\n            if (!waitForChar) {\r\n                switch (currChar) {\r\n                    case markerOpen:\r\n                        openMarkers++;\r\n                        break;\r\n                    case markerClose:\r\n                        openMarkers--;\r\n                        break;\r\n                    case '\"':\r\n                    case \"'\":\r\n                    case \"`\":\r\n                        waitForChar = currChar;\r\n                        break;\r\n                    case '/':\r\n                        if (currPos + 1 < block.length) {\r\n                            const nextChar = block.charAt(currPos + 1);\r\n                            if (nextChar === '/') {\r\n                                waitForChar = '\\n';\r\n                            } else if (nextChar === '*') {\r\n                                waitForChar = '*/';\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n            } else {\r\n                if (currChar === waitForChar) {\r\n                    if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                        block.charAt(currPos - 1) !== '\\\\' && (waitForChar = '');\r\n                    } else {\r\n                        waitForChar = '';\r\n                    }\r\n                } else if (waitForChar === '*/' && currChar === '*' && currPos + 1 < block.length) {\r\n                    block.charAt(currPos + 1) === '/' && (waitForChar = '');\r\n                    if (waitForChar === '') {\r\n                        currPos++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            currPos++ ;\r\n            if (openMarkers === 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return openMarkers === 0 ? currPos - 1 : -1;\r\n    }\r\n\r\n    private _skipWhitespaces(s: string, index: number): number {\r\n        while (index < s.length) {\r\n            const c = s[index];\r\n            if (c !== ' ' && c !== '\\n' && c !== '\\r' && c !== '\\t' && c !== '\\u000a' && c !== '\\u00a0') {\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    private _removeComments(block: string): string {\r\n        let currPos = 0,\r\n            waitForChar = '',\r\n            inComments = false,\r\n            s = [];\r\n\r\n        while (currPos < block.length) {\r\n            let currChar = block.charAt(currPos);\r\n\r\n            if (!waitForChar) {\r\n                switch (currChar) {\r\n                    case '\"':\r\n                    case \"'\":\r\n                    case \"`\":\r\n                        waitForChar = currChar;\r\n                        break;\r\n                    case '/':\r\n                        if (currPos + 1 < block.length) {\r\n                            const nextChar = block.charAt(currPos + 1);\r\n                            if (nextChar === '/') {\r\n                                waitForChar = '\\n';\r\n                                inComments = true;\r\n                            } else if (nextChar === '*') {\r\n                                waitForChar = '*/';\r\n                                inComments = true;\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            } else {\r\n                if (currChar === waitForChar) {\r\n                    if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                        block.charAt(currPos - 1) !== '\\\\' && (waitForChar = '');\r\n                        s.push(currChar);\r\n                    } else {\r\n                        waitForChar = '';\r\n                        inComments = false;\r\n                    }\r\n                } else if (waitForChar === '*/' && currChar === '*' && currPos + 1 < block.length) {\r\n                    block.charAt(currPos + 1) === '/' && (waitForChar = '');\r\n                    if (waitForChar === '') {\r\n                        inComments = false;\r\n                        currPos++;\r\n                    }\r\n                } else {\r\n                    if (!inComments) {\r\n                        s.push(currChar);\r\n                    }\r\n                }\r\n            }\r\n\r\n            currPos++ ;\r\n        }\r\n\r\n        return s.join('');\r\n    }\r\n\r\n    private _replaceFunctionCallsByCode(): boolean {\r\n        let doAgain = false;\r\n\r\n        for (const func of this._functionDescr) {\r\n            const { name, type, parameters, body } = func;\r\n\r\n            let startIndex = 0;\r\n\r\n            while (startIndex < this._sourceCode.length) {\r\n                // Look for the function name in the source code\r\n                const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\r\n\r\n                if (functionCallIndex < 0) {\r\n                    break;\r\n                }\r\n\r\n                // Find the opening parenthesis\r\n                const callParamsStartIndex = this._skipWhitespaces(this._sourceCode, functionCallIndex + name.length);\r\n                if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== '(') {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\r\n                const callParamsEndIndex = this._extractBetweenMarkers('(', ')', this._sourceCode, callParamsStartIndex);\r\n                if (callParamsEndIndex < 0) {\r\n                    if (this.debug) {\r\n                        console.warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n                const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\r\n\r\n                // process the parameter call: extract each names\r\n                const params = this._removeComments(callParams).split(\",\");\r\n                const paramNames = [];\r\n\r\n                for (let p = 0; p < params.length; ++p) {\r\n                    const param = params[p].trim();\r\n                    paramNames.push(param);\r\n                }\r\n\r\n                const retParamName = type !== 'void' ? name + '_' + (func.callIndex++) : null;\r\n\r\n                if (retParamName) {\r\n                    paramNames.push(retParamName + ' =');\r\n                }\r\n\r\n                if (paramNames.length !== parameters.length) {\r\n                    if (this.debug) {\r\n                        console.warn(`Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                startIndex = callParamsEndIndex + 1;\r\n\r\n                // replace the function call by the body function\r\n                const funcBody = this._replaceNames(body, parameters, paramNames);\r\n\r\n                let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\r\n                let partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\r\n\r\n                if (retParamName) {\r\n                    // case where the function returns a value. We generate:\r\n                    // FUNCTYPE retParamName;\r\n                    // {function body}\r\n                    // and replace the function call by retParamName\r\n                    const injectDeclarationIndex = this._findBackward(this._sourceCode, functionCallIndex - 1, '\\n');\r\n\r\n                    partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\r\n                    let partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\r\n\r\n                    this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\r\n\r\n                    if (this.debug) {\r\n                        console.log(`Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}`);\r\n                    }\r\n                } else {\r\n                    // simple case where the return value of the function is \"void\"\r\n                    this._sourceCode = partBefore + funcBody + partAfter;\r\n\r\n                    startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\r\n\r\n                    if (this.debug) {\r\n                        console.log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}`);\r\n                    }\r\n                }\r\n\r\n                doAgain = true;\r\n            }\r\n        }\r\n\r\n        return doAgain;\r\n    }\r\n\r\n    private _findBackward(s: string, index: number, c: string): number {\r\n        while (index >= 0 && s.charAt(index) !== c) {\r\n            index--;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    private _escapeRegExp(s: string): string {\r\n        return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n    }\r\n\r\n    private _replaceNames(code: string, sources: string[], destinations: string[]): string {\r\n\r\n        for (let i = 0; i < sources.length; ++i) {\r\n            const source = new RegExp(this._escapeRegExp(sources[i]), 'g'),\r\n                  destination = destinations[i];\r\n\r\n            code = code.replace(source, destination);\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n"]}