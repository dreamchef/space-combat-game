import { Nullable, IndicesArray, DataArray } from "../types";
import { Engine } from "../Engines/engine";
import { VertexBuffer } from "../Meshes/buffer";
import { InternalTexture } from "../Materials/Textures/internalTexture";
import { BaseTexture } from "../Materials/Textures/baseTexture";
import { Effect } from "../Materials/effect";
import { DataBuffer } from '../Meshes/dataBuffer';
import { Matrix, Viewport, Color3 } from "../Maths/math";
import { IColor4Like } from '../Maths/math.like';
import { Scene } from "../scene";
import { RenderTargetCreationOptions } from "../Materials/Textures/renderTargetCreationOptions";
import { IPipelineContext } from './IPipelineContext';
import { ISceneLike } from './thinEngine';
import { RenderTargetTextureSize } from '../Engines/Extensions/engine.renderTarget';
import { DepthTextureCreationOptions } from '../Engines/depthTextureCreationOptions';
/**
 * Container for accessors for natively-stored mesh data buffers.
 */
declare class NativeDataBuffer extends DataBuffer {
    /**
     * Accessor value used to identify/retrieve a natively-stored index buffer.
     */
    nativeIndexBuffer?: any;
    /**
     * Accessor value used to identify/retrieve a natively-stored vertex buffer.
     */
    nativeVertexBuffer?: any;
}
/** @hidden */
declare class NativeTexture extends InternalTexture {
    getInternalTexture(): InternalTexture;
    getViewCount(): number;
}
/** @hidden */
export declare class NativeEngine extends Engine {
    private readonly _native;
    /** Defines the invalid handle returned by bgfx when resource creation goes wrong */
    private readonly INVALID_HANDLE;
    private _boundBuffersVertexArray;
    private _currentDepthTest;
    getHardwareScalingLevel(): number;
    constructor();
    dispose(): void;
    /**
     * Can be used to override the current requestAnimationFrame requester.
     * @hidden
     */
    protected _queueNewFrame(bindedRenderFunction: any, requester?: any): number;
    /**
     * Override default engine behavior.
     * @param color
     * @param backBuffer
     * @param depth
     * @param stencil
     */
    _bindUnboundFramebuffer(framebuffer: Nullable<WebGLFramebuffer>): void;
    /**
     * Gets host document
     * @returns the host document object
     */
    getHostDocument(): Nullable<Document>;
    clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil?: boolean): void;
    createIndexBuffer(indices: IndicesArray, updateable?: boolean): NativeDataBuffer;
    createVertexBuffer(data: DataArray, updateable?: boolean): NativeDataBuffer;
    protected _recordVertexArrayObject(vertexArray: any, vertexBuffers: {
        [key: string]: VertexBuffer;
    }, indexBuffer: Nullable<NativeDataBuffer>, effect: Effect): void;
    bindBuffers(vertexBuffers: {
        [key: string]: VertexBuffer;
    }, indexBuffer: Nullable<NativeDataBuffer>, effect: Effect): void;
    recordVertexArrayObject(vertexBuffers: {
        [key: string]: VertexBuffer;
    }, indexBuffer: Nullable<NativeDataBuffer>, effect: Effect): WebGLVertexArrayObject;
    bindVertexArrayObject(vertexArray: WebGLVertexArrayObject): void;
    releaseVertexArrayObject(vertexArray: WebGLVertexArrayObject): void;
    getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[];
    /**
     * Draw a list of indexed primitives
     * @param fillMode defines the primitive to use
     * @param indexStart defines the starting index
     * @param indexCount defines the number of index to draw
     * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
     */
    drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void;
    /**
     * Draw a list of unindexed primitives
     * @param fillMode defines the primitive to use
     * @param verticesStart defines the index of first vertex to draw
     * @param verticesCount defines the count of vertices to draw
     * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
     */
    drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void;
    createPipelineContext(): IPipelineContext;
    _preparePipelineContext(pipelineContext: IPipelineContext, vertexSourceCode: string, fragmentSourceCode: string, createAsRaw: boolean, rebuildRebind: any, defines: Nullable<string>, transformFeedbackVaryings: Nullable<string[]>): void;
    /** @hidden */
    _isRenderingStateCompiled(pipelineContext: IPipelineContext): boolean;
    /** @hidden */
    _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void): void;
    createRawShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, context?: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): any;
    createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: Nullable<string>, context?: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): any;
    protected _setProgram(program: WebGLProgram): void;
    _releaseEffect(effect: Effect): void;
    _deletePipelineContext(pipelineContext: IPipelineContext): void;
    getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): WebGLUniformLocation[];
    bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void;
    bindSamplers(effect: Effect): void;
    setMatrix(uniform: WebGLUniformLocation, matrix: Matrix): void;
    getRenderWidth(useScreen?: boolean): number;
    getRenderHeight(useScreen?: boolean): number;
    setViewport(viewport: Viewport, requiredWidth?: number, requiredHeight?: number): void;
    setState(culling: boolean, zOffset?: number, force?: boolean, reverseSide?: boolean): void;
    /**
     * Set the z offset to apply to current rendering
     * @param value defines the offset to apply
     */
    setZOffset(value: number): void;
    /**
     * Gets the current value of the zOffset
     * @returns the current zOffset state
     */
    getZOffset(): number;
    /**
     * Enable or disable depth buffering
     * @param enable defines the state to set
     */
    setDepthBuffer(enable: boolean): void;
    /**
     * Gets a boolean indicating if depth writing is enabled
     * @returns the current depth writing state
     */
    getDepthWrite(): boolean;
    setDepthFunctionToGreater(): void;
    setDepthFunctionToGreaterOrEqual(): void;
    setDepthFunctionToLess(): void;
    setDepthFunctionToLessOrEqual(): void;
    /**
     * Enable or disable depth writing
     * @param enable defines the state to set
     */
    setDepthWrite(enable: boolean): void;
    /**
     * Enable or disable color writing
     * @param enable defines the state to set
     */
    setColorWrite(enable: boolean): void;
    /**
     * Gets a boolean indicating if color writing is enabled
     * @returns the current color writing state
     */
    getColorWrite(): boolean;
    /**
     * Sets alpha constants used by some alpha blending modes
     * @param r defines the red component
     * @param g defines the green component
     * @param b defines the blue component
     * @param a defines the alpha component
     */
    setAlphaConstants(r: number, g: number, b: number, a: number): void;
    /**
     * Sets the current alpha mode
     * @param mode defines the mode to use (one of the BABYLON.undefined)
     * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)
     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
     */
    setAlphaMode(mode: number, noDepthWriteChange?: boolean): void;
    /**
     * Gets the current alpha mode
     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
     * @returns the current alpha mode
     */
    getAlphaMode(): number;
    setInt(uniform: WebGLUniformLocation, int: number): boolean;
    setIntArray(uniform: WebGLUniformLocation, array: Int32Array): boolean;
    setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): boolean;
    setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): boolean;
    setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): boolean;
    setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): boolean;
    setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): boolean;
    setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): boolean;
    setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): boolean;
    setArray(uniform: WebGLUniformLocation, array: number[]): boolean;
    setArray2(uniform: WebGLUniformLocation, array: number[]): boolean;
    setArray3(uniform: WebGLUniformLocation, array: number[]): boolean;
    setArray4(uniform: WebGLUniformLocation, array: number[]): boolean;
    setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): boolean;
    setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): boolean;
    setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): boolean;
    setFloat(uniform: WebGLUniformLocation, value: number): boolean;
    setFloat2(uniform: WebGLUniformLocation, x: number, y: number): boolean;
    setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): boolean;
    setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): boolean;
    setColor3(uniform: WebGLUniformLocation, color3: Color3): boolean;
    setColor4(uniform: WebGLUniformLocation, color3: Color3, alpha: number): boolean;
    wipeCaches(bruteForce?: boolean): void;
    _createTexture(): WebGLTexture;
    protected _deleteTexture(texture: Nullable<WebGLTexture>): void;
    /**
     * Update the content of a dynamic texture
     * @param texture defines the texture to update
     * @param canvas defines the canvas containing the source
     * @param invertY defines if data must be stored with Y axis inverted
     * @param premulAlpha defines if alpha is stored as premultiplied
     * @param format defines the format of the data
     * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)
     */
    updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: HTMLCanvasElement, invertY: boolean, premulAlpha?: boolean, format?: number): void;
    /**
     * Usually called from Texture.ts.
     * Passed information to create a WebGLTexture
     * @param url defines a value which contains one of the following:
     * * A conventional http URL, e.g. 'http://...' or 'file://...'
     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
     * @param scene needed for loading to the correct scene
     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
     * @param onLoad optional callback to be called upon successful completion
     * @param onError optional callback to be called upon failure
     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
     * @param forcedExtension defines the extension to use to pick the right loader
     * @param mimeType defines an optional mime type
     * @param loaderOptions options to be passed to the loader
     * @returns a InternalTexture for assignment back into BABYLON.Texture
     */
    createTexture(url: Nullable<string>, noMipmap: boolean, invertY: boolean, scene: Nullable<ISceneLike>, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message: string, exception: any) => void>, buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>, fallback?: Nullable<InternalTexture>, format?: Nullable<number>, forcedExtension?: Nullable<string>, mimeType?: string, loaderOptions?: any): InternalTexture;
    _createDepthStencilTexture(size: RenderTargetTextureSize, options: DepthTextureCreationOptions): NativeTexture;
    _releaseFramebufferObjects(texture: InternalTexture): void;
    /**
     * Creates a cube texture
     * @param rootUrl defines the url where the files to load is located
     * @param scene defines the current scene
     * @param files defines the list of files to load (1 per face)
     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)
     * @param onLoad defines an optional callback raised when the texture is loaded
     * @param onError defines an optional callback raised if there is an issue to load the texture
     * @param format defines the format of the data
     * @param forcedExtension defines the extension to use to pick the right loader
     * @param createPolynomials if a polynomial sphere should be created for the cube texture
     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
     * @param fallback defines texture to use while falling back when (compressed) texture file not found.
     * @returns the cube texture as an InternalTexture
     */
    createCubeTexture(rootUrl: string, scene: Nullable<Scene>, files: Nullable<string[]>, noMipmap?: boolean, onLoad?: Nullable<(data?: any) => void>, onError?: Nullable<(message?: string, exception?: any) => void>, format?: number, forcedExtension?: any, createPolynomials?: boolean, lodScale?: number, lodOffset?: number, fallback?: Nullable<InternalTexture>): InternalTexture;
    createRenderTargetTexture(size: number | {
        width: number;
        height: number;
    }, options: boolean | RenderTargetCreationOptions): NativeTexture;
    updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void;
    bindFramebuffer(texture: InternalTexture, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void;
    unBindFramebuffer(texture: InternalTexture, disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;
    createDynamicVertexBuffer(data: DataArray): DataBuffer;
    updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset?: number): void;
    /**
     * Updates a dynamic vertex buffer.
     * @param vertexBuffer the vertex buffer to update
     * @param data the data used to update the vertex buffer
     * @param byteOffset the byte offset of the data (optional)
     * @param byteLength the byte length of the data (optional)
     */
    updateDynamicVertexBuffer(vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void;
    protected _setTexture(channel: number, texture: Nullable<BaseTexture>, isPartOfTextureArray?: boolean, depthStencilTexture?: boolean): boolean;
    private _updateAnisotropicLevel;
    private _getAddressMode;
    /** @hidden */
    _bindTexture(channel: number, texture: InternalTexture): void;
    protected _deleteBuffer(buffer: NativeDataBuffer): void;
    releaseEffects(): void;
    /** @hidden */
    _uploadCompressedDataToTextureDirectly(texture: InternalTexture, internalFormat: number, width: number, height: number, data: ArrayBufferView, faceIndex?: number, lod?: number): void;
    /** @hidden */
    _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex?: number, lod?: number): void;
    /** @hidden */
    _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex?: number, lod?: number): void;
    /** @hidden */
    _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement, faceIndex?: number, lod?: number): void;
    private _getNativeSamplingMode;
    private _getNativeTextureFormat;
    private _getNativeAlphaMode;
    private _getNativeAttribType;
}
export {};
