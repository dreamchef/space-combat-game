{"version":3,"file":"windowsMotionController.js","sourceRoot":"","sources":["../../../../sourceES6/core/Gamepads/Controllers/windowsMotionController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { WebVRController } from \"./webVRController\";\r\nimport { GenericController } from \"./genericController\";\r\nimport { PoseEnabledController, PoseEnabledControllerType, ExtendedGamepadButton, PoseEnabledControllerHelper } from \"./poseEnabledController\";\r\nimport { StickValues, GamepadButtonChanges } from \"../../Gamepads/gamepad\";\r\n\r\n/**\r\n * Defines the LoadedMeshInfo object that describes information about the loaded webVR controller mesh\r\n */\r\nclass LoadedMeshInfo {\r\n    /**\r\n     * Root of the mesh\r\n     */\r\n    public rootNode: AbstractMesh;\r\n    /**\r\n     * Node of the mesh corresponding to the direction the ray should be cast from the controller\r\n     */\r\n    public pointingPoseNode: TransformNode;\r\n    /**\r\n     * Map of the button meshes contained in the controller\r\n     */\r\n    public buttonMeshes: { [id: string]: IButtonMeshInfo; } = {};\r\n    /**\r\n     * Map of the axis meshes contained in the controller\r\n     */\r\n    public axisMeshes: { [id: number]: IAxisMeshInfo; } = {};\r\n}\r\n\r\n/**\r\n * Defines the IMeshInfo object that describes information a webvr controller mesh\r\n */\r\ninterface IMeshInfo {\r\n    /**\r\n     * Index of the mesh inside the root mesh\r\n     */\r\n    index: number;\r\n    /**\r\n     * The mesh\r\n     */\r\n    value: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the IButtonMeshInfo object that describes a button mesh\r\n */\r\ninterface IButtonMeshInfo extends IMeshInfo {\r\n    /**\r\n     * The mesh that should be displayed when pressed\r\n     */\r\n    pressed: TransformNode;\r\n    /**\r\n     * The mesh that should be displayed when not pressed\r\n     */\r\n    unpressed: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the IAxisMeshInfo object that describes an axis mesh\r\n */\r\ninterface IAxisMeshInfo extends IMeshInfo {\r\n    /**\r\n     * The mesh that should be set when at its min\r\n     */\r\n    min: TransformNode;\r\n    /**\r\n     * The mesh that should be set when at its max\r\n     */\r\n    max: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the WindowsMotionController object that the state of the windows motion controller\r\n */\r\nexport class WindowsMotionController extends WebVRController {\r\n    /**\r\n     * The base url used to load the left and right controller models\r\n     */\r\n    public static MODEL_BASE_URL: string = 'https://controllers.babylonjs.com/microsoft/';\r\n    /**\r\n     * The name of the left controller model file\r\n     */\r\n    public static MODEL_LEFT_FILENAME: string = 'left.glb';\r\n    /**\r\n     * The name of the right controller model file\r\n     */\r\n    public static MODEL_RIGHT_FILENAME: string = 'right.glb';\r\n\r\n    /**\r\n     * The controller name prefix for this controller type\r\n     */\r\n    public static readonly GAMEPAD_ID_PREFIX: string = 'Spatial Controller (Spatial Interaction Source) ';\r\n    /**\r\n     * The controller id pattern for this controller type\r\n     */\r\n    private static readonly GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;\r\n\r\n    private _loadedMeshInfo: Nullable<LoadedMeshInfo>;\r\n    protected readonly _mapping = {\r\n        // Semantic button names\r\n        buttons: ['thumbstick', 'trigger', 'grip', 'menu', 'trackpad'],\r\n        // trigger, grip, trackpad, thumbstick, menu\r\n\r\n        // A mapping of the button name to glTF model node name\r\n        // that should be transformed by button value.\r\n        buttonMeshNames: {\r\n            'trigger': 'SELECT',\r\n            'menu': 'MENU',\r\n            'grip': 'GRASP',\r\n            'thumbstick': 'THUMBSTICK_PRESS',\r\n            'trackpad': 'TOUCHPAD_PRESS'\r\n        },\r\n        // This mapping is used to translate from the Motion Controller to Babylon semantics\r\n        buttonObservableNames: {\r\n            'trigger': 'onTriggerStateChangedObservable',\r\n            'menu': 'onSecondaryButtonStateChangedObservable',\r\n            'grip': 'onMainButtonStateChangedObservable',\r\n            'thumbstick': 'onPadStateChangedObservable',\r\n            'trackpad': 'onTrackpadChangedObservable'\r\n        },\r\n        // A mapping of the axis name to glTF model node name\r\n        // that should be transformed by axis value.\r\n        // This array mirrors the browserGamepad.axes array, such that\r\n        // the mesh corresponding to axis 0 is in this array index 0.\r\n        axisMeshNames: [\r\n            'THUMBSTICK_X',\r\n            'THUMBSTICK_Y',\r\n            'TOUCHPAD_TOUCH_X',\r\n            'TOUCHPAD_TOUCH_Y'\r\n        ],\r\n        // upside down in webxr\r\n        pointingPoseMeshName: PoseEnabledController.POINTING_POSE\r\n    };\r\n\r\n    /**\r\n     * Fired when the trackpad on this controller is clicked\r\n     */\r\n    public onTrackpadChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the trackpad on this controller is modified\r\n     */\r\n    public onTrackpadValuesChangedObservable = new Observable<StickValues>();\r\n    /**\r\n     * The current x and y values of this controller's trackpad\r\n     */\r\n    public trackpad: StickValues = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Creates a new WindowsMotionController from a gamepad\r\n     * @param vrGamepad the gamepad that the controller should be created from\r\n     */\r\n    constructor(vrGamepad: any) {\r\n        super(vrGamepad);\r\n        this.controllerType = PoseEnabledControllerType.WINDOWS;\r\n        this._loadedMeshInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Fired when the trigger on this controller is modified\r\n     */\r\n    public get onTriggerButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onTriggerStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the menu button on this controller is modified\r\n     */\r\n    public get onMenuButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onSecondaryButtonStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the grip button on this controller is modified\r\n     */\r\n    public get onGripButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onMainButtonStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     */\r\n    public get onThumbstickButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onPadStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\r\n    public get onTouchpadButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onTrackpadChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\r\n    public get onTouchpadValuesChangedObservable(): Observable<StickValues> {\r\n        return this.onTrackpadValuesChangedObservable;\r\n    }\r\n\r\n    protected _updateTrackpad() {\r\n        if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {\r\n            this.trackpad.x = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf('TOUCHPAD_TOUCH_X')];\r\n            this.trackpad.y = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf('TOUCHPAD_TOUCH_Y')];\r\n            this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called once per frame by the engine.\r\n     */\r\n    public update() {\r\n        super.update();\r\n        if (this.browserGamepad.axes) {\r\n            this._updateTrackpad();\r\n            // Only need to animate axes if there is a loaded mesh\r\n            if (this._loadedMeshInfo) {\r\n                for (let axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {\r\n                    this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called once for each button that changed state since the last frame\r\n     * @param buttonIdx Which button index changed\r\n     * @param state New state of the button\r\n     * @param changes Which properties on the state changed since last frame\r\n     */\r\n    protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges) {\r\n        let buttonName = this._mapping.buttons[buttonIdx];\r\n        if (!buttonName) {\r\n            return;\r\n        }\r\n\r\n        // Update the trackpad to ensure trackpad.x/y are accurate during button events between frames\r\n        this._updateTrackpad();\r\n\r\n        // Only emit events for buttons that we know how to map from index to name\r\n        let observable = (<any>this)[(<any>(this._mapping.buttonObservableNames))[buttonName]];\r\n        if (observable) {\r\n            observable.notifyObservers(state);\r\n        }\r\n\r\n        this._lerpButtonTransform(buttonName, state.value);\r\n    }\r\n\r\n    /**\r\n     * Moves the buttons on the controller mesh based on their current state\r\n     * @param buttonName the name of the button to move\r\n     * @param buttonValue the value of the button which determines the buttons new position\r\n     */\r\n    protected _lerpButtonTransform(buttonName: string, buttonValue: number) {\r\n\r\n        // If there is no loaded mesh, there is nothing to transform.\r\n        if (!this._loadedMeshInfo) {\r\n            return;\r\n        }\r\n\r\n        var meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];\r\n\r\n        if (!meshInfo || !meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        Quaternion.SlerpToRef(\r\n            meshInfo.unpressed.rotationQuaternion,\r\n            meshInfo.pressed.rotationQuaternion,\r\n            buttonValue,\r\n            meshInfo.value.rotationQuaternion);\r\n        Vector3.LerpToRef(\r\n            meshInfo.unpressed.position,\r\n            meshInfo.pressed.position,\r\n            buttonValue,\r\n            meshInfo.value.position);\r\n    }\r\n\r\n    /**\r\n     * Moves the axis on the controller mesh based on its current state\r\n     * @param axis the index of the axis\r\n     * @param axisValue the value of the axis which determines the meshes new position\r\n     * @hidden\r\n     */\r\n    protected _lerpAxisTransform(axis: number, axisValue: number) {\r\n        if (!this._loadedMeshInfo) {\r\n            return;\r\n        }\r\n\r\n        let meshInfo = this._loadedMeshInfo.axisMeshes[axis];\r\n        if (!meshInfo) {\r\n            return;\r\n        }\r\n\r\n        if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\r\n        let lerpValue = axisValue * 0.5 + 0.5;\r\n        Quaternion.SlerpToRef(\r\n            meshInfo.min.rotationQuaternion,\r\n            meshInfo.max.rotationQuaternion,\r\n            lerpValue,\r\n            meshInfo.value.rotationQuaternion);\r\n        Vector3.LerpToRef(\r\n            meshInfo.min.position,\r\n            meshInfo.max.position,\r\n            lerpValue,\r\n            meshInfo.value.position);\r\n    }\r\n\r\n    /**\r\n     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.\r\n     * @param scene scene in which to add meshes\r\n     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.\r\n     */\r\n    public initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void, forceDefault = false) {\r\n        let path: string;\r\n        let filename: string;\r\n\r\n        // Checking if GLB loader is present\r\n        if (SceneLoader.IsPluginForExtensionAvailable(\".glb\")) {\r\n            // Determine the device specific folder based on the ID suffix\r\n            let device = 'default';\r\n            if (this.id && !forceDefault) {\r\n                let match = this.id.match(WindowsMotionController.GAMEPAD_ID_PATTERN);\r\n                device = ((match && match[0]) || device);\r\n            }\r\n\r\n            // Hand\r\n            if (this.hand === 'left') {\r\n                filename = WindowsMotionController.MODEL_LEFT_FILENAME;\r\n            }\r\n            else { // Right is the default if no hand is specified\r\n                filename = WindowsMotionController.MODEL_RIGHT_FILENAME;\r\n            }\r\n\r\n            path = WindowsMotionController.MODEL_BASE_URL + device + '/';\r\n        } else {\r\n            Logger.Warn(\"You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models\");\r\n            path = GenericController.MODEL_BASE_URL;\r\n            filename = GenericController.MODEL_FILENAME;\r\n        }\r\n\r\n        SceneLoader.ImportMesh(\"\", path, filename, scene, (meshes: AbstractMesh[]) => {\r\n            // glTF files successfully loaded from the remote server, now process them to ensure they are in the right format.\r\n            this._loadedMeshInfo = this.processModel(scene, meshes);\r\n\r\n            if (!this._loadedMeshInfo) {\r\n                return;\r\n            }\r\n\r\n            this._defaultModel = this._loadedMeshInfo.rootNode;\r\n            this.attachToMesh(this._defaultModel);\r\n\r\n            if (meshLoaded) {\r\n                meshLoaded(this._defaultModel);\r\n            }\r\n        }, null, (scene: Scene, message: string) => {\r\n            Logger.Log(message);\r\n            Logger.Warn('Failed to retrieve controller model from the remote server: ' + path + filename);\r\n            if (!forceDefault) {\r\n                this.initControllerMesh(scene, meshLoaded, true);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that\r\n     * can be transformed by button presses and axes values, based on this._mapping.\r\n     *\r\n     * @param scene scene in which the meshes exist\r\n     * @param meshes list of meshes that make up the controller model to process\r\n     * @return structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.\r\n     */\r\n    private processModel(scene: Scene, meshes: AbstractMesh[]): Nullable<LoadedMeshInfo> {\r\n        let loadedMeshInfo = null;\r\n\r\n        // Create a new mesh to contain the glTF hierarchy\r\n        let parentMesh = new Mesh(this.id + \" \" + this.hand, scene);\r\n\r\n        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\r\n        let childMesh: Nullable<AbstractMesh> = null;\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            let mesh = meshes[i];\r\n\r\n            if (!mesh.parent) {\r\n                // Exclude controller meshes from picking results\r\n                mesh.isPickable = false;\r\n\r\n                // Handle root node, attach to the new parentMesh\r\n                childMesh = mesh;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (childMesh) {\r\n            childMesh.setParent(parentMesh);\r\n\r\n            // Create our mesh info. Note that this method will always return non-null.\r\n            loadedMeshInfo = this.createMeshInfo(parentMesh);\r\n        } else {\r\n            Logger.Warn('Could not find root node in model file.');\r\n        }\r\n\r\n        return loadedMeshInfo;\r\n    }\r\n\r\n    private createMeshInfo(rootNode: AbstractMesh): LoadedMeshInfo {\r\n        let loadedMeshInfo = new LoadedMeshInfo();\r\n        var i;\r\n        loadedMeshInfo.rootNode = rootNode;\r\n\r\n        // Reset the caches\r\n        loadedMeshInfo.buttonMeshes = {};\r\n        loadedMeshInfo.axisMeshes = {};\r\n\r\n        // Button Meshes\r\n        for (i = 0; i < this._mapping.buttons.length; i++) {\r\n            var buttonMeshName = (<any>this._mapping.buttonMeshNames)[this._mapping.buttons[i]];\r\n            if (!buttonMeshName) {\r\n                Logger.Log('Skipping unknown button at index: ' + i + ' with mapped name: ' + this._mapping.buttons[i]);\r\n                continue;\r\n            }\r\n\r\n            var buttonMesh = getChildByName(rootNode, buttonMeshName);\r\n            if (!buttonMesh) {\r\n                Logger.Warn('Missing button mesh with name: ' + buttonMeshName);\r\n                continue;\r\n            }\r\n\r\n            var buttonMeshInfo = {\r\n                index: i,\r\n                value: getImmediateChildByName(buttonMesh, 'VALUE'),\r\n                pressed: getImmediateChildByName(buttonMesh, 'PRESSED'),\r\n                unpressed: getImmediateChildByName(buttonMesh, 'UNPRESSED')\r\n            };\r\n            if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {\r\n                loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;\r\n            } else {\r\n                // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\r\n                Logger.Warn('Missing button submesh under mesh with name: ' + buttonMeshName +\r\n                    '(VALUE: ' + !!buttonMeshInfo.value +\r\n                    ', PRESSED: ' + !!buttonMeshInfo.pressed +\r\n                    ', UNPRESSED:' + !!buttonMeshInfo.unpressed +\r\n                    ')');\r\n            }\r\n        }\r\n\r\n        // Axis Meshes\r\n        for (i = 0; i < this._mapping.axisMeshNames.length; i++) {\r\n            var axisMeshName = this._mapping.axisMeshNames[i];\r\n            if (!axisMeshName) {\r\n                Logger.Log('Skipping unknown axis at index: ' + i);\r\n                continue;\r\n            }\r\n\r\n            var axisMesh = getChildByName(rootNode, axisMeshName);\r\n            if (!axisMesh) {\r\n                Logger.Warn('Missing axis mesh with name: ' + axisMeshName);\r\n                continue;\r\n            }\r\n\r\n            var axisMeshInfo = {\r\n                index: i,\r\n                value: getImmediateChildByName(axisMesh, 'VALUE'),\r\n                min: getImmediateChildByName(axisMesh, 'MIN'),\r\n                max: getImmediateChildByName(axisMesh, 'MAX')\r\n            };\r\n            if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {\r\n                loadedMeshInfo.axisMeshes[i] = axisMeshInfo;\r\n            } else {\r\n                // If we didn't find the mesh, it simply means thit axis won't have transforms applied as mapped axis values change.\r\n                Logger.Warn('Missing axis submesh under mesh with name: ' + axisMeshName +\r\n                    '(VALUE: ' + !!axisMeshInfo.value +\r\n                    ', MIN: ' + !!axisMeshInfo.min +\r\n                    ', MAX:' + !!axisMeshInfo.max +\r\n                    ')');\r\n            }\r\n        }\r\n\r\n        // Pointing Ray\r\n        loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);\r\n        if (!loadedMeshInfo.pointingPoseNode) {\r\n            Logger.Warn('Missing pointing pose mesh with name: ' + this._mapping.pointingPoseMeshName);\r\n        } else {\r\n            this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;\r\n        }\r\n\r\n        return loadedMeshInfo;\r\n\r\n        // Look through all children recursively. This will return null if no mesh exists with the given name.\r\n        function getChildByName(node: Node, name: string) {\r\n            return <TransformNode>node.getChildren((n) => n.name === name, false)[0];\r\n        }\r\n        // Look through only immediate children. This will return null if no mesh exists with the given name.\r\n        function getImmediateChildByName(node: Node, name: string): TransformNode {\r\n            return <TransformNode>node.getChildren((n) => n.name == name, true)[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the ray of the controller in the direction the controller is pointing\r\n     * @param length the length the resulting ray should be\r\n     * @returns a ray in the direction the controller is pointing\r\n     */\r\n    public getForwardRay(length = 100): Ray {\r\n        if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {\r\n            return super.getForwardRay(length);\r\n        }\r\n\r\n        var m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();\r\n        var origin = m.getTranslation();\r\n\r\n        var forward = new Vector3(0, 0, -1);\r\n        var forwardWorld = Vector3.TransformNormal(forward, m);\r\n\r\n        var direction = Vector3.Normalize(forwardWorld);\r\n\r\n        return new Ray(origin, direction, length);\r\n    }\r\n\r\n    /**\r\n    * Disposes of the controller\r\n    */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onTrackpadChangedObservable.clear();\r\n        this.onTrackpadValuesChangedObservable.clear();\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a new windows motion controller in XR.\r\n */\r\nexport class XRWindowsMotionController extends WindowsMotionController {\r\n\r\n    /**\r\n     * Changing the original WIndowsMotionController mapping to fir the new mapping\r\n     */\r\n    protected readonly _mapping = {\r\n        // Semantic button names\r\n        buttons: ['trigger', 'grip', 'trackpad', 'thumbstick', 'menu'],\r\n        // trigger, grip, trackpad, thumbstick, menu\r\n\r\n        // A mapping of the button name to glTF model node name\r\n        // that should be transformed by button value.\r\n        buttonMeshNames: {\r\n            'trigger': 'SELECT',\r\n            'menu': 'MENU',\r\n            'grip': 'GRASP',\r\n            'thumbstick': 'THUMBSTICK_PRESS',\r\n            'trackpad': 'TOUCHPAD_PRESS'\r\n        },\r\n        // This mapping is used to translate from the Motion Controller to Babylon semantics\r\n        buttonObservableNames: {\r\n            'trigger': 'onTriggerStateChangedObservable',\r\n            'menu': 'onSecondaryButtonStateChangedObservable',\r\n            'grip': 'onMainButtonStateChangedObservable',\r\n            'thumbstick': 'onThumbstickStateChangedObservable',\r\n            'trackpad': 'onTrackpadChangedObservable'\r\n        },\r\n        // A mapping of the axis name to glTF model node name\r\n        // that should be transformed by axis value.\r\n        // This array mirrors the browserGamepad.axes array, such that\r\n        // the mesh corresponding to axis 0 is in this array index 0.\r\n        axisMeshNames: [\r\n            'TOUCHPAD_TOUCH_X',\r\n            'TOUCHPAD_TOUCH_Y',\r\n            'THUMBSTICK_X',\r\n            'THUMBSTICK_Y'\r\n        ],\r\n        // upside down in webxr\r\n        pointingPoseMeshName: PoseEnabledController.POINTING_POSE\r\n    };\r\n\r\n    /**\r\n     * Construct a new XR-Based windows motion controller\r\n     *\r\n     * @param gamepadInfo the gamepad object from the browser\r\n     */\r\n    constructor(gamepadInfo: any) {\r\n        super(gamepadInfo);\r\n    }\r\n\r\n    /**\r\n     * holds the thumbstick values (X,Y)\r\n     */\r\n    public thumbstickValues: StickValues = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Fired when the thumbstick on this controller is clicked\r\n     */\r\n    public onThumbstickStateChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the thumbstick on this controller is modified\r\n     */\r\n    public onThumbstickValuesChangedObservable = new Observable<StickValues>();\r\n\r\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\r\n    public onTrackpadChangedObservable = this.onPadStateChangedObservable;\r\n\r\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\r\n    public onTrackpadValuesChangedObservable = this.onPadValuesChangedObservable;\r\n\r\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     * here to prevent breaking changes\r\n     */\r\n    public get onThumbstickButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onThumbstickStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * updating the thumbstick(!) and not the trackpad.\r\n     * This is named this way due to the difference between WebVR and XR and to avoid\r\n     * changing the parent class.\r\n     */\r\n    protected _updateTrackpad() {\r\n        if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.thumbstickValues.x || this.browserGamepad.axes[3] != this.thumbstickValues.y)) {\r\n            this.trackpad.x = this.browserGamepad[\"axes\"][2];\r\n            this.trackpad.y = this.browserGamepad[\"axes\"][3];\r\n            this.onThumbstickValuesChangedObservable.notifyObservers(this.trackpad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the class with joy\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onThumbstickStateChangedObservable.clear();\r\n        this.onThumbstickValuesChangedObservable.clear();\r\n    }\r\n\r\n}\r\n\r\nPoseEnabledControllerHelper._ControllerFactories.push({\r\n    canCreate: (gamepadInfo) => {\r\n        return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;\r\n    },\r\n    create: (gamepadInfo) => {\r\n        return new WindowsMotionController(gamepadInfo);\r\n    }\r\n});\r\n"]}