{"version":3,"file":"planeRotationGizmo.js","sourceRoot":"","sources":["../../../sourceES6/core/Gizmos/planeRotationGizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observer, Observable } from \"../Misc/observable\";\nimport { Nullable } from \"../types\";\nimport { PointerInfo } from \"../Events/pointerEvents\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport \"../Meshes/Builders/linesBuilder\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { LinesMesh } from '../Meshes/linesMesh';\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Node } from \"../node\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { Gizmo, GizmoAxisCache } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { RotationGizmo } from \"./rotationGizmo\";\n\n/**\n * Single plane rotation gizmo\n */\nexport class PlaneRotationGizmo extends Gizmo {\n    /**\n     * Drag behavior responsible for the gizmos dragging interactions\n     */\n    public dragBehavior: PointerDragBehavior;\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\n\n    /**\n     * Rotation distance in radians that the gizmo will snap to (Default: 0)\n     */\n    public snapDistance = 0;\n    /**\n     * Event that fires each time the gizmo snaps to a new location.\n     * * snapDistance is the the change in distance\n     */\n    public onSnapObservable = new Observable<{ snapDistance: number }>();\n\n    private _isEnabled: boolean = true;\n    private _parent: Nullable<RotationGizmo> = null;\n    private _coloredMaterial: StandardMaterial;\n    private _hoverMaterial: StandardMaterial;\n    private _disableMaterial: StandardMaterial;\n    private _gizmoMesh: Mesh;\n    private _rotationCircle: Mesh;\n    private _dragging: boolean = false;\n\n    private static _CircleConstants = {\n        radius: 0.3,\n        pi2: Math.PI * 2,\n        tessellation: 70,\n        rotationCircleRange: 4\n    };\n\n    /**\n     * Creates a PlaneRotationGizmo\n     * @param gizmoLayer The utility layer the gizmo will be added to\n     * @param planeNormal The normal of the plane which the gizmo will be able to rotate on\n     * @param color The color of the gizmo\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\n     * @param useEulerRotation Use and update Euler angle instead of quaternion\n     * @param thickness display gizmo axis thickness\n     */\n    constructor(planeNormal: Vector3, color: Color3 = Color3.Gray(), gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, parent: Nullable<RotationGizmo> = null, useEulerRotation = false, thickness: number = 1) {\n        super(gizmoLayer);\n        this._parent = parent;\n        // Create Material\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._coloredMaterial.diffuseColor = color;\n        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n\n        this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._hoverMaterial.diffuseColor = Color3.Yellow();\n\n        this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._disableMaterial.diffuseColor = Color3.Gray();\n        this._disableMaterial.alpha = 0.4;\n\n        // Build mesh on root node\n        this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\n        const { rotationMesh, collider } = this._createGizmoMesh(this._gizmoMesh, thickness, tessellation);\n\n        // Setup Rotation Circle\n        const rotationCirclePaths: any[] = [];\n        this._rotationCircle = this.setupRotationCircle(rotationCirclePaths, this._gizmoMesh);\n\n        this._gizmoMesh.lookAt(this._rootMesh.position.add(planeNormal));\n        this._rootMesh.addChild(this._gizmoMesh);\n        this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n        // Add drag behavior to handle events when the gizmo is dragged\n        this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: planeNormal });\n        this.dragBehavior.moveAttached = false;\n        this.dragBehavior.maxDragAngle = Math.PI * 9 / 20;\n        this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;\n        this._rootMesh.addBehavior(this.dragBehavior);\n\n        // Closures for drag logic\n        let dragDistance = 0;\n        const lastDragPosition = new Vector3();\n        let dragPlanePoint = new Vector3();\n        const rotationMatrix = new Matrix();\n        const planeNormalTowardsCamera = new Vector3();\n        let localPlaneNormalTowardsCamera = new Vector3();\n\n        this.dragBehavior.onDragStartObservable.add((e) => {\n            if (this.attachedNode) {\n                lastDragPosition.copyFrom(e.dragPlanePoint);\n\n                // This is for instantiation location of rotation circle\n                const forward = new Vector3(0, 0, 1);\n                const direction = this._rotationCircle.getDirection(forward);\n                direction.normalize();\n\n                // Remove Rotation Circle from parent mesh before drag interaction\n                this._gizmoMesh.removeChild(this._rotationCircle);\n\n                lastDragPosition.copyFrom(e.dragPlanePoint);\n                dragPlanePoint = e.dragPlanePoint;\n                const origin = this._rotationCircle.getAbsolutePosition().clone();\n                const originalRotationPoint = this._rotationCircle.getAbsolutePosition().clone().addInPlace(direction);\n                const dragStartPoint = e.dragPlanePoint;\n                const angle = Vector3.GetAngleBetweenVectors(originalRotationPoint.subtract(origin), dragStartPoint.subtract(origin), this._rotationCircle.up);\n\n                this._rotationCircle.addRotation(0, angle, 0);\n                this._dragging = true;\n            }\n        });\n\n        this.dragBehavior.onDragEndObservable.add(() => {\n            dragDistance = 0;\n            this.updateRotationCircle(this._rotationCircle, rotationCirclePaths, dragDistance, dragPlanePoint);\n            this._gizmoMesh.addChild(this._rotationCircle);    // Add rotation circle back to parent mesh after drag behavior\n            this._dragging = false;\n        });\n\n        var tmpSnapEvent = { snapDistance: 0 };\n        var currentSnapDragDistance = 0;\n        var tmpMatrix = new Matrix();\n        var amountToRotate = new Quaternion();\n        this.dragBehavior.onDragObservable.add((event) => {\n            if (this.attachedNode) {\n                // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)\n                var nodeScale = new Vector3(1, 1, 1);\n                var nodeQuaternion = new Quaternion(0, 0, 0, 1);\n                var nodeTranslation = new Vector3(0, 0, 0);\n                this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);\n\n                var newVector = event.dragPlanePoint.subtract(nodeTranslation).normalize();\n                var originalVector = lastDragPosition.subtract(nodeTranslation).normalize();\n                var cross = Vector3.Cross(newVector, originalVector);\n                var dot = Vector3.Dot(newVector, originalVector);\n                var angle = Math.atan2(cross.length(), dot);\n                planeNormalTowardsCamera.copyFrom(planeNormal);\n                localPlaneNormalTowardsCamera.copyFrom(planeNormal);\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\n                    nodeQuaternion.toRotationMatrix(rotationMatrix);\n                    localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);\n                }\n                // Flip up vector depending on which side the camera is on\n                let cameraFlipped = false;\n                if (gizmoLayer.utilityLayerScene.activeCamera) {\n                    var camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslation);\n                    if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {\n                        planeNormalTowardsCamera.scaleInPlace(-1);\n                        localPlaneNormalTowardsCamera.scaleInPlace(-1);\n                        cameraFlipped = true;\n                    }\n                }\n                var halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;\n                if (halfCircleSide) { angle = -angle; }\n\n                // Snapping logic\n                var snapped = false;\n                if (this.snapDistance != 0) {\n                    currentSnapDragDistance += angle;\n                    if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\n                        var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\n                        if (currentSnapDragDistance < 0) {\n                            dragSteps *= -1;\n                        }\n                        currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\n                        angle = this.snapDistance * dragSteps;\n                        snapped = true;\n                    } else {\n                        angle = 0;\n                    }\n                }\n\n                dragDistance += cameraFlipped ? -angle : angle;\n                this.updateRotationCircle(this._rotationCircle, rotationCirclePaths, dragDistance, dragPlanePoint);\n\n                // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)\n                var quaternionCoefficient = Math.sin(angle / 2);\n                amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2));\n\n                // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis\n                if (tmpMatrix.determinant() > 0) {\n                    var tmpVector = new Vector3();\n                    amountToRotate.toEulerAnglesToRef(tmpVector);\n                    Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);\n                }\n\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\n                    // Rotate selected mesh quaternion over fixed axis\n                    nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);\n                } else {\n                    // Rotate selected mesh quaternion over rotated axis\n                    amountToRotate.multiplyToRef(nodeQuaternion, nodeQuaternion);\n                }\n\n                // recompose matrix\n                this.attachedNode.getWorldMatrix().copyFrom(Matrix.Compose(nodeScale, nodeQuaternion, nodeTranslation));\n\n                lastDragPosition.copyFrom(event.dragPlanePoint);\n                if (snapped) {\n                    tmpSnapEvent.snapDistance = angle;\n                    this.onSnapObservable.notifyObservers(tmpSnapEvent);\n                }\n\n                this._matrixChanged();\n            }\n        });\n\n        var light = gizmoLayer._getSharedGizmoLight();\n        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\n\n        const cache: GizmoAxisCache = {\n            colliderMeshes: [ collider ],\n            gizmoMeshes: [ rotationMesh ],\n            material: this._coloredMaterial,\n            hoverMaterial: this._hoverMaterial,\n            disableMaterial: this._disableMaterial,\n            active: false\n        };\n        this._parent?.addToAxisCache(this._gizmoMesh, cache);\n\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\n            if (this._customMeshSet) {\n                return;\n            }\n            this._isHovered = !!(cache.colliderMeshes.indexOf(<Mesh>pointerInfo?.pickInfo?.pickedMesh) != -1);\n            if (!this._parent) {\n                var material = this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial;\n                cache.gizmoMeshes.forEach((m: Mesh) => {\n                    m.material = material;\n                    if ((<LinesMesh>m).color) {\n                        (<LinesMesh>m).color = material.diffuseColor;\n                    }\n                });\n            }\n        });\n    }\n\n    /** Create Geometry for Gizmo */\n    private _createGizmoMesh(parentMesh: AbstractMesh, thickness: number, tessellation: number) {\n        let collider = Mesh.CreateTorus(\"ignore\", 0.6, 0.03 * thickness, tessellation, this.gizmoLayer.utilityLayerScene);\n        collider.visibility = 0;\n        let rotationMesh = Mesh.CreateTorus(\"\", 0.6, 0.005 * thickness, tessellation, this.gizmoLayer.utilityLayerScene);\n        rotationMesh.material = this._coloredMaterial;\n\n        // Position arrow pointing in its drag axis\n        rotationMesh.rotation.x = Math.PI / 2;\n        collider.rotation.x = Math.PI / 2;\n\n        parentMesh.addChild(rotationMesh);\n        parentMesh.addChild(collider);\n        return { rotationMesh, collider };\n    }\n\n    protected _attachedNodeChanged(value: Nullable<Node>) {\n        if (this.dragBehavior) {\n            this.dragBehavior.enabled = value ? true : false;\n        }\n    }\n\n    private setupRotationCircle(paths: Vector3[][], parentMesh: AbstractMesh): Mesh {\n        const fillRadians = 0;\n        const step = PlaneRotationGizmo._CircleConstants.pi2 / PlaneRotationGizmo._CircleConstants.tessellation;\n        for (let p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {\n            const path: Vector3[] = [];\n            for (let i = 0; i < PlaneRotationGizmo._CircleConstants.pi2 * PlaneRotationGizmo._CircleConstants.rotationCircleRange + 0.01; i += step) {\n                if (i < fillRadians) {\n                    const x = PlaneRotationGizmo._CircleConstants.radius * Math.sin(i) * Math.cos(p);\n                    const z = PlaneRotationGizmo._CircleConstants.radius * Math.cos(i) * Math.cos(p);\n                    const y = 0;\n                    path.push(new Vector3(x, y, z));\n                } else {\n                    path.push(new Vector3(0, 0, 0));\n                }\n            }\n\n            paths.push(path);\n        }\n\n        const mat = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n        mat.diffuseColor = Color3.Yellow();\n        mat.backFaceCulling = false;\n        const mesh = Mesh.CreateRibbon(\"rotationCircle\", paths, false, false, 0, this.gizmoLayer.utilityLayerScene, true);\n        mesh.material = mat;\n        mesh.material.alpha = .25;\n        mesh.rotation.x = Math.PI / 2;\n        parentMesh.addChild(mesh);\n        return mesh;\n    }\n\n    private updateRotationPath(pathArr: Vector3[][], newFill: number): void {\n        // To update the Ribbon, you have to mutate the pathArray in-place\n        const step = PlaneRotationGizmo._CircleConstants.pi2 / PlaneRotationGizmo._CircleConstants.tessellation;\n        let tessellationCounter = 0;\n        for (let p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {\n            const path = pathArr[tessellationCounter];\n            if (path) {\n                let radianCounter = 0;\n                for (let i = 0; i < PlaneRotationGizmo._CircleConstants.pi2 * PlaneRotationGizmo._CircleConstants.rotationCircleRange + 0.01; i += step) {\n                    if (path[radianCounter]) {\n                        if (i < Math.abs(newFill)) {\n                            const absI = (newFill > 0) ? i : i * -1;\n                            const absP = (newFill > 0) ? p : p * -1;\n                            path[radianCounter].set(\n                                PlaneRotationGizmo._CircleConstants.radius * Math.sin(absI) * Math.cos(absP),\n                                0,\n                                PlaneRotationGizmo._CircleConstants.radius * Math.cos(absI) * Math.cos(absP)\n                            );\n                        } else {\n                            path[radianCounter].set(0, 0, 0);\n                        }\n                    }\n\n                    radianCounter++;\n                }\n            }\n\n            tessellationCounter ++;\n        }\n    }\n\n    private updateRotationCircle(mesh: Mesh, paths: any[], newFill: number, dragPlanePoint: Vector3): void {\n        this.updateRotationPath(paths, newFill);\n        Mesh.CreateRibbon(\"rotationCircle\", paths, false, false, 0, this.gizmoLayer.utilityLayerScene, undefined, undefined, mesh.geometry ? mesh : undefined);\n    }\n\n    /**\n         * If the gizmo is enabled\n         */\n    public set isEnabled(value: boolean) {\n        this._isEnabled = value;\n        if (!value) {\n            this.attachedMesh = null;\n        }\n        else {\n            if (this._parent) {\n                this.attachedMesh = this._parent.attachedMesh;\n            }\n        }\n    }\n    public get isEnabled(): boolean {\n        return this._isEnabled;\n    }\n    /**\n     * Disposes of the gizmo\n     */\n    public dispose() {\n        this.onSnapObservable.clear();\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n        this.dragBehavior.detach();\n        if (this._gizmoMesh) {\n            this._gizmoMesh.dispose();\n        }\n        if (this._rotationCircle) {\n            this._rotationCircle.dispose();\n        }\n        [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {\n            if (matl) {\n                matl.dispose();\n            }\n        });\n        super.dispose();\n    }\n}"]}