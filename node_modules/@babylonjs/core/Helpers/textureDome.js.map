{"version":3,"file":"textureDome.js","sourceRoot":"","sources":["../../../sourceES6/core/Helpers/textureDome.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../scene\";\nimport { TransformNode } from \"../Meshes/transformNode\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial\";\nimport \"../Meshes/Builders/sphereBuilder\";\nimport { Nullable } from \"../types\";\nimport { Observer, Observable } from \"../Misc/observable\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Axis } from \"../Maths/math\";\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\n\ndeclare type Camera = import(\"../Cameras/camera\").Camera;\n\n/**\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\n */\nexport abstract class TextureDome<T extends Texture> extends TransformNode {\n    /**\n     * Define the source as a Monoscopic panoramic 360/180.\n     */\n    public static readonly MODE_MONOSCOPIC = 0;\n    /**\n     * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\n     */\n    public static readonly MODE_TOPBOTTOM = 1;\n    /**\n     * Define the source as a Stereoscopic Side by Side panoramic 360/180.\n     */\n    public static readonly MODE_SIDEBYSIDE = 2;\n\n    private _halfDome: boolean = false;\n    private _crossEye: boolean = false;\n\n    protected _useDirectMapping = false;\n\n    /**\n     * The texture being displayed on the sphere\n     */\n    protected _texture: T;\n\n    /**\n     * Gets the texture being displayed on the sphere\n     */\n    public get texture(): T {\n        return this._texture;\n    }\n\n    /**\n     * Sets the texture being displayed on the sphere\n     */\n    public set texture(newTexture: T) {\n        if (this._texture === newTexture) {\n            return;\n        }\n        this._texture = newTexture;\n        if (this._useDirectMapping) {\n            this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n            this._material.diffuseTexture = this._texture;\n        } else {\n            this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n            this._material.reflectionTexture = this._texture;\n        }\n        this._changeTextureMode(this._textureMode);\n    }\n\n    /**\n     * The skybox material\n     */\n    protected _material: BackgroundMaterial;\n\n    /**\n     * The surface used for the dome\n     */\n    protected _mesh: Mesh;\n    /**\n     * Gets the mesh used for the dome.\n     */\n    public get mesh(): Mesh {\n        return this._mesh;\n    }\n\n    /**\n     * A mesh that will be used to mask the back of the dome in case it is a 180 degree movie.\n     */\n    private _halfDomeMask: Mesh;\n\n    /**\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\n     * Also see the options.resolution property.\n     */\n    public get fovMultiplier(): number {\n        return this._material.fovMultiplier;\n    }\n    public set fovMultiplier(value: number) {\n        this._material.fovMultiplier = value;\n    }\n\n    protected _textureMode = TextureDome.MODE_MONOSCOPIC;\n    /**\n     * Gets or set the current texture mode for the texture. It can be:\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n     */\n    public get textureMode(): number {\n        return this._textureMode;\n    }\n    /**\n     * Sets the current texture mode for the texture. It can be:\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n     */\n    public set textureMode(value: number) {\n        if (this._textureMode === value) {\n            return;\n        }\n\n        this._changeTextureMode(value);\n    }\n\n    /**\n     * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\n     */\n    public get halfDome(): boolean {\n        return this._halfDome;\n    }\n\n    /**\n     * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\n     */\n    public set halfDome(enabled: boolean) {\n        this._halfDome = enabled;\n        this._halfDomeMask.setEnabled(enabled);\n    }\n\n    /**\n     * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\n     */\n    public set crossEye(enabled: boolean) {\n        this._crossEye = enabled;\n    }\n\n    /**\n     * Is it a cross-eye texture?\n     */\n    public get crossEye(): boolean {\n        return this._crossEye;\n    }\n\n    /**\n     * The background material of this dome.\n     */\n    public get material(): BackgroundMaterial {\n        return this._material;\n    }\n\n    /**\n     * Oberserver used in Stereoscopic VR Mode.\n     */\n    private _onBeforeCameraRenderObserver: Nullable<Observer<Camera>> = null;\n    /**\n     * Observable raised when an error occured while loading the 360 image\n     */\n    public onLoadErrorObservable = new Observable<string>();\n\n    /**\n     * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\n     * @param name Element's name, child elements will append suffixes for their own names.\n     * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\n     * @param options An object containing optional or exposed sub element properties\n     */\n    constructor(\n        name: string,\n        textureUrlOrElement: string | string[] | HTMLVideoElement,\n        options: {\n            resolution?: number;\n            clickToPlay?: boolean;\n            autoPlay?: boolean;\n            loop?: boolean;\n            size?: number;\n            poster?: string;\n            faceForward?: boolean;\n            useDirectMapping?: boolean;\n            halfDomeMode?: boolean;\n            crossEyeMode?: boolean;\n            generateMipMaps?: boolean;\n        },\n        scene: Scene,\n        protected onError: Nullable<(message?: string, exception?: any) => void> = null\n    ) {\n        super(name, scene);\n\n        scene = this.getScene();\n\n        // set defaults and manage values\n        name = name || \"textureDome\";\n        options.resolution = Math.abs(options.resolution as any) | 0 || 32;\n        options.clickToPlay = Boolean(options.clickToPlay);\n        options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\n        options.loop = options.loop === undefined ? true : Boolean(options.loop);\n        options.size = Math.abs(options.size as any) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\n\n        if (options.useDirectMapping === undefined) {\n            this._useDirectMapping = true;\n        } else {\n            this._useDirectMapping = options.useDirectMapping;\n        }\n\n        if (options.faceForward === undefined) {\n            options.faceForward = true;\n        }\n\n        this._setReady(false);\n        this._mesh = Mesh.CreateSphere(name + \"_mesh\", options.resolution, options.size, scene, false, Mesh.BACKSIDE);\n        // configure material\n        let material = (this._material = new BackgroundMaterial(name + \"_material\", scene));\n        material.useEquirectangularFOV = true;\n        material.fovMultiplier = 1.0;\n        material.opacityFresnel = false;\n\n        const texture = this._initTexture(textureUrlOrElement, scene, options);\n        this.texture = texture;\n\n        // configure mesh\n        this._mesh.material = material;\n        this._mesh.parent = this;\n\n        // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\n        this._halfDomeMask = SphereBuilder.CreateSphere(\"\", { slice: 0.5, diameter: options.size * 0.98, segments: options.resolution * 2, sideOrientation: Mesh.BACKSIDE }, scene);\n        this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);\n        // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\n        this._halfDomeMask.parent = this._mesh;\n        this._halfDome = !!options.halfDomeMode;\n        // enable or disable according to the settings\n        this._halfDomeMask.setEnabled(this._halfDome);\n        this._crossEye = !!options.crossEyeMode;\n\n        // create\n        this._texture.anisotropicFilteringLevel = 1;\n        this._texture.onLoadObservable.addOnce(() => {\n            this._setReady(true);\n        });\n\n        // Initial rotation\n        if (options.faceForward && scene.activeCamera) {\n            let camera = scene.activeCamera;\n\n            let forward = Vector3.Forward();\n            var direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\n            direction.normalize();\n\n            this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\n        }\n\n        this._changeTextureMode(this._textureMode);\n    }\n\n    protected abstract _initTexture(urlsOrElement: string | string[] | HTMLElement, scene: Scene, options: any): T;\n\n    protected _changeTextureMode(value: number): void {\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n        this._textureMode = value;\n\n        // Default Setup and Reset.\n        this._texture.uScale = 1;\n        this._texture.vScale = 1;\n        this._texture.uOffset = 0;\n        this._texture.vOffset = 0;\n        this._texture.vAng = 0;\n\n        switch (value) {\n            case TextureDome.MODE_MONOSCOPIC:\n                if (this._halfDome) {\n                    this._texture.uScale = 2;\n                    this._texture.uOffset = -1;\n                }\n                break;\n            case TextureDome.MODE_SIDEBYSIDE:\n                // in half-dome mode the uScale should be double of 360 texture\n                // Use 0.99999 to boost perf by not switching program\n                this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\n                const rightOffset = this._halfDome ? 0.0 : 0.5;\n                const leftOffset = this._halfDome ? -0.5 : 0.0;\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\n                    let isRightCamera = camera.isRightCamera;\n                    if (this._crossEye) {\n                        isRightCamera = !isRightCamera;\n                    }\n                    if (isRightCamera) {\n                        this._texture.uOffset = rightOffset;\n                    } else {\n                        this._texture.uOffset = leftOffset;\n                    }\n                });\n                break;\n            case TextureDome.MODE_TOPBOTTOM:\n                // in half-dome mode the vScale should be double of 360 texture\n                // Use 0.99999 to boost perf by not switching program\n                this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\n                    let isRightCamera = camera.isRightCamera;\n                    // allow \"cross-eye\" if left and right were switched in this mode\n                    if (this._crossEye) {\n                        isRightCamera = !isRightCamera;\n                    }\n                    this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\n                });\n                break;\n        }\n    }\n\n    /**\n     * Releases resources associated with this node.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\n        this._texture.dispose();\n        this._mesh.dispose();\n        this._material.dispose();\n\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n        this.onLoadErrorObservable.clear();\n\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\n    }\n}\n"]}