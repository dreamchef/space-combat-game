{"version":3,"file":"effectLayer.js","sourceRoot":"","sources":["../../../sourceES6/core/Layers/effectLayer.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { ISize } from \"../Maths/math.size\";\r\nimport { Color4 } from '../Maths/math.color';\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\n\r\n\r\nimport \"../Shaders/glowMapGeneration.fragment\";\r\nimport \"../Shaders/glowMapGeneration.vertex\";\r\nimport { _DevTools } from '../Misc/devTools';\r\nimport { DataBuffer } from '../Meshes/dataBuffer';\r\nimport { EffectFallbacks } from '../Materials/effectFallbacks';\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the objects (the smaller the faster).\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure effect stability across devices.\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation.\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer.\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in.\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or higlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\r\nexport abstract class EffectLayer {\r\n\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _cachedDefines: string;\r\n    private _effectLayerMapGenerationEffect: Effect;\r\n    private _effectLayerOptions: IEffectLayerOptions;\r\n    private _mergeEffect: Effect;\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    protected _maxSize: number = 0;\r\n    protected _mainTextureDesiredSize: ISize = { width: 0, height: 0 };\r\n    protected _mainTexture: RenderTargetTexture;\r\n    protected _shouldRender = true;\r\n    protected _postProcesses: PostProcess[] = [];\r\n    protected _textures: BaseTexture[] = [];\r\n    protected _emissiveTextureAndColor: { texture: Nullable<BaseTexture>, color: Color4 } = { texture: null, color: new Color4() };\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    @serializeAsColor4()\r\n    public neutralColor: Color4 = new Color4();\r\n\r\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\r\n    @serialize()\r\n    public isEnabled: boolean = true;\r\n\r\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\r\n    @serializeAsCameraReference()\r\n    public get camera(): Nullable<Camera> {\r\n        return this._effectLayerOptions.camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    @serialize()\r\n    public get renderingGroupId(): number {\r\n        return this._effectLayerOptions.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._effectLayerOptions.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    @serialize()\r\n    public disableBoundingBoxesFromEffectLayer = false;\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderMainTextureObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the efffect layer changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<EffectLayer>();\r\n\r\n    /** @hidden */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _DevTools.WarnImport(\"EffectLayerSceneComponent\");\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer and references it in the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     */\r\n    constructor(\r\n        /** The Friendly of the effect in the scene */\r\n        name: string,\r\n        scene: Scene) {\r\n        this.name = name;\r\n\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        EffectLayer._SceneComponentInitialization(this._scene);\r\n\r\n        this._engine = this._scene.getEngine();\r\n        this._maxSize = this._engine.getCaps().maxTextureSize;\r\n        this._scene.effectLayers.push(this);\r\n\r\n        // Generate Buffers\r\n        this._generateIndexBuffer();\r\n        this._generateVertexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @return The effect name\r\n     */\r\n    public abstract getEffectName(): string;\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @return true if ready otherwise, false\r\n     */\r\n    public abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;\r\n\r\n    /**\r\n     * Returns whether or nood the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public abstract needStencil(): boolean;\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect containing the shader used to merge the effect on the  main canvas\r\n     */\r\n    protected abstract _createMergeEffect(): Effect;\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the effect layer.\r\n     */\r\n    protected abstract _createTextureAndPostProcesses(): void;\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     */\r\n    protected abstract _internalRender(effect: Effect): void;\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     */\r\n    public abstract _disposeMesh(mesh: Mesh): void;\r\n\r\n    /**\r\n     * Serializes this layer (Glow or Highlight for example)\r\n     * @returns a serialized layer object\r\n     */\r\n    public abstract serialize?(): any;\r\n\r\n    /**\r\n     * Initializes the effect layer with the required options.\r\n     * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n     */\r\n    protected _init(options: Partial<IEffectLayerOptions>): void {\r\n        // Adapt options\r\n        this._effectLayerOptions = {\r\n            mainTextureRatio: 0.5,\r\n            alphaBlendingMode: 2,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            ...options,\r\n        };\r\n\r\n        this._setMainTextureSize();\r\n        this._createMainTexture();\r\n        this._createTextureAndPostProcesses();\r\n        this._mergeEffect = this._createMergeEffect();\r\n    }\r\n\r\n    /**\r\n     * Generates the index buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateIndexBuffer(): void {\r\n        // Indices\r\n        var indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Generates the vertex buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateVertexBuffer(): void {\r\n        // VBO\r\n        var vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        var vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Sets the main texture desired size which is the closest power of two\r\n     * of the engine canvas size.\r\n     */\r\n    private _setMainTextureSize(): void {\r\n        if (this._effectLayerOptions.mainTextureFixedSize) {\r\n            this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\r\n            this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\r\n        }\r\n        else {\r\n            this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\r\n            this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\r\n\r\n            this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;\r\n            this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;\r\n        }\r\n\r\n        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\r\n        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\r\n    }\r\n\r\n    /**\r\n     * Creates the main texture for the effect layer.\r\n     */\r\n    protected _createMainTexture(): void {\r\n        this._mainTexture = new RenderTargetTexture(\"HighlightLayerMainRTT\",\r\n            {\r\n                width: this._mainTextureDesiredSize.width,\r\n                height: this._mainTextureDesiredSize.height\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            0);\r\n        this._mainTexture.activeCamera = this._effectLayerOptions.camera;\r\n        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.anisotropicFilteringLevel = 1;\r\n        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._mainTexture.renderParticles = false;\r\n        this._mainTexture.renderList = null;\r\n        this._mainTexture.ignoreCameraViewport = true;\r\n\r\n        // Custom render function\r\n        this._mainTexture.customRenderFunction = (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>): void => {\r\n            this.onBeforeRenderMainTextureObservable.notifyObservers(this);\r\n\r\n            var index: number;\r\n\r\n            let engine = this._scene.getEngine();\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    this._renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                this._renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                this._renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            const previousAlphaMode = engine.getAlphaMode();\r\n\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                this._renderSubMesh(transparentSubMeshes.data[index], true);\r\n            }\r\n\r\n            engine.setAlphaMode(previousAlphaMode);\r\n        };\r\n\r\n        this._mainTexture.onClearObservable.add((engine: Engine) => {\r\n            engine.clear(this.neutralColor, true, true, true);\r\n        });\r\n\r\n        const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\r\n\r\n        this._mainTexture.onBeforeBindObservable.add(() => {\r\n            this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\r\n        });\r\n\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        // Nothing to add by default.\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @return true if ready otherwise, false\r\n     */\r\n    protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        let material = subMesh.getMaterial();\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        if (!material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {\r\n            return false;\r\n        }\r\n\r\n        var defines: string[] = [];\r\n\r\n        var attribs = [VertexBuffer.PositionKind];\r\n\r\n        var mesh = subMesh.getMesh();\r\n        var uv1 = false;\r\n        var uv2 = false;\r\n\r\n        // Diffuse\r\n        if (material) {\r\n            const needAlphaTest = material.needAlphaTesting();\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha &&\r\n                ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                defines.push(\"#define DIFFUSE\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) &&\r\n                    diffuseTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define DIFFUSEUV2\");\r\n                    uv2 = true;\r\n                }\r\n                else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define DIFFUSEUV1\");\r\n                    uv1 = true;\r\n                }\r\n\r\n                if (needAlphaTest) {\r\n                    defines.push(\"#define ALPHATEST\");\r\n                    defines.push(\"#define ALPHATESTVALUE 0.4\");\r\n                }\r\n            }\r\n\r\n            var opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                defines.push(\"#define OPACITY\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) &&\r\n                    opacityTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define OPACITYUV2\");\r\n                    uv2 = true;\r\n                }\r\n                else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define OPACITYUV1\");\r\n                    uv1 = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emissive\r\n        if (emissiveTexture) {\r\n            defines.push(\"#define EMISSIVE\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) &&\r\n                emissiveTexture.coordinatesIndex === 1) {\r\n                defines.push(\"#define EMISSIVEUV2\");\r\n                uv2 = true;\r\n            }\r\n            else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                defines.push(\"#define EMISSIVEUV1\");\r\n                uv1 = true;\r\n            }\r\n        }\r\n\r\n        // Vertex\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (uv1) {\r\n            attribs.push(VertexBuffer.UVKind);\r\n            defines.push(\"#define UV1\");\r\n        }\r\n        if (uv2) {\r\n            attribs.push(VertexBuffer.UV2Kind);\r\n            defines.push(\"#define UV2\");\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n\r\n            let skeleton = mesh.skeleton;\r\n            if (skeleton && skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton ? (skeleton.bones.length + 1) : 0));\r\n            }\r\n\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        var manager = (<Mesh>mesh).morphTargetManager;\r\n        let morphInfluencers = 0;\r\n        if (manager) {\r\n            if (manager.numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                morphInfluencers = manager.numInfluencers;\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        this._addCustomEffectDefines(defines);\r\n\r\n        // Get correct effect\r\n        var join = defines.join(\"\\n\");\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n            this._effectLayerMapGenerationEffect = this._scene.getEngine().createEffect(\"glowMapGeneration\",\r\n                attribs,\r\n                [\"world\", \"mBones\", \"viewProjection\",\r\n                    \"glowColor\", \"morphTargetInfluences\", \"boneTextureWidth\",\r\n                    \"diffuseMatrix\", \"emissiveMatrix\", \"opacityMatrix\", \"opacityIntensity\"],\r\n                [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\"], join,\r\n                fallbacks, undefined, undefined, { maxSimultaneousMorphTargets: morphInfluencers });\r\n        }\r\n\r\n        return this._effectLayerMapGenerationEffect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     */\r\n    public render(): void {\r\n        var currentEffect = this._mergeEffect;\r\n\r\n        // Check\r\n        if (!currentEffect.isReady()) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < this._postProcesses.length; i++) {\r\n            if (!this._postProcesses[i].isReady()) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        var engine = this._scene.getEngine();\r\n\r\n        this.onBeforeComposeObservable.notifyObservers(this);\r\n\r\n        // Render\r\n        engine.enableEffect(currentEffect);\r\n        engine.setState(false);\r\n\r\n        // VBOs\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\r\n\r\n        // Cache\r\n        var previousAlphaMode = engine.getAlphaMode();\r\n\r\n        // Go Blend.\r\n        engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);\r\n\r\n        // Blends the map on the main canvas.\r\n        this._internalRender(currentEffect);\r\n\r\n        // Restore Alpha\r\n        engine.setAlphaMode(previousAlphaMode);\r\n\r\n        this.onAfterComposeObservable.notifyObservers(this);\r\n\r\n        // Handle size changes.\r\n        var size = this._mainTexture.getSize();\r\n        this._setMainTextureSize();\r\n        if (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) {\r\n            // Recreate RTT and post processes on size change.\r\n            this.onSizeChangedObservable.notifyObservers(this);\r\n            this._disposeTextureAndPostProcesses();\r\n            this._createMainTexture();\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this.isEnabled && this._shouldRender;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderMesh(mesh: AbstractMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return !material.needAlphaBlendingForMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderEmissiveTextureForMesh(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh passed in parameter to the generation map.\r\n     */\r\n    protected _renderSubMesh(subMesh: SubMesh, enableAlphaMode: boolean = false): void {\r\n        if (!this.shouldRender()) {\r\n            return;\r\n        }\r\n\r\n        var material = subMesh.getMaterial();\r\n        var ownerMesh = subMesh.getMesh();\r\n        var replacementMesh = subMesh.getReplacementMesh();\r\n        var renderingMesh = subMesh.getRenderingMesh();\r\n        var effectiveMesh = subMesh.getEffectiveMesh();\r\n        var scene = this._scene;\r\n        var engine = scene.getEngine();\r\n\r\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n        if (!material) {\r\n            return;\r\n        }\r\n\r\n        // Do not block in blend mode.\r\n        if (!this._canRenderMesh(renderingMesh, material)) {\r\n            return;\r\n        }\r\n\r\n        // Culling\r\n        let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\r\n        const mainDeterminant = renderingMesh._getWorldMatrixDeterminant();\r\n        if (mainDeterminant < 0) {\r\n            sideOrientation = (sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation);\r\n        }\r\n\r\n        const reverse = sideOrientation === Material.ClockWiseSideOrientation;\r\n        engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse);\r\n\r\n        // Managing instances\r\n        var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\r\n        if (batch.mustReturn) {\r\n            return;\r\n        }\r\n\r\n        // Early Exit per mesh\r\n        if (!this._shouldRenderMesh(renderingMesh)) {\r\n            return;\r\n        }\r\n\r\n        var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\r\n\r\n        if (this._useMeshMaterial(renderingMesh)) {\r\n            renderingMesh.render(subMesh, hardwareInstancedRendering, replacementMesh || undefined);\r\n        }\r\n        else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n            engine.enableEffect(this._effectLayerMapGenerationEffect);\r\n            renderingMesh._bind(subMesh, this._effectLayerMapGenerationEffect, Material.TriangleFillMode);\r\n\r\n            this._effectLayerMapGenerationEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n            this._effectLayerMapGenerationEffect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n\r\n            this._effectLayerMapGenerationEffect.setFloat4(\"glowColor\",\r\n                this._emissiveTextureAndColor.color.r,\r\n                this._emissiveTextureAndColor.color.g,\r\n                this._emissiveTextureAndColor.color.b,\r\n                this._emissiveTextureAndColor.color.a);\r\n\r\n            const needAlphaTest = material.needAlphaTesting();\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha &&\r\n                ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                this._effectLayerMapGenerationEffect.setTexture(\"diffuseSampler\", diffuseTexture);\r\n                const textureMatrix = diffuseTexture.getTextureMatrix();\r\n\r\n                if (textureMatrix) {\r\n                    this._effectLayerMapGenerationEffect.setMatrix(\"diffuseMatrix\", textureMatrix);\r\n                }\r\n            }\r\n\r\n            const opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                this._effectLayerMapGenerationEffect.setTexture(\"opacitySampler\", opacityTexture);\r\n                this._effectLayerMapGenerationEffect.setFloat(\"opacityIntensity\", opacityTexture.level);\r\n                const textureMatrix = opacityTexture.getTextureMatrix();\r\n                if (textureMatrix) {\r\n                    this._effectLayerMapGenerationEffect.setMatrix(\"opacityMatrix\", textureMatrix);\r\n                }\r\n            }\r\n\r\n            // Glow emissive only\r\n            if (this._emissiveTextureAndColor.texture) {\r\n                this._effectLayerMapGenerationEffect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\r\n                this._effectLayerMapGenerationEffect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\r\n            }\r\n\r\n            // Bones\r\n            if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                const skeleton = renderingMesh.skeleton;\r\n\r\n                if (skeleton.isUsingTextureForMatrices) {\r\n                    const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                    if (!boneTexture) {\r\n                        return;\r\n                    }\r\n\r\n                    this._effectLayerMapGenerationEffect.setTexture(\"boneSampler\", boneTexture);\r\n                    this._effectLayerMapGenerationEffect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                } else {\r\n                    this._effectLayerMapGenerationEffect.setMatrices(\"mBones\", skeleton.getTransformMatrices((renderingMesh)));\r\n                }\r\n            }\r\n\r\n            // Morph targets\r\n            MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effectLayerMapGenerationEffect);\r\n\r\n            // Alpha mode\r\n            if (enableAlphaMode) {\r\n                engine.setAlphaMode(material.alphaMode);\r\n            }\r\n\r\n            // Draw\r\n            renderingMesh._processRendering(effectiveMesh, subMesh, this._effectLayerMapGenerationEffect, material.fillMode, batch, hardwareInstancedRendering,\r\n                (isInstance, world) => this._effectLayerMapGenerationEffect.setMatrix(\"world\", world));\r\n        } else {\r\n            // Need to reset refresh rate of the main map\r\n            this._mainTexture.resetRefreshCounter();\r\n        }\r\n\r\n        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the required buffers.\r\n     * @hidden Internal use only.\r\n     */\r\n    public _rebuild(): void {\r\n        let vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._generateIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Dispose only the render target textures and post process.\r\n     */\r\n    private _disposeTextureAndPostProcesses(): void {\r\n        this._mainTexture.dispose();\r\n\r\n        for (var i = 0; i < this._postProcesses.length; i++) {\r\n            if (this._postProcesses[i]) {\r\n                this._postProcesses[i].dispose();\r\n            }\r\n        }\r\n        this._postProcesses = [];\r\n\r\n        for (var i = 0; i < this._textures.length; i++) {\r\n            if (this._textures[i]) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        // Clean textures and post processes\r\n        this._disposeTextureAndPostProcesses();\r\n\r\n        // Remove from scene\r\n        var index = this._scene.effectLayers.indexOf(this, 0);\r\n        if (index > -1) {\r\n            this._scene.effectLayers.splice(index, 1);\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderMainTextureObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n      * Gets the class name of the effect layer\r\n      * @returns the string with the class name of the effect layer\r\n      */\r\n    public getClassName(): string {\r\n        return \"EffectLayer\";\r\n    }\r\n\r\n    /**\r\n     * Creates an effect layer from parsed effect layer data\r\n     * @param parsedEffectLayer defines effect layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the effect layer information\r\n     * @returns a parsed effect Layer\r\n     */\r\n    public static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer {\r\n        var effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\r\n\r\n        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\r\n    }\r\n}\r\n"]}