{"version":3,"file":"directionalLight.js","sourceRoot":"","sources":["../../../sourceES6/core/Lights/directionalLight.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize } from \"../Misc/decorators\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport { Effect } from \"../Materials/effect\";\r\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\r\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A directional light is defined by a direction (what a surprise!).\r\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\r\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\r\n * Documentation: https://doc.babylonjs.com/babylon101/lights\r\n */\r\nexport class DirectionalLight extends ShadowLight {\r\n\r\n    private _shadowFrustumSize = 0;\r\n    /**\r\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\r\n     */\r\n    @serialize()\r\n    public get shadowFrustumSize(): number {\r\n        return this._shadowFrustumSize;\r\n    }\r\n    /**\r\n     * Specifies a fix frustum size for the shadow generation.\r\n     */\r\n    public set shadowFrustumSize(value: number) {\r\n        this._shadowFrustumSize = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    private _shadowOrthoScale = 0.1;\r\n    /**\r\n     * Gets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    @serialize()\r\n    public get shadowOrthoScale(): number {\r\n        return this._shadowOrthoScale;\r\n    }\r\n    /**\r\n     * Sets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    public set shadowOrthoScale(value: number) {\r\n        this._shadowOrthoScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Automatically compute the projection matrix to best fit (including all the casters)\r\n     * on each frame.\r\n     */\r\n    @serialize()\r\n    public autoUpdateExtends = true;\r\n\r\n    /**\r\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\r\n     * on each frame. autoUpdateExtends must be set to true for this to work\r\n     */\r\n    @serialize()\r\n    public autoCalcShadowZBounds = false;\r\n\r\n    // Cache\r\n    private _orthoLeft = Number.MAX_VALUE;\r\n    private _orthoRight = Number.MIN_VALUE;\r\n    private _orthoTop = Number.MIN_VALUE;\r\n    private _orthoBottom = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\r\n     * The directional light is emitted from everywhere in the given direction.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene: Scene) {\r\n        super(name, scene);\r\n        this.position = direction.scale(-1.0);\r\n        this.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"DirectionalLight\".\r\n     * @return The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DirectionalLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 1.\r\n     * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     */\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        if (this.shadowFrustumSize > 0) {\r\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\r\n        }\r\n        else {\r\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     */\r\n    protected _setDefaultFixedFrustumShadowProjectionMatrix(matrix: Matrix): void {\r\n        var activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize,\r\n            this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     */\r\n    protected _setDefaultAutoExtendShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        var activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        // Check extends\r\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\r\n            var tempVector3 = Vector3.Zero();\r\n\r\n            this._orthoLeft = Number.MAX_VALUE;\r\n            this._orthoRight = Number.MIN_VALUE;\r\n            this._orthoTop = Number.MIN_VALUE;\r\n            this._orthoBottom = Number.MAX_VALUE;\r\n\r\n            var shadowMinZ = Number.MAX_VALUE;\r\n            var shadowMaxZ = Number.MIN_VALUE;\r\n\r\n            for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\r\n                var mesh = renderList[meshIndex];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                var boundingInfo = mesh.getBoundingInfo();\r\n                var boundingBox = boundingInfo.boundingBox;\r\n\r\n                for (var index = 0; index < boundingBox.vectorsWorld.length; index++) {\r\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\r\n\r\n                    if (tempVector3.x < this._orthoLeft) {\r\n                        this._orthoLeft = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y < this._orthoBottom) {\r\n                        this._orthoBottom = tempVector3.y;\r\n                    }\r\n\r\n                    if (tempVector3.x > this._orthoRight) {\r\n                        this._orthoRight = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y > this._orthoTop) {\r\n                        this._orthoTop = tempVector3.y;\r\n                    }\r\n                    if (this.autoCalcShadowZBounds) {\r\n                        if (tempVector3.z < shadowMinZ) {\r\n                            shadowMinZ = tempVector3.z;\r\n                        }\r\n                        if (tempVector3.z > shadowMaxZ) {\r\n                            shadowMaxZ = tempVector3.z;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.autoCalcShadowZBounds) {\r\n                this._shadowMinZ = shadowMinZ;\r\n                this._shadowMaxZ = shadowMaxZ;\r\n            }\r\n        }\r\n\r\n        var xOffset = this._orthoRight - this._orthoLeft;\r\n        var yOffset = this._orthoTop - this._orthoBottom;\r\n\r\n        Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale,\r\n            this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale,\r\n            this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix);\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The directional light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): DirectionalLight {\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\r\n            return this;\r\n        }\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light {\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\r\n            return this;\r\n        }\r\n\r\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"DIRLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"]}