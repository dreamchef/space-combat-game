{"version":3,"file":"reflectionTextureBaseBlock.js","sourceRoot":"","sources":["../../../../../../sourceES6/core/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlock } from '../../nodeMaterialBlock';\r\nimport { NodeMaterialBuildState } from '../../nodeMaterialBuildState';\r\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\r\nimport { NodeMaterialConnectionPoint } from '../../nodeMaterialBlockConnectionPoint';\r\nimport { BaseTexture } from '../../../Textures/baseTexture';\r\nimport { AbstractMesh } from '../../../../Meshes/abstractMesh';\r\nimport { NodeMaterial, NodeMaterialDefines } from '../../nodeMaterial';\r\nimport { Effect } from '../../../effect';\r\nimport { Mesh } from '../../../../Meshes/mesh';\r\nimport { Nullable } from '../../../../types';\r\nimport { _TypeStore } from '../../../../Misc/typeStore';\r\nimport { Scene } from '../../../../scene';\r\nimport { InputBlock } from '../Input/inputBlock';\r\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\r\n\r\n\r\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction\";\r\nimport { CubeTexture } from '../../../Textures/cubeTexture';\r\nimport { Texture } from '../../../Textures/texture';\r\n\r\n/**\r\n * Base block used to read a reflection texture from a sampler\r\n */\r\nexport abstract class ReflectionTextureBaseBlock extends NodeMaterialBlock {\r\n    /** @hidden */\r\n    public _define3DName: string;\r\n    /** @hidden */\r\n    public _defineCubicName: string;\r\n    /** @hidden */\r\n    public _defineExplicitName: string;\r\n    /** @hidden */\r\n    public _defineProjectionName: string;\r\n    /** @hidden */\r\n    public _defineLocalCubicName: string;\r\n    /** @hidden */\r\n    public _defineSphericalName: string;\r\n    /** @hidden */\r\n    public _definePlanarName: string;\r\n    /** @hidden */\r\n    public _defineEquirectangularName: string;\r\n    /** @hidden */\r\n    public _defineMirroredEquirectangularFixedName: string;\r\n    /** @hidden */\r\n    public _defineEquirectangularFixedName: string;\r\n    /** @hidden */\r\n    public _defineSkyboxName: string;\r\n    /** @hidden */\r\n    public _defineOppositeZ: string;\r\n    /** @hidden */\r\n    public _cubeSamplerName: string;\r\n    /** @hidden */\r\n    public _2DSamplerName: string;\r\n    protected _positionUVWName: string;\r\n    protected _directionWName: string;\r\n    protected _reflectionVectorName: string;\r\n    /** @hidden */\r\n    public _reflectionCoordsName: string;\r\n    /** @hidden */\r\n    public _reflectionMatrixName: string;\r\n    protected _reflectionColorName: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Create a new ReflectionTextureBaseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ReflectionTextureBaseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get position(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get worldPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public abstract get worldNormal(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public abstract get world(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n    * Gets the camera (or eye) position component\r\n    */\r\n    public abstract get cameraPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public abstract get view(): NodeMaterialConnectionPoint;\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        return this.texture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\");\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n\r\n        if (!this.world.isConnected) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World);\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const texture = this._getTexture();\r\n\r\n        if (!texture || !texture.getTextureMatrix) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, texture.isCube, true);\r\n        defines.setValue(this._defineLocalCubicName, (<any>texture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);\r\n        defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);\r\n        defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);\r\n        defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === 6, true);\r\n        defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);\r\n        defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);\r\n        defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);\r\n        defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);\r\n        defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);\r\n        defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        const texture = this._getTexture();\r\n\r\n        if (!mesh || !texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\r\n\r\n        if (texture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, texture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the code to inject in the vertex shader\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public handleVertexSide(state: NodeMaterialBuildState): string {\r\n        this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\r\n        this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\r\n        this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\r\n        this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\r\n        this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\r\n        this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\r\n        this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n        this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\r\n        this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n        this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n        this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\r\n\r\n        this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\r\n\r\n        state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\r\n\r\n        let code = \"\";\r\n\r\n        let worldPosVaryingName = \"v_\" + this.worldPosition.associatedVariableName;\r\n        if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\r\n            code += `${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\r\\n`;\r\n        }\r\n\r\n        this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\r\n        this._directionWName = state._getFreeVariableName(\"directionW\");\r\n\r\n        if (state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\r\n            code += `#ifdef ${this._defineSkyboxName}\\r\\n`;\r\n            code += `${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\r\\n`;\r\n            code += `#endif\\r\\n`;\r\n        }\r\n\r\n        if (state._emitVaryingFromString(this._directionWName, \"vec3\", `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`)) {\r\n            code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\r\\n`;\r\n            code += `${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${this.position.associatedVariableName}.xyz, 0.0)));\\r\\n`;\r\n            code += `#endif\\r\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Handles the inits for the fragment code path\r\n     * @param state node material build state\r\n     */\r\n    public handleFragmentSideInits(state: NodeMaterialBuildState) {\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\r\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#else\\r\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#endif\\r\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        let comments = `//${this.name}`;\r\n        state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\r\n        state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\r\n            replaceStrings: [\r\n                { search: /vec3 computeReflectionCoords/g, replace: \"void DUMMYFUNC\" }\r\n            ]\r\n        });\r\n\r\n        this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\r\n        this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\r\n        this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection coords code for the fragment code path\r\n     * @param worldNormalVarName name of the world normal variable\r\n     * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\r\n     * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionCoords(worldNormalVarName: string, worldPos?: string, onlyReflectionVector = false): string {\r\n        if (!worldPos) {\r\n            worldPos = `v_${this.worldPosition.associatedVariableName}`;\r\n        }\r\n        let reflectionMatrix = this._reflectionMatrixName;\r\n        let direction = `normalize(${this._directionWName})`;\r\n        let positionUVW = `${this._positionUVWName}`;\r\n        let vEyePosition = `${this.cameraPosition.associatedVariableName}`;\r\n        let view = `${this.view.associatedVariableName}`;\r\n\r\n        worldNormalVarName += \".xyz\";\r\n\r\n        let code = `\r\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularName}\r\n                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSphericalName}\r\n                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._definePlanarName}\r\n                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineCubicName}\r\n                #ifdef ${this._defineLocalCubicName}\r\n                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, vReflectionSize, vReflectionPosition);\r\n                #else\r\n                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n                #endif\r\n            #endif\r\n\r\n            #ifdef ${this._defineProjectionName}\r\n                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSkyboxName}\r\n                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineExplicitName}\r\n                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);\r\n            #endif\r\n\r\n            #ifdef ${this._defineOppositeZ}\r\n                ${this._reflectionVectorName}.z *= -1.0;\r\n            #endif\\r\\n`;\r\n\r\n        if (!onlyReflectionVector) {\r\n            code += `\r\n                #ifdef ${this._define3DName}\r\n                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};\r\n                #else\r\n                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;\r\n                    #ifdef ${this._defineProjectionName}\r\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\r\n                    #endif\r\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\r\n                #endif\\r\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection color code for the fragment code path\r\n     * @param lodVarName name of the lod variable\r\n     * @param swizzleLookupTexture swizzle to use for the final color variable\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionColor(lodVarName?: string, swizzleLookupTexture = \".rgb\"): string {\r\n        const colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : (swizzleLookupTexture.length - 1));\r\n\r\n        let code = `${colorType} ${this._reflectionColorName};\r\n            #ifdef ${this._define3DName}\\r\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\\r\\n`;\r\n        }\r\n\r\n        code += `\r\n            #else\\r\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\\r\\n`;\r\n        }\r\n\r\n        code += `#endif\\r\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the code corresponding to the connected output points\r\n     * @param state node material build state\r\n     * @param varName name of the variable to output\r\n     * @returns the shader code\r\n     */\r\n    public writeOutputs(state: NodeMaterialBuildState, varName: string): string {\r\n        let code = \"\";\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            for (var output of this._outputs) {\r\n                if (output.hasEndpoints) {\r\n                    code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\r\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        if (!this.texture) {\r\n            return \"\";\r\n        }\r\n\r\n        let codeString: string;\r\n\r\n        if (this.texture.isCube) {\r\n            codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\r\\n`;\r\n        } else {\r\n            codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\r\\n`;\r\n        }\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        let serializationObject = super.serialize();\r\n\r\n        if (this.texture) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ReflectionTextureBaseBlock\"] = ReflectionTextureBaseBlock;"]}