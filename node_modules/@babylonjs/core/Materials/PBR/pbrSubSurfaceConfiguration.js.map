{"version":3,"file":"pbrSubSurfaceConfiguration.js","sourceRoot":"","sources":["../../../../sourceES6/core/Materials/PBR/pbrSubSurfaceConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { IAnimatable } from '../../Animations/animatable.interface';\r\nimport { SerializationHelper, serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from '../../Maths/math.color';\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Effect } from \"../../Materials/effect\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport { EffectFallbacks } from '../effectFallbacks';\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\n\r\ndeclare type Engine = import(\"../../Engines/engine\").Engine;\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface IMaterialSubSurfaceDefines {\r\n    SUBSURFACE: boolean;\r\n\r\n    SS_REFRACTION: boolean;\r\n    SS_TRANSLUCENCY: boolean;\r\n    SS_SCATTERING: boolean;\r\n\r\n    SS_THICKNESSANDMASK_TEXTURE: boolean;\r\n    SS_THICKNESSANDMASK_TEXTUREDIRECTUV: number;\r\n\r\n    SS_REFRACTIONMAP_3D: boolean;\r\n    SS_REFRACTIONMAP_OPPOSITEZ: boolean;\r\n    SS_LODINREFRACTIONALPHA: boolean;\r\n    SS_GAMMAREFRACTION: boolean;\r\n    SS_RGBDREFRACTION: boolean;\r\n    SS_LINEARSPECULARREFRACTION: boolean;\r\n    SS_LINKREFRACTIONTOTRANSPARENCY: boolean;\r\n    SS_ALBEDOFORREFRACTIONTINT: boolean;\r\n\r\n    SS_MASK_FROM_THICKNESS_TEXTURE: boolean;\r\n    SS_MASK_FROM_THICKNESS_TEXTURE_GLTF: boolean;\r\n\r\n    /** @hidden */\r\n    _areTexturesDirty: boolean;\r\n}\r\n\r\n/**\r\n * Define the code related to the sub surface parameters of the pbr material.\r\n */\r\nexport class PBRSubSurfaceConfiguration {\r\n\r\n    private _isRefractionEnabled = false;\r\n    /**\r\n     * Defines if the refraction is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isRefractionEnabled = false;\r\n\r\n    private _isTranslucencyEnabled = false;\r\n    /**\r\n     * Defines if the translucency is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTranslucencyEnabled = false;\r\n\r\n    private _isScatteringEnabled = false;\r\n    /**\r\n     * Defines if the sub surface scattering is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markScenePrePassDirty\")\r\n    public isScatteringEnabled = false;\r\n\r\n    @serialize()\r\n    private _scatteringDiffusionProfileIndex = 0;\r\n\r\n    /**\r\n     * Diffusion profile for subsurface scattering.\r\n     * Useful for better scattering in the skins or foliages.\r\n     */\r\n    public get scatteringDiffusionProfile() : Nullable<Color3> {\r\n        if (!this._scene.subSurfaceConfiguration) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\r\n    }\r\n\r\n    public set scatteringDiffusionProfile(c: Nullable<Color3>) {\r\n        if (!this._scene.enableSubSurfaceForPrePass()) {\r\n            // Not supported\r\n            return;\r\n        }\r\n\r\n        // addDiffusionProfile automatically checks for doubles\r\n        if (c) {\r\n            this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration!.addDiffusionProfile(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the refraction intensity of the material.\r\n     * The refraction when enabled replaces the Diffuse part of the material.\r\n     * The intensity helps transitionning between diffuse and refraction.\r\n     */\r\n    @serialize()\r\n    public refractionIntensity: number = 1;\r\n\r\n    /**\r\n     * Defines the translucency intensity of the material.\r\n     * When translucency has been enabled, this defines how much of the \"translucency\"\r\n     * is addded to the diffuse part of the material.\r\n     */\r\n    @serialize()\r\n    public translucencyIntensity: number = 1;\r\n\r\n    /**\r\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintRefraction: boolean = false;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\r\n     * The red channel of the texture should contain the thickness remapped between 0 and 1.\r\n     * 0 would mean minimumThickness\r\n     * 1 would mean maximumThickness\r\n     * The other channels might be use as a mask to vary the different effects intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Defines the texture to use for refraction.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _indexOfRefraction = 1.5;\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = 1.5;\r\n\r\n    @serialize()\r\n    private _volumeIndexOfRefraction = -1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material's volume.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\r\n     * the volume will use the same IOR as the surface.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public get volumeIndexOfRefraction(): number {\r\n        if (this._volumeIndexOfRefraction >= 1.0) {\r\n            return this._volumeIndexOfRefraction;\r\n        }\r\n        return this._indexOfRefraction;\r\n    }\r\n    public set volumeIndexOfRefraction(value: number) {\r\n        if (value >= 1.0) {\r\n            this._volumeIndexOfRefraction = value;\r\n        } else {\r\n            this._volumeIndexOfRefraction = -1.0;\r\n        }\r\n    }\r\n\r\n    private _invertRefractionY = false;\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertRefractionY = false;\r\n\r\n    private _linkRefractionWithTransparency = false;\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting aginst not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkRefractionWithTransparency = false;\r\n\r\n    /**\r\n     * Defines the minimum thickness stored in the thickness map.\r\n     * If no thickness map is defined, this value will be used to simulate thickness.\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = 0;\r\n\r\n    /**\r\n     * Defines the maximum thickness stored in the thickness map.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = 1;\r\n\r\n    /**\r\n     * Defines the volume tint of the material.\r\n     * This is used for both translucency and scattering.\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the media.\r\n     * This is used for refraction only.\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines how far each channel transmit through the media.\r\n     * It is defined as a color to simplify it selection.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffusionDistance = Color3.White();\r\n\r\n    private _useMaskFromThicknessTexture = false;\r\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture.\r\n     * * the green channel is the translucency intensity.\r\n     * * the blue channel is the scattering intensity.\r\n     * * the alpha channel is the refraction intensity.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMaskFromThicknessTexture: boolean = false;\r\n\r\n    private _scene: Scene;\r\n    private _useMaskFromThicknessTextureGltf = false;\r\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture. This variation\r\n     * matches the channel-packing that is used by glTF.\r\n     * * the red channel is the transmission/translucency intensity.\r\n     * * the green channel is the thickness.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMaskFromThicknessTextureGltf: boolean = false;\r\n\r\n    /** @hidden */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n    private _internalMarkScenePrePassDirty: () => void;\r\n\r\n    /** @hidden */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n    /** @hidden */\r\n    public _markScenePrePassDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n        this._internalMarkScenePrePassDirty();\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new istance of sub surface configuration.\r\n     * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n     * @param markScenePrePassDirty Callback to flag the scene as prepass dirty\r\n     * @param scene The scene\r\n     */\r\n    constructor(markAllSubMeshesAsTexturesDirty: () => void, markScenePrePassDirty: () => void, scene: Scene) {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\r\n        this._internalMarkScenePrePassDirty = markScenePrePassDirty;\r\n        this._scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Gets wehter the submesh is ready to be used or not.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public isReadyForSubMesh(defines: IMaterialSubSurfaceDefines, scene: Scene): boolean {\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                var refractionTexture = this._getRefractionTexture(scene);\r\n                if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                    if (!refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene to the material belongs to.\r\n     */\r\n    public prepareDefines(defines: IMaterialSubSurfaceDefines, scene: Scene): void {\r\n        if (defines._areTexturesDirty) {\r\n            defines.SUBSURFACE = false;\r\n\r\n            defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\r\n            defines.SS_SCATTERING = this._isScatteringEnabled;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n\r\n            if (this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled) {\r\n                defines.SUBSURFACE = true;\r\n\r\n                if (defines._areTexturesDirty) {\r\n                    if (scene.texturesEnabled) {\r\n                        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                            MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\r\n                        }\r\n                    }\r\n                }\r\n\r\n                defines.SS_MASK_FROM_THICKNESS_TEXTURE = this._useMaskFromThicknessTexture;\r\n                defines.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = this._useMaskFromThicknessTextureGltf;\r\n            }\r\n\r\n            if (this._isRefractionEnabled) {\r\n                if (scene.texturesEnabled) {\r\n                    var refractionTexture = this._getRefractionTexture(scene);\r\n                    if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                        defines.SS_REFRACTION = true;\r\n                        defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\r\n                        defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\r\n                        defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\r\n                        defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\r\n                        defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;\r\n                        defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\r\n                        defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\r\n                        defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine defines the engine the material belongs to.\r\n     * @param isFrozen defines whether the material is frozen or not.\r\n     * @param lodBasedMicrosurface defines whether the material relies on lod based microsurface or not.\r\n     * @param realTimeFiltering defines whether the textures should be filtered on the fly.\r\n     */\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, isFrozen: boolean, lodBasedMicrosurface: boolean, realTimeFiltering: boolean): void {\r\n        var refractionTexture = this._getRefractionTexture(scene);\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\r\n            }\r\n\r\n            uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness, this.maximumThickness - this.minimumThickness);\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getReflectionTextureMatrix());\r\n\r\n                var depth = 1.0;\r\n                if (!refractionTexture.isCube) {\r\n                    if ((<any>refractionTexture).depth) {\r\n                        depth = (<any>refractionTexture).depth;\r\n                    }\r\n                }\r\n\r\n                var width = refractionTexture.getSize().width;\r\n                var refractionIor = this.volumeIndexOfRefraction;\r\n                uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\r\n                uniformBuffer.updateFloat3(\"vRefractionMicrosurfaceInfos\",\r\n                    width,\r\n                    refractionTexture.lodGenerationScale,\r\n                    refractionTexture.lodGenerationOffset);\r\n\r\n                if (realTimeFiltering) {\r\n                    uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\r\n                }\r\n            }\r\n\r\n            if (this.isScatteringEnabled) {\r\n                uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\r\n            }\r\n            uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\r\n\r\n            uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r,\r\n                this.tintColor.g,\r\n                this.tintColor.b,\r\n                this.tintColorAtDistance);\r\n\r\n            uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                if (lodBasedMicrosurface) {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\r\n                }\r\n                else {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh.\r\n     * @param activeEffect defines the effect that should be unbound from.\r\n     * @returns true if unbound, otherwise false\r\n     */\r\n    public unbind(activeEffect: Effect): boolean {\r\n        if (this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            activeEffect.setTexture(\"refractionSampler\", null);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for refraction or null if none is used.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - Refraction texture if present.  If no refraction texture and refraction\r\n     * is linked with transparency, returns environment texture.  Otherwise, returns null.\r\n     */\r\n    private _getRefractionTexture(scene: Scene): Nullable<BaseTexture> {\r\n        if (this._refractionTexture) {\r\n            return this._refractionTexture;\r\n        }\r\n\r\n        if (this._isRefractionEnabled) {\r\n            return scene.environmentTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    public get disableAlphaBlending(): boolean {\r\n        return this.isRefractionEnabled && this._linkRefractionWithTransparency;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param renderTargets the list of render targets to update\r\n     */\r\n    public fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     * @returns true if this uses a render target otherwise false.\r\n     */\r\n    public hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param activeTextures Array of BaseTextures\r\n     */\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param animatables Array of animatable textures.\r\n     */\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            animatables.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._thicknessTexture) {\r\n                this._thicknessTexture.dispose();\r\n            }\r\n\r\n            if (this._refractionTexture) {\r\n                this._refractionTexture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Get the current class name of the texture useful for serialization or dynamic coding.\r\n    * @returns \"PBRSubSurfaceConfiguration\"\r\n    */\r\n    public getClassName(): string {\r\n        return \"PBRSubSurfaceConfiguration\";\r\n    }\r\n\r\n    /**\r\n     * Add fallbacks to the effect fallbacks list.\r\n     * @param defines defines the Base texture to use.\r\n     * @param fallbacks defines the current fallback list.\r\n     * @param currentRank defines the current fallback rank.\r\n     * @returns the new fallback rank.\r\n     */\r\n    public static AddFallbacks(defines: IMaterialSubSurfaceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SS_SCATTERING) {\r\n            fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\r\n        }\r\n        if (defines.SS_TRANSLUCENCY) {\r\n            fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    public static AddUniforms(uniforms: string[]): void {\r\n        uniforms.push(\r\n            \"vDiffusionDistance\", \"vTintColor\", \"vSubSurfaceIntensity\",\r\n            \"vRefractionMicrosurfaceInfos\", \"vRefractionFilteringInfo\",\r\n            \"vRefractionInfos\", \"vThicknessInfos\", \"vThicknessParam\",\r\n            \"refractionMatrix\", \"thicknessMatrix\", \"scatteringDiffusionProfile\");\r\n    }\r\n\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    public static AddSamplers(samplers: string[]): void {\r\n        samplers.push(\"thicknessSampler\",\r\n            \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current buffer.\r\n     * @param uniformBuffer defines the current uniform buffer.\r\n     */\r\n    public static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void {\r\n        uniformBuffer.addUniform(\"vRefractionMicrosurfaceInfos\", 3);\r\n        uniformBuffer.addUniform(\"vRefractionFilteringInfo\", 2);\r\n        uniformBuffer.addUniform(\"vRefractionInfos\", 4);\r\n        uniformBuffer.addUniform(\"refractionMatrix\", 16);\r\n        uniformBuffer.addUniform(\"vThicknessInfos\", 2);\r\n        uniformBuffer.addUniform(\"thicknessMatrix\", 16);\r\n        uniformBuffer.addUniform(\"vThicknessParam\", 2);\r\n        uniformBuffer.addUniform(\"vDiffusionDistance\", 3);\r\n        uniformBuffer.addUniform(\"vTintColor\", 4);\r\n        uniformBuffer.addUniform(\"vSubSurfaceIntensity\", 3);\r\n        uniformBuffer.addUniform(\"scatteringDiffusionProfile\", 1);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param configuration define the config where to copy the info\r\n     */\r\n    public copyTo(configuration: PBRSubSurfaceConfiguration): void {\r\n        SerializationHelper.Clone(() => configuration, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this Sub Surface configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a anisotropy Configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}"]}