{"version":3,"file":"equiRectangularCubeTexture.js","sourceRoot":"","sources":["../../../../sourceES6/core/Materials/Textures/equiRectangularCubeTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { PanoramaToCubeMapTools } from '../../Misc/HighDynamicRange/panoramaToCubemap';\nimport { BaseTexture } from './baseTexture';\nimport { Texture } from './texture';\nimport { Scene } from \"../../scene\";\nimport { Nullable } from \"../../types\";\nimport { Tools } from '../../Misc/tools';\nimport \"../../Engines/Extensions/engine.rawTexture\";\n\n\n/**\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\n */\nexport class EquiRectangularCubeTexture extends BaseTexture {\n    /** The six faces of the cube. */\n    private static _FacesMapping = ['right', 'left', 'up', 'down', 'front', 'back'];\n\n    private _noMipmap: boolean;\n    private _onLoad: Nullable<() => void> = null;\n    private _onError: Nullable<() => void> = null;\n\n    /** The size of the cubemap. */\n    private _size: number;\n\n    /** The buffer of the image. */\n    private _buffer: ArrayBuffer;\n\n    /** The width of the input image. */\n    private _width: number;\n\n    /** The height of the input image. */\n    private _height: number;\n\n    /** The URL to the image. */\n    public url: string;\n\n    /**\n     * Instantiates an EquiRectangularCubeTexture from the following parameters.\n     * @param url The location of the image\n     * @param scene The scene the texture will be used in\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\n     * @param noMipmap Forces to not generate the mipmap if true\n     * @param gammaSpace Specifies if the texture will be used in gamma or linear space\n     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\n     * @param onLoad — defines a callback called when texture is loaded\n     * @param onError — defines a callback called if there is an error\n     */\n    constructor(\n        url: string,\n        scene: Scene,\n        size: number,\n        noMipmap: boolean = false,\n        gammaSpace: boolean = true,\n        onLoad: Nullable<() => void> = null,\n        onError: Nullable<(message?: string, exception?: any) => void> = null\n    ) {\n        super(scene);\n\n        if (!url) {\n            throw new Error('Image url is not set');\n        }\n\n        this._coordinatesMode = Texture.CUBIC_MODE;\n        this.name = url;\n        this.url = url;\n        this._size = size;\n        this._noMipmap = noMipmap;\n        this.gammaSpace = gammaSpace;\n        this._onLoad = onLoad;\n        this._onError = onError;\n\n        this.hasAlpha = false;\n        this.isCube = true;\n\n        this._texture = this._getFromCache(url, this._noMipmap);\n\n        if (!this._texture) {\n            if (!scene.useDelayedTextureLoading) {\n                this.loadImage(this.loadTexture.bind(this), this._onError);\n            } else {\n                this.delayLoadState = 4;\n            }\n        } else if (onLoad) {\n            if (this._texture.isReady) {\n                Tools.SetImmediate(() => onLoad());\n            } else {\n                this._texture.onLoadedObservable.add(onLoad);\n            }\n        }\n    }\n\n    /**\n     * Load the image data, by putting the image on a canvas and extracting its buffer.\n     */\n    private loadImage(loadTextureCallback: () => void, onError: Nullable<(message?: string, exception?: any) => void>): void {\n        const canvas = document.createElement('canvas');\n        const image = new Image();\n\n        image.addEventListener('load', () => {\n            this._width = image.width;\n            this._height = image.height;\n            canvas.width = this._width;\n            canvas.height = this._height;\n\n            const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n            ctx.drawImage(image, 0, 0);\n\n            const imageData = ctx.getImageData(0, 0, image.width, image.height);\n            this._buffer = imageData.data.buffer as ArrayBuffer;\n\n            canvas.remove();\n            loadTextureCallback();\n        });\n        image.addEventListener('error', (error) => {\n            if (onError) {\n                onError(`${this.getClassName()} could not be loaded`, error);\n            }\n        });\n        image.src = this.url;\n    }\n\n    /**\n     * Convert the image buffer into a cubemap and create a CubeTexture.\n     */\n    private loadTexture(): void {\n        const scene = this.getScene();\n        const callback = (): Nullable<ArrayBufferView[]> => {\n            const imageData = this.getFloat32ArrayFromArrayBuffer(this._buffer);\n\n            // Extract the raw linear data.\n            const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size);\n\n            const results = [];\n\n            // Push each faces.\n            for (let i = 0; i < 6; i++) {\n                const dataFace = (data as any)[EquiRectangularCubeTexture._FacesMapping[i]];\n                results.push(dataFace);\n            }\n\n            return results;\n        };\n\n        if (!scene) {\n            return;\n        }\n        this._texture = scene\n            .getEngine()\n            .createRawCubeTextureFromUrl(\n                this.url,\n                scene,\n                this._size,\n                4,\n                scene.getEngine().getCaps().textureFloat\n                    ? 1\n                    : 7,\n                this._noMipmap,\n                callback,\n                null,\n                this._onLoad,\n                this._onError\n            );\n    }\n\n    /**\n     * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\n     * @param buffer The ArrayBuffer that should be converted.\n     * @returns The buffer as Float32Array.\n     */\n    private getFloat32ArrayFromArrayBuffer(buffer: ArrayBuffer): Float32Array {\n        const dataView = new DataView(buffer);\n        const floatImageData = new Float32Array((buffer.byteLength * 3) / 4);\n\n        let k = 0;\n        for (let i = 0; i < buffer.byteLength; i++) {\n            // We drop the transparency channel, because we do not need/want it\n            if ((i + 1) % 4 !== 0) {\n                floatImageData[k++] = dataView.getUint8(i) / 255;\n            }\n        }\n\n        return floatImageData;\n    }\n\n    /**\n     * Get the current class name of the texture useful for serialization or dynamic coding.\n     * @returns \"EquiRectangularCubeTexture\"\n     */\n    public getClassName(): string {\n        return \"EquiRectangularCubeTexture\";\n    }\n\n    /**\n     * Create a clone of the current EquiRectangularCubeTexture and return it.\n     * @returns A clone of the current EquiRectangularCubeTexture.\n     */\n    public clone(): EquiRectangularCubeTexture {\n        const scene = this.getScene();\n        if (!scene) {\n            return this;\n        }\n\n        const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\n\n        // Base texture\n        newTexture.level = this.level;\n        newTexture.wrapU = this.wrapU;\n        newTexture.wrapV = this.wrapV;\n        newTexture.coordinatesIndex = this.coordinatesIndex;\n        newTexture.coordinatesMode = this.coordinatesMode;\n\n        return newTexture;\n    }\n}\n"]}