import { Observable } from "../../Misc/observable";
import { Nullable, int } from "../../types";
declare type ThinEngine = import("../../Engines/thinEngine").ThinEngine;
declare type BaseTexture = import("../../Materials/Textures/baseTexture").BaseTexture;
declare type SphericalPolynomial = import("../../Maths/sphericalPolynomial").SphericalPolynomial;
/**
 * Defines the source of the internal texture
 */
export declare enum InternalTextureSource {
    /**
     * The source of the texture data is unknown
     */
    Unknown = 0,
    /**
    * Texture data comes from an URL
    */
    Url = 1,
    /**
     * Texture data is only used for temporary storage
     */
    Temp = 2,
    /**
     * Texture data comes from raw data (ArrayBuffer)
     */
    Raw = 3,
    /**
     * Texture content is dynamic (video or dynamic texture)
     */
    Dynamic = 4,
    /**
     * Texture content is generated by rendering to it
     */
    RenderTarget = 5,
    /**
     * Texture content is part of a multi render target process
     */
    MultiRenderTarget = 6,
    /**
     * Texture data comes from a cube data file
     */
    Cube = 7,
    /**
     * Texture data comes from a raw cube data
     */
    CubeRaw = 8,
    /**
     * Texture data come from a prefiltered cube data file
     */
    CubePrefiltered = 9,
    /**
     * Texture content is raw 3D data
     */
    Raw3D = 10,
    /**
     * Texture content is raw 2D array data
     */
    Raw2DArray = 11,
    /**
     * Texture content is a depth texture
     */
    Depth = 12,
    /**
     * Texture data comes from a raw cube data encoded with RGBD
     */
    CubeRawRGBD = 13
}
/**
 * Class used to store data associated with WebGL texture data for the engine
 * This class should not be used directly
 */
export declare class InternalTexture {
    /** @hidden */
    static _UpdateRGBDAsync: (internalTexture: InternalTexture, data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial>, lodScale: number, lodOffset: number) => Promise<void>;
    /**
     * Defines if the texture is ready
     */
    isReady: boolean;
    /**
     * Defines if the texture is a cube texture
     */
    isCube: boolean;
    /**
     * Defines if the texture contains 3D data
     */
    is3D: boolean;
    /**
     * Defines if the texture contains 2D array data
     */
    is2DArray: boolean;
    /**
     * Defines if the texture contains multiview data
     */
    isMultiview: boolean;
    /**
     * Gets the URL used to load this texture
     */
    url: string;
    /** @hidden */
    _originalUrl: string;
    /**
     * Gets the sampling mode of the texture
     */
    samplingMode: number;
    /**
     * Gets a boolean indicating if the texture needs mipmaps generation
     */
    generateMipMaps: boolean;
    /**
     * Gets the number of samples used by the texture (WebGL2+ only)
     */
    samples: number;
    /**
     * Gets the type of the texture (int, float...)
     */
    type: number;
    /**
     * Gets the format of the texture (RGB, RGBA...)
     */
    format: number;
    /**
     * Observable called when the texture is loaded
     */
    onLoadedObservable: Observable<InternalTexture>;
    /**
     * Gets the width of the texture
     */
    width: number;
    /**
     * Gets the height of the texture
     */
    height: number;
    /**
     * Gets the depth of the texture
     */
    depth: number;
    /**
     * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)
     */
    baseWidth: number;
    /**
     * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)
     */
    baseHeight: number;
    /**
     * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)
     */
    baseDepth: number;
    /**
     * Gets a boolean indicating if the texture is inverted on Y axis
     */
    invertY: boolean;
    /** @hidden */
    _invertVScale: boolean;
    /** @hidden */
    _associatedChannel: number;
    /** @hidden */
    _source: InternalTextureSource;
    /** @hidden */
    _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>;
    /** @hidden */
    _bufferView: Nullable<ArrayBufferView>;
    /** @hidden */
    _bufferViewArray: Nullable<ArrayBufferView[]>;
    /** @hidden */
    _bufferViewArrayArray: Nullable<ArrayBufferView[][]>;
    /** @hidden */
    _size: number;
    /** @hidden */
    _extension: string;
    /** @hidden */
    _files: Nullable<string[]>;
    /** @hidden */
    _workingCanvas: Nullable<HTMLCanvasElement | OffscreenCanvas>;
    /** @hidden */
    _workingContext: Nullable<CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D>;
    /** @hidden */
    _framebuffer: Nullable<WebGLFramebuffer>;
    /** @hidden */
    _depthStencilBuffer: Nullable<WebGLRenderbuffer>;
    /** @hidden */
    _MSAAFramebuffer: Nullable<WebGLFramebuffer>;
    /** @hidden */
    _MSAARenderBuffer: Nullable<WebGLRenderbuffer>;
    /** @hidden */
    _attachments: Nullable<number[]>;
    /** @hidden */
    _textureArray: Nullable<InternalTexture[]>;
    /** @hidden */
    _cachedCoordinatesMode: Nullable<number>;
    /** @hidden */
    _cachedWrapU: Nullable<number>;
    /** @hidden */
    _cachedWrapV: Nullable<number>;
    /** @hidden */
    _cachedWrapR: Nullable<number>;
    /** @hidden */
    _cachedAnisotropicFilteringLevel: Nullable<number>;
    /** @hidden */
    _isDisabled: boolean;
    /** @hidden */
    _compression: Nullable<string>;
    /** @hidden */
    _generateStencilBuffer: boolean;
    /** @hidden */
    _generateDepthBuffer: boolean;
    /** @hidden */
    _comparisonFunction: number;
    /** @hidden */
    _sphericalPolynomial: Nullable<SphericalPolynomial>;
    /** @hidden */
    _lodGenerationScale: number;
    /** @hidden */
    _lodGenerationOffset: number;
    /** @hidden */
    _depthStencilTexture: Nullable<InternalTexture>;
    /** @hidden */
    _colorTextureArray: Nullable<WebGLTexture>;
    /** @hidden */
    _depthStencilTextureArray: Nullable<WebGLTexture>;
    /** @hidden */
    _lodTextureHigh: Nullable<BaseTexture>;
    /** @hidden */
    _lodTextureMid: Nullable<BaseTexture>;
    /** @hidden */
    _lodTextureLow: Nullable<BaseTexture>;
    /** @hidden */
    _isRGBD: boolean;
    /** @hidden */
    _linearSpecularLOD: boolean;
    /** @hidden */
    _irradianceTexture: Nullable<BaseTexture>;
    /** @hidden */
    _webGLTexture: Nullable<WebGLTexture>;
    /** @hidden */
    _references: number;
    /** @hidden */
    _gammaSpace: Nullable<boolean>;
    private _engine;
    /**
     * Gets the Engine the texture belongs to.
     * @returns The babylon engine
     */
    getEngine(): ThinEngine;
    /**
     * Gets the data source type of the texture
     */
    get source(): InternalTextureSource;
    /**
     * Creates a new InternalTexture
     * @param engine defines the engine to use
     * @param source defines the type of data that will be used
     * @param delayAllocation if the texture allocation should be delayed (default: false)
     */
    constructor(engine: ThinEngine, source: InternalTextureSource, delayAllocation?: boolean);
    /**
     * Increments the number of references (ie. the number of Texture that point to it)
     */
    incrementReferences(): void;
    /**
     * Change the size of the texture (not the size of the content)
     * @param width defines the new width
     * @param height defines the new height
     * @param depth defines the new depth (1 by default)
     */
    updateSize(width: int, height: int, depth?: int): void;
    /** @hidden */
    _rebuild(): void;
    /** @hidden */
    _swapAndDie(target: InternalTexture): void;
    /**
     * Dispose the current allocated resources
     */
    dispose(): void;
}
export {};
