import { Nullable } from "../types";
import { Scene } from "../scene";
import { BaseTexture } from './Textures/baseTexture';
import { UniformBuffer } from './uniformBuffer';
import { IAnimatable } from '../Animations/animatable.interface';
/**
 * @hidden
 */
export interface IMaterialDetailMapDefines {
    DETAIL: boolean;
    DETAILDIRECTUV: number;
    DETAIL_NORMALBLENDMETHOD: number;
    /** @hidden */
    _areTexturesDirty: boolean;
}
/**
 * Define the code related to the detail map parameters of a material
 *
 * Inspired from:
 *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html
 *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html
 *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps
 */
export declare class DetailMapConfiguration {
    private _texture;
    /**
     * The detail texture of the material.
     */
    texture: Nullable<BaseTexture>;
    /**
     * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture
     * Bigger values mean stronger blending
     */
    diffuseBlendLevel: number;
    /**
     * Defines how strongly the detail roughness channel is blended with the regular roughness value
     * Bigger values mean stronger blending. Only used with PBR materials
     */
    roughnessBlendLevel: number;
    /**
     * Defines how strong the bump effect from the detail map is
     * Bigger values mean stronger effect
     */
    bumpLevel: number;
    private _normalBlendMethod;
    /**
     * The method used to blend the bump and detail normals together
     */
    normalBlendMethod: number;
    private _isEnabled;
    /**
     * Enable or disable the detail map on this material
     */
    isEnabled: boolean;
    /** @hidden */
    private _internalMarkAllSubMeshesAsTexturesDirty;
    /** @hidden */
    _markAllSubMeshesAsTexturesDirty(): void;
    /**
     * Instantiate a new detail map
     * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
     */
    constructor(markAllSubMeshesAsTexturesDirty: () => void);
    /**
     * Gets whether the submesh is ready to be used or not.
     * @param defines the list of "defines" to update.
     * @param scene defines the scene the material belongs to.
     * @returns - boolean indicating that the submesh is ready or not.
     */
    isReadyForSubMesh(defines: IMaterialDetailMapDefines, scene: Scene): boolean;
    /**
     * Update the defines for detail map usage
     * @param defines the list of "defines" to update.
     * @param scene defines the scene the material belongs to.
     */
    prepareDefines(defines: IMaterialDetailMapDefines, scene: Scene): void;
    /**
     * Binds the material data.
     * @param uniformBuffer defines the Uniform buffer to fill in.
     * @param scene defines the scene the material belongs to.
     * @param isFrozen defines whether the material is frozen or not.
     */
    bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, isFrozen: boolean): void;
    /**
     * Checks to see if a texture is used in the material.
     * @param texture - Base texture to use.
     * @returns - Boolean specifying if a texture is used in the material.
     */
    hasTexture(texture: BaseTexture): boolean;
    /**
     * Returns an array of the actively used textures.
     * @param activeTextures Array of BaseTextures
     */
    getActiveTextures(activeTextures: BaseTexture[]): void;
    /**
     * Returns the animatable textures.
     * @param animatables Array of animatable textures.
     */
    getAnimatables(animatables: IAnimatable[]): void;
    /**
     * Disposes the resources of the material.
     * @param forceDisposeTextures - Forces the disposal of all textures.
     */
    dispose(forceDisposeTextures?: boolean): void;
    /**
    * Get the current class name useful for serialization or dynamic coding.
    * @returns "DetailMap"
    */
    getClassName(): string;
    /**
     * Add the required uniforms to the current list.
     * @param uniforms defines the current uniform list.
     */
    static AddUniforms(uniforms: string[]): void;
    /**
     * Add the required samplers to the current list.
     * @param samplers defines the current sampler list.
     */
    static AddSamplers(samplers: string[]): void;
    /**
     * Add the required uniforms to the current buffer.
     * @param uniformBuffer defines the current uniform buffer.
     */
    static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void;
    /**
     * Makes a duplicate of the current instance into another one.
     * @param detailMap define the instance where to copy the info
     */
    copyTo(detailMap: DetailMapConfiguration): void;
    /**
     * Serializes this detail map instance
     * @returns - An object with the serialized instance.
     */
    serialize(): any;
    /**
     * Parses a detail map setting from a serialized object.
     * @param source - Serialized object.
     * @param scene Defines the scene we are parsing for
     * @param rootUrl Defines the rootUrl to load from
     */
    parse(source: any, scene: Scene, rootUrl: string): void;
}
