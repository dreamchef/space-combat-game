{"version":3,"file":"multiMaterial.js","sourceRoot":"","sources":["../../../sourceES6/core/Materials/multiMaterial.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\n/**\r\n * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n * separate meshes. This can be use to improve performances.\r\n * @see https://doc.babylonjs.com/how_to/multi_materials\r\n */\r\nexport class MultiMaterial extends Material {\r\n    private _subMaterials: Nullable<Material>[];\r\n\r\n    /**\r\n     * Gets or Sets the list of Materials used within the multi material.\r\n     * They need to be ordered according to the submeshes order in the associated mesh\r\n     */\r\n    public get subMaterials(): Nullable<Material>[] {\r\n        return this._subMaterials;\r\n    }\r\n\r\n    public set subMaterials(value: Nullable<Material>[]) {\r\n        this._subMaterials = value;\r\n        this._hookArray(value);\r\n    }\r\n\r\n    /**\r\n     * Function used to align with Node.getChildren()\r\n     * @returns the list of Materials used within the multi material\r\n     */\r\n    public getChildren(): Nullable<Material>[] {\r\n        return this.subMaterials;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Multi Material\r\n     * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n     * separate meshes. This can be use to improve performances.\r\n     * @see https://doc.babylonjs.com/how_to/multi_materials\r\n     * @param name Define the name in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene, true);\r\n\r\n        scene.multiMaterials.push(this);\r\n\r\n        this.subMaterials = new Array<Material>();\r\n\r\n        this._storeEffectOnSubMeshes = true; // multimaterial is considered like a push material\r\n    }\r\n\r\n    private _hookArray(array: Nullable<Material>[]): void {\r\n        var oldPush = array.push;\r\n        array.push = (...items: Nullable<Material>[]) => {\r\n            var result = oldPush.apply(array, items);\r\n\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            return result;\r\n        };\r\n\r\n        var oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            var deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            return deleted;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get one of the submaterial by its index in the submaterials array\r\n     * @param index The index to look the sub material at\r\n     * @returns The Material if the index has been defined\r\n     */\r\n    public getSubMaterial(index: number): Nullable<Material> {\r\n        if (index < 0 || index >= this.subMaterials.length) {\r\n            return this.getScene().defaultMaterial;\r\n        }\r\n\r\n        return this.subMaterials[index];\r\n    }\r\n\r\n    /**\r\n     * Get the list of active textures for the whole sub materials list.\r\n     * @returns All the textures that will be used during the rendering\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        return super.getActiveTextures().concat(...this.subMaterials.map((subMaterial) => {\r\n            if (subMaterial) {\r\n                return subMaterial.getActiveTextures();\r\n            } else {\r\n                return [];\r\n            }\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Specifies if any sub-materials of this multi-material use a given texture.\r\n     * @param texture Defines the texture to check against this multi-material's sub-materials.\r\n     * @returns A boolean specifying if any sub-material of this multi-material uses the texture.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (let i = 0; i < this.subMaterials.length; i++) {\r\n            if (this.subMaterials[i]?.hasTexture(texture)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"MultiMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"MultiMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested sub mesh\r\n     * @param mesh Define the mesh the submesh belongs to\r\n     * @param subMesh Define the sub mesh to look readyness for\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        for (var index = 0; index < this.subMaterials.length; index++) {\r\n            var subMaterial = this.subMaterials[index];\r\n            if (subMaterial) {\r\n                if (subMaterial._storeEffectOnSubMeshes) {\r\n                    if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {\r\n                        return false;\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (!subMaterial.isReady(mesh)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Clones the current material and its related sub materials\r\n     * @param name Define the name of the newly cloned material\r\n     * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string, cloneChildren?: boolean): MultiMaterial {\r\n        var newMultiMaterial = new MultiMaterial(name, this.getScene());\r\n\r\n        for (var index = 0; index < this.subMaterials.length; index++) {\r\n            var subMaterial: Nullable<Material> = null;\r\n            let current = this.subMaterials[index];\r\n            if (cloneChildren && current) {\r\n                subMaterial = current.clone(name + \"-\" + current.name);\r\n            } else {\r\n                subMaterial = this.subMaterials[index];\r\n            }\r\n            newMultiMaterial.subMaterials.push(subMaterial);\r\n        }\r\n\r\n        return newMultiMaterial;\r\n    }\r\n\r\n    /**\r\n     * Serializes the materials into a JSON representation.\r\n     * @returns the JSON representation\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n        serializationObject.materials = [];\r\n\r\n        for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\r\n            var subMat = this.subMaterials[matIndex];\r\n\r\n            if (subMat) {\r\n                serializationObject.materials.push(subMat.id);\r\n            } else {\r\n                serializationObject.materials.push(null);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Dispose the material and release its associated resources\r\n     * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)\r\n     * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)\r\n     * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, forceDisposeChildren?: boolean): void {\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        if (forceDisposeChildren) {\r\n            for (var index = 0; index < this.subMaterials.length; index++) {\r\n                var subMaterial = this.subMaterials[index];\r\n                if (subMaterial) {\r\n                    subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);\r\n                }\r\n            }\r\n        }\r\n\r\n        var index = scene.multiMaterials.indexOf(this);\r\n        if (index >= 0) {\r\n            scene.multiMaterials.splice(index, 1);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n\r\n    /**\r\n     * Creates a MultiMaterial from parsed MultiMaterial data.\r\n     * @param parsedMultiMaterial defines parsed MultiMaterial data.\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MultiMaterial\r\n     */\r\n    public static ParseMultiMaterial(parsedMultiMaterial: any, scene: Scene): MultiMaterial {\r\n        var multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);\r\n\r\n        multiMaterial.id = parsedMultiMaterial.id;\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\r\n        }\r\n\r\n        for (var matIndex = 0; matIndex < parsedMultiMaterial.materials.length; matIndex++) {\r\n            var subMatId = parsedMultiMaterial.materials[matIndex];\r\n\r\n            if (subMatId) {\r\n                // If the same multimaterial is loaded twice, the 2nd multimaterial needs to reference the latest material by that id which\r\n                // is why this lookup should use getLastMaterialByID instead of getMaterialByID\r\n                multiMaterial.subMaterials.push(scene.getLastMaterialByID(subMatId));\r\n            } else {\r\n                multiMaterial.subMaterials.push(null);\r\n            }\r\n        }\r\n\r\n        return multiMaterial;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.MultiMaterial\"] = MultiMaterial;\r\n"]}