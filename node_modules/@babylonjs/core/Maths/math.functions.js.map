{"version":3,"file":"math.functions.js","sourceRoot":"","sources":["../../../sourceES6/core/Maths/math.functions.ts"],"names":[],"mappings":"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","sourcesContent":["import { FloatArray, Nullable, IndicesArray } from '../types';\r\nimport { Vector2, Vector3 } from './math.vector';\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of indexed positions\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to the positions\r\n * @param indexStart defines the start index\r\n * @param indexCount defines the end index\r\n * @param bias defines bias value to add to the result\r\n * @return minimum and maximum values\r\n */\r\nexport function extractMinAndMaxIndexed(positions: FloatArray, indices: IndicesArray, indexStart: number, indexCount: number, bias: Nullable<Vector2> = null): { minimum: Vector3; maximum: Vector3 } {\r\n    var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    for (var index = indexStart; index < indexStart + indexCount; index++) {\r\n        const offset = indices[index] * 3;\r\n        const x = positions[offset];\r\n        const y = positions[offset + 1];\r\n        const z = positions[offset + 2];\r\n        minimum.minimizeInPlaceFromFloats(x, y, z);\r\n        maximum.maximizeInPlaceFromFloats(x, y, z);\r\n    }\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum\r\n    };\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of positions\r\n * @param positions defines the positions to use\r\n * @param start defines the start index in the positions array\r\n * @param count defines the number of positions to handle\r\n * @param bias defines bias value to add to the result\r\n * @param stride defines the stride size to use (distance between two positions in the positions array)\r\n * @return minimum and maximum values\r\n */\r\nexport function extractMinAndMax(positions: FloatArray, start: number, count: number, bias: Nullable<Vector2> = null, stride?: number): { minimum: Vector3; maximum: Vector3 } {\r\n    var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    if (!stride) {\r\n        stride = 3;\r\n    }\r\n\r\n    for (var index = start, offset = start * stride; index < start + count; index++ , offset += stride) {\r\n        const x = positions[offset];\r\n        const y = positions[offset + 1];\r\n        const z = positions[offset + 2];\r\n        minimum.minimizeInPlaceFromFloats(x, y, z);\r\n        maximum.maximizeInPlaceFromFloats(x, y, z);\r\n    }\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum\r\n    };\r\n}\r\n"]}