{"version":3,"file":"discBuilder.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Builders/discBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\n\r\nVertexData.CreateDisc = function(options: { radius?: number, tessellation?: number, arc?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n    var positions = new Array<number>();\r\n    var indices = new Array<number>();\r\n    var normals = new Array<number>();\r\n    var uvs = new Array<number>();\r\n\r\n    var radius = options.radius || 0.5;\r\n    var tessellation = options.tessellation || 64;\r\n    var arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // positions and uvs\r\n    positions.push(0, 0, 0);    // disc center first\r\n    uvs.push(0.5, 0.5);\r\n\r\n    var theta = Math.PI * 2 * arc;\r\n    var step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);\r\n    var a = 0;\r\n    for (var t = 0; t < tessellation; t++) {\r\n        var x = Math.cos(a);\r\n        var y = Math.sin(a);\r\n        var u = (x + 1) / 2;\r\n        var v = (1 - y) / 2;\r\n        positions.push(radius * x, radius * y, 0);\r\n        uvs.push(u, v);\r\n        a += step;\r\n    }\r\n    if (arc === 1) {\r\n        positions.push(positions[3], positions[4], positions[5]); // close the circle\r\n        uvs.push(uvs[2], uvs[3]);\r\n    }\r\n\r\n    //indices\r\n    var vertexNb = positions.length / 3;\r\n    for (var i = 1; i < vertexNb - 1; i++) {\r\n        indices.push(i + 1, 0, i);\r\n    }\r\n\r\n    // result\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateDisc = (name: string, radius: number, tessellation: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return DiscBuilder.CreateDisc(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class DiscBuilder {\r\n    /**\r\n     * Creates a plane polygonal mesh.  By default, this is a disc\r\n     * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\r\n     * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n     * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the plane polygonal mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon\r\n     */\r\n    public static CreateDisc(name: string, options: { radius?: number, tessellation?: number, arc?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }, scene: Nullable<Scene> = null): Mesh {\r\n        var disc = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        disc._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateDisc(options);\r\n\r\n        vertexData.applyToMesh(disc, options.updatable);\r\n\r\n        return disc;\r\n    }\r\n}"]}