{"version":3,"file":"linesBuilder.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Builders/linesBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\n\r\nVertexData.CreateLineSystem = function(options: { lines: Vector3[][], colors?: Nullable<Color4[][]> }): VertexData {\r\n    var indices = [];\r\n    var positions = [];\r\n    var lines = options.lines;\r\n    var colors = options.colors;\r\n    var vertexColors = [];\r\n    var idx = 0;\r\n\r\n    for (var l = 0; l < lines.length; l++) {\r\n        var points = lines[l];\r\n        for (var index = 0; index < points.length; index++) {\r\n            positions.push(points[index].x, points[index].y, points[index].z);\r\n            if (colors) {\r\n                var color = colors[l];\r\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    var vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n};\r\n\r\nVertexData.CreateDashedLines = function(options: { points: Vector3[], dashSize?: number, gapSize?: number, dashNb?: number }): VertexData {\r\n    var dashSize = options.dashSize || 3;\r\n    var gapSize = options.gapSize || 1;\r\n    var dashNb = options.dashNb || 200;\r\n    var points = options.points;\r\n\r\n    var positions = new Array<number>();\r\n    var indices = new Array<number>();\r\n\r\n    var curvect = Vector3.Zero();\r\n    var lg = 0;\r\n    var nb = 0;\r\n    var shft = 0;\r\n    var dashshft = 0;\r\n    var curshft = 0;\r\n    var idx = 0;\r\n    var i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = dashSize * shft / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (var j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    var options = {\r\n        points: points,\r\n        updatable: updatable,\r\n        instance: instance\r\n    };\r\n    return LinesBuilder.CreateLines(name, options, scene);\r\n};\r\n\r\nMesh.CreateDashedLines = (name: string, points: Vector3[], dashSize: number, gapSize: number, dashNb: number, scene: Nullable<Scene> = null, updatable?: boolean, instance?: LinesMesh): LinesMesh => {\r\n    var options = {\r\n        points: points,\r\n        dashSize: dashSize,\r\n        gapSize: gapSize,\r\n        dashNb: dashNb,\r\n        updatable: updatable,\r\n        instance: instance\r\n    };\r\n    return LinesBuilder.CreateDashedLines(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class LinesBuilder {\r\n    /**\r\n     * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n     * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n     * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n     * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n     * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n     * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\r\n     * @param name defines the name of the new line system\r\n     * @param options defines the options used to create the line system\r\n     * @param scene defines the hosting scene\r\n     * @returns a new line system mesh\r\n     */\r\n    public static CreateLineSystem(name: string, options: { lines: Vector3[][], updatable?: boolean, instance?: Nullable<LinesMesh>, colors?: Nullable<Color4[][]>, useVertexAlpha?: boolean }, scene: Nullable<Scene>): LinesMesh {\r\n        var instance = options.instance;\r\n        var lines = options.lines;\r\n        var colors = options.colors;\r\n\r\n        if (instance) { // lines update\r\n            var positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n            var vertexColor;\r\n            var lineColors;\r\n            if (colors) {\r\n                vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n            }\r\n            var i = 0;\r\n            var c = 0;\r\n            for (var l = 0; l < lines.length; l++) {\r\n                var points = lines[l];\r\n                for (var p = 0; p < points.length; p++) {\r\n                    positions[i] = points[p].x;\r\n                    positions[i + 1] = points[p].y;\r\n                    positions[i + 2] = points[p].z;\r\n                    if (colors && vertexColor) {\r\n                        lineColors = colors[l];\r\n                        vertexColor[c] = lineColors[p].r;\r\n                        vertexColor[c + 1] = lineColors[p].g;\r\n                        vertexColor[c + 2] = lineColors[p].b;\r\n                        vertexColor[c + 3] = lineColors[p].a;\r\n                        c += 4;\r\n                    }\r\n                    i += 3;\r\n                }\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n            if (colors && vertexColor) {\r\n                instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n            }\r\n            return instance;\r\n        }\r\n\r\n        // line system creation\r\n        var useVertexColor = (colors) ? true : false;\r\n        var lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha);\r\n        var vertexData = VertexData.CreateLineSystem(options);\r\n        vertexData.applyToMesh(lineSystem, options.updatable);\r\n        return lineSystem;\r\n    }\r\n\r\n    /**\r\n     * Creates a line mesh\r\n     * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n     * * The parameter `points` is an array successive Vector3\r\n     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n     * * When updating an instance, remember that only point positions can change, not the number of points\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\r\n     * @param name defines the name of the new line system\r\n     * @param options defines the options used to create the line system\r\n     * @param scene defines the hosting scene\r\n     * @returns a new line mesh\r\n     */\r\n    public static CreateLines(name: string, options: { points: Vector3[], updatable?: boolean, instance?: Nullable<LinesMesh>, colors?: Color4[], useVertexAlpha?: boolean }, scene: Nullable<Scene> = null): LinesMesh {\r\n        var colors = (options.colors) ? [options.colors] : null;\r\n        var lines = LinesBuilder.CreateLineSystem(name, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha }, scene);\r\n        return lines;\r\n    }\r\n\r\n    /**\r\n     * Creates a dashed line mesh\r\n     * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n     * * The parameter `points` is an array successive Vector3\r\n     * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n     * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n     * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n     * * When updating an instance, remember that only point positions can change, not the number of points\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the dashed line mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\r\n     */\r\n    public static CreateDashedLines(name: string, options: { points: Vector3[], dashSize?: number, gapSize?: number, dashNb?: number, updatable?: boolean, instance?: LinesMesh, useVertexAlpha?: boolean }, scene: Nullable<Scene> = null): LinesMesh {\r\n        var points = options.points;\r\n        var instance = options.instance;\r\n        var gapSize = options.gapSize || 1;\r\n        var dashSize = options.dashSize || 3;\r\n\r\n        if (instance) {  //  dashed lines update\r\n            var positionFunction = (positions: FloatArray): void => {\r\n                var curvect = Vector3.Zero();\r\n                var nbSeg = positions.length / 6;\r\n                var lg = 0;\r\n                var nb = 0;\r\n                var shft = 0;\r\n                var dashshft = 0;\r\n                var curshft = 0;\r\n                var p = 0;\r\n                var i = 0;\r\n                var j = 0;\r\n                for (i = 0; i < points.length - 1; i++) {\r\n                    points[i + 1].subtractToRef(points[i], curvect);\r\n                    lg += curvect.length();\r\n                }\r\n                shft = lg / nbSeg;\r\n                let dashSize = instance!._creationDataStorage!.dashSize;\r\n                let gapSize = instance!._creationDataStorage!.gapSize;\r\n                dashshft = dashSize * shft / (dashSize + gapSize);\r\n                for (i = 0; i < points.length - 1; i++) {\r\n                    points[i + 1].subtractToRef(points[i], curvect);\r\n                    nb = Math.floor(curvect.length() / shft);\r\n                    curvect.normalize();\r\n                    j = 0;\r\n                    while (j < nb && p < positions.length) {\r\n                        curshft = shft * j;\r\n                        positions[p] = points[i].x + curshft * curvect.x;\r\n                        positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                        positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                        positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                        positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                        positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                        p += 6;\r\n                        j++;\r\n                    }\r\n                }\r\n                while (p < positions.length) {\r\n                    positions[p] = points[i].x;\r\n                    positions[p + 1] = points[i].y;\r\n                    positions[p + 2] = points[i].z;\r\n                    p += 3;\r\n                }\r\n            };\r\n            instance.updateMeshPositions(positionFunction, false);\r\n            return instance;\r\n        }\r\n        // dashed lines creation\r\n        var dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha);\r\n        var vertexData = VertexData.CreateDashedLines(options);\r\n        vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n        dashedLines._creationDataStorage = new _CreationDataStorage();\r\n        dashedLines._creationDataStorage.dashSize = dashSize;\r\n        dashedLines._creationDataStorage.gapSize = gapSize;\r\n        return dashedLines;\r\n    }\r\n}"]}