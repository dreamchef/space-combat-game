{"version":3,"file":"shapeBuilder.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Builders/shapeBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3, TmpVectors, Vector4, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { RibbonBuilder } from \"./ribbonBuilder\";\r\nimport { Path3D } from '../../Maths/math.path';\r\n\r\nMesh.ExtrudeShape = (name: string, shape: Vector3[], path: Vector3[], scale: number, rotation: number, cap: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: (cap === 0) ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable\r\n    };\r\n\r\n    return ShapeBuilder.ExtrudeShape(name, options, scene);\r\n};\r\n\r\nMesh.ExtrudeShapeCustom = (name: string, shape: Vector3[], path: Vector3[], scaleFunction: Function, rotationFunction: Function, ribbonCloseArray: boolean, ribbonClosePath: boolean, cap: number, scene: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: (cap === 0) ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable\r\n    };\r\n\r\n    return ShapeBuilder.ExtrudeShapeCustom(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class ShapeBuilder {\r\n    /**\r\n     * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n     * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    public static ExtrudeShape(name: string, options: { shape: Vector3[], path: Vector3[], scale?: number, rotation?: number, cap?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, instance?: Mesh, invertUV?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var path = options.path;\r\n        var shape = options.shape;\r\n        var scale = options.scale || 1;\r\n        var rotation = options.rotation || 0;\r\n        var cap = (options.cap === 0) ? 0 : options.cap || Mesh.NO_CAP;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance || null;\r\n        var invertUV = options.invertUV || false;\r\n\r\n        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, false, false, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);\r\n    }\r\n\r\n    /**\r\n     * Creates an custom extruded shape mesh.\r\n     * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n     * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n     * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n     * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n     * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`\r\n     * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the custom extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    public static ExtrudeShapeCustom(name: string, options: { shape: Vector3[], path: Vector3[], scaleFunction?: any, rotationFunction?: any, ribbonCloseArray?: boolean, ribbonClosePath?: boolean, cap?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, instance?: Mesh, invertUV?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var path = options.path;\r\n        var shape = options.shape;\r\n        var scaleFunction = options.scaleFunction || (() => { return 1; });\r\n        var rotationFunction = options.rotationFunction || (() => { return 0; });\r\n        var ribbonCloseArray = options.ribbonCloseArray || false;\r\n        var ribbonClosePath = options.ribbonClosePath || false;\r\n        var cap = (options.cap === 0) ? 0 : options.cap || Mesh.NO_CAP;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance;\r\n        var invertUV = options.invertUV || false;\r\n        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);\r\n    }\r\n\r\n    private static _ExtrudeShapeGeneric(name: string, shape: Vector3[], curve: Vector3[], scale: Nullable<number>, rotation: Nullable<number>, scaleFunction: Nullable<{ (i: number, distance: number): number; }>,\r\n        rotateFunction: Nullable<{ (i: number, distance: number): number; }>, rbCA: boolean, rbCP: boolean, cap: number, custom: boolean,\r\n        scene: Nullable<Scene>, updtbl: boolean, side: number, instance: Nullable<Mesh>, invertUV: boolean, frontUVs: Nullable<Vector4>, backUVs: Nullable<Vector4>): Mesh {\r\n        // extrusion geometry\r\n        var extrusionPathArray = (shape: Vector3[], curve: Vector3[], path3D: Path3D, shapePaths: Vector3[][], scale: Nullable<number>, rotation: Nullable<number>,\r\n            scaleFunction: Nullable<{ (i: number, distance: number): number; }>, rotateFunction: Nullable<{ (i: number, distance: number): number; }>, cap: number, custom: boolean) => {\r\n            var tangents = path3D.getTangents();\r\n            var normals = path3D.getNormals();\r\n            var binormals = path3D.getBinormals();\r\n            var distances = path3D.getDistances();\r\n\r\n            var angle = 0;\r\n            var returnScale: { (i: number, distance: number): number; } = () => { return scale !== null ? scale : 1; };\r\n            var returnRotation: { (i: number, distance: number): number; } = () => { return rotation !== null ? rotation : 0; };\r\n            var rotate: { (i: number, distance: number): number; } = custom && rotateFunction ? rotateFunction : returnRotation;\r\n            var scl: { (i: number, distance: number): number; } = custom && scaleFunction ? scaleFunction : returnScale;\r\n            var index = (cap === Mesh.NO_CAP || cap === Mesh.CAP_END) ? 0 : 2;\r\n            var rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n\r\n            for (var i = 0; i < curve.length; i++) {\r\n                var shapePath = new Array<Vector3>();\r\n                var angleStep = rotate(i, distances[i]);\r\n                var scaleRatio = scl(i, distances[i]);\r\n                for (var p = 0; p < shape.length; p++) {\r\n                    Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n                    var planed = ((tangents[i].scale(shape[p].z)).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y)));\r\n                    var rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();\r\n                    Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                    rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                    shapePath[p] = rotated;\r\n                }\r\n                shapePaths[index] = shapePath;\r\n                angle += angleStep;\r\n                index++;\r\n            }\r\n            // cap\r\n            var capPath = (shapePath: Vector3[]) => {\r\n                var pointCap = Array<Vector3>();\r\n                var barycenter = Vector3.Zero();\r\n                var i: number;\r\n                for (i = 0; i < shapePath.length; i++) {\r\n                    barycenter.addInPlace(shapePath[i]);\r\n                }\r\n                barycenter.scaleInPlace(1.0 / shapePath.length);\r\n                for (i = 0; i < shapePath.length; i++) {\r\n                    pointCap.push(barycenter);\r\n                }\r\n                return pointCap;\r\n            };\r\n            switch (cap) {\r\n                case Mesh.NO_CAP:\r\n                    break;\r\n                case Mesh.CAP_START:\r\n                    shapePaths[0] = capPath(shapePaths[2]);\r\n                    shapePaths[1] = shapePaths[2];\r\n                    break;\r\n                case Mesh.CAP_END:\r\n                    shapePaths[index] = shapePaths[index - 1];\r\n                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                    break;\r\n                case Mesh.CAP_ALL:\r\n                    shapePaths[0] = capPath(shapePaths[2]);\r\n                    shapePaths[1] = shapePaths[2];\r\n                    shapePaths[index] = shapePaths[index - 1];\r\n                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            return shapePaths;\r\n        };\r\n        var path3D;\r\n        var pathArray;\r\n        if (instance) { // instance update\r\n            let storage = instance._creationDataStorage!;\r\n            path3D = storage.path3D.update(curve);\r\n            pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);\r\n            instance = Mesh.CreateRibbon(\"\", pathArray, false, false, 0, scene || undefined, false, 0, instance);\r\n\r\n            return instance;\r\n        }\r\n        // extruded shape creation\r\n        path3D = <any>new Path3D(curve);\r\n        var newShapePaths = new Array<Array<Vector3>>();\r\n        cap = (cap < 0 || cap > 3) ? 0 : cap;\r\n        pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\r\n        var extrudedGeneric = RibbonBuilder.CreateRibbon(name, { pathArray: pathArray, closeArray: rbCA, closePath: rbCP, updatable: updtbl, sideOrientation: side, invertUV: invertUV, frontUVs: frontUVs || undefined, backUVs: backUVs || undefined }, scene);\r\n        extrudedGeneric._creationDataStorage!.pathArray = pathArray;\r\n        extrudedGeneric._creationDataStorage!.path3D = path3D;\r\n        extrudedGeneric._creationDataStorage!.cap = cap;\r\n\r\n        return extrudedGeneric;\r\n    }\r\n}"]}