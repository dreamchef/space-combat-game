{"version":3,"file":"sphereBuilder.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Builders/sphereBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector4, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Nullable } from '../../types';\r\n\r\nVertexData.CreateSphere = function(options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, dedupTopBottomIndices?: boolean }): VertexData {\r\n    var segments: number = options.segments || 32;\r\n    var diameterX: number = options.diameterX || options.diameter || 1;\r\n    var diameterY: number = options.diameterY || options.diameter || 1;\r\n    var diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    var arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var slice: number = options.slice && (options.slice <= 0) ? 1.0 : options.slice || 1.0;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    var dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    var totalZRotationSteps = 2 + segments;\r\n    var totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n\r\n    for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        var normalizedZ = zRotationStep / totalZRotationSteps;\r\n        var angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            var normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            var angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            var rotationZ = Matrix.RotationZ(-angleZ);\r\n            var rotationY = Matrix.RotationY(angleY);\r\n            var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            var vertex = complete.multiply(radius);\r\n            var normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            var verticesCount = positions.length / 3;\r\n            for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); (firstIndex + totalYRotationSteps + 2) < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push((firstIndex));\r\n                        indices.push((firstIndex + 1));\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push((firstIndex + totalYRotationSteps + 1));\r\n                        indices.push((firstIndex + 1));\r\n                        indices.push((firstIndex + totalYRotationSteps + 2));\r\n                    }\r\n                }\r\n                else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return SphereBuilder.CreateSphere(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class SphereBuilder {\r\n    /**\r\n     * Creates a sphere mesh\r\n     * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n     * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n     * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n     * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n     * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the sphere mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n     */\r\n    public static CreateSphere(name: string, options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var sphere = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateSphere(options);\r\n\r\n        vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n        return sphere;\r\n    }\r\n}\r\n"]}