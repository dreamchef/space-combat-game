{"version":3,"file":"torusKnotBuilder.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Builders/torusKnotBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector4, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\n\r\nVertexData.CreateTorusKnot = function(options: { radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n    var indices = new Array<number>();\r\n    var positions = new Array<number>();\r\n    var normals = new Array<number>();\r\n    var uvs = new Array<number>();\r\n\r\n    var radius = options.radius || 2;\r\n    var tube = options.tube || 0.5;\r\n    var radialSegments = options.radialSegments || 32;\r\n    var tubularSegments = options.tubularSegments || 32;\r\n    var p = options.p || 2;\r\n    var q = options.q || 3;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Helper\r\n    var getPos = (angle: number) => {\r\n\r\n        var cu = Math.cos(angle);\r\n        var su = Math.sin(angle);\r\n        var quOverP = q / p * angle;\r\n        var cs = Math.cos(quOverP);\r\n\r\n        var tx = radius * (2 + cs) * 0.5 * cu;\r\n        var ty = radius * (2 + cs) * su * 0.5;\r\n        var tz = radius * Math.sin(quOverP) * 0.5;\r\n\r\n        return new Vector3(tx, ty, tz);\r\n    };\r\n\r\n    // Vertices\r\n    var i: number;\r\n    var j: number;\r\n    for (i = 0; i <= radialSegments; i++) {\r\n        var modI = i % radialSegments;\r\n        var u = modI / radialSegments * 2 * p * Math.PI;\r\n        var p1 = getPos(u);\r\n        var p2 = getPos(u + 0.01);\r\n        var tang = p2.subtract(p1);\r\n        var n = p2.add(p1);\r\n\r\n        var bitan = Vector3.Cross(tang, n);\r\n        n = Vector3.Cross(bitan, tang);\r\n\r\n        bitan.normalize();\r\n        n.normalize();\r\n\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            var modJ = j % tubularSegments;\r\n            var v = modJ / tubularSegments * 2 * Math.PI;\r\n            var cx = -tube * Math.cos(v);\r\n            var cy = tube * Math.sin(v);\r\n\r\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\r\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\r\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\r\n\r\n            uvs.push(i / radialSegments);\r\n            uvs.push(j / tubularSegments);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < radialSegments; i++) {\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            var jNext = (j + 1) % tubularSegments;\r\n            var a = i * tubularSegments + j;\r\n            var b = (i + 1) * tubularSegments + j;\r\n            var c = (i + 1) * tubularSegments + jNext;\r\n            var d = i * tubularSegments + jNext;\r\n\r\n            indices.push(d); indices.push(b); indices.push(a);\r\n            indices.push(d); indices.push(c); indices.push(b);\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateTorusKnot = (name: string, radius: number, tube: number, radialSegments: number, tubularSegments: number, p: number, q: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        radius: radius,\r\n        tube: tube,\r\n        radialSegments: radialSegments,\r\n        tubularSegments: tubularSegments,\r\n        p: p,\r\n        q: q,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return TorusKnotBuilder.CreateTorusKnot(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class TorusKnotBuilder {\r\n    /**\r\n     * Creates a torus knot mesh\r\n     * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n     * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n     * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n     * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the torus knot mesh\r\n     * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot\r\n     */\r\n    public static CreateTorusKnot(name: string, options: { radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }, scene: any): Mesh {\r\n        var torusKnot = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        torusKnot._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateTorusKnot(options);\r\n\r\n        vertexData.applyToMesh(torusKnot, options.updatable);\r\n\r\n        return torusKnot;\r\n    }\r\n}"]}