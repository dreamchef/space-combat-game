{"version":3,"file":"tubeBuilder.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Builders/tubeBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3, TmpVectors, Vector4, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { RibbonBuilder } from \"./ribbonBuilder\";\r\nimport { Path3D } from '../../Maths/math.path';\r\n\r\nMesh.CreateTube = (name: string, path: Vector3[], radius: number, tessellation: number, radiusFunction: { (i: number, distance: number): number; }, cap: number, scene: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh => {\r\n    var options = {\r\n        path: path,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        radiusFunction: radiusFunction,\r\n        arc: 1,\r\n        cap: cap,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance\r\n    };\r\n    return TubeBuilder.CreateTube(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class TubeBuilder {\r\n    /**\r\n     * Creates a tube mesh.\r\n     * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n     * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n     * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n     * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n     * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`\r\n     * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n     * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the tube mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#tube\r\n     */\r\n    public static CreateTube(name: string, options: { path: Vector3[], radius?: number, tessellation?: number, radiusFunction?: { (i: number, distance: number): number; }, cap?: number, arc?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, instance?: Mesh, invertUV?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var path = options.path;\r\n        var instance = options.instance;\r\n        var radius = 1.0;\r\n\r\n        if (options.radius !== undefined) {\r\n            radius = options.radius;\r\n        } else if (instance) {\r\n            radius = instance._creationDataStorage!.radius;\r\n        }\r\n\r\n        var tessellation = options.tessellation || 64 | 0;\r\n        var radiusFunction = options.radiusFunction || null;\r\n        var cap = options.cap || Mesh.NO_CAP;\r\n        var invertUV = options.invertUV || false;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\r\n\r\n        // tube geometry\r\n        var tubePathArray = (path: Vector3[], path3D: Path3D, circlePaths: Vector3[][], radius: number, tessellation: number,\r\n            radiusFunction: Nullable<{ (i: number, distance: number): number; }>, cap: number, arc: number) => {\r\n            var tangents = path3D.getTangents();\r\n            var normals = path3D.getNormals();\r\n            var distances = path3D.getDistances();\r\n            var pi2 = Math.PI * 2;\r\n            var step = pi2 / tessellation * arc;\r\n            var returnRadius: { (i: number, distance: number): number; } = () => radius;\r\n            var radiusFunctionFinal: { (i: number, distance: number): number; } = radiusFunction || returnRadius;\r\n\r\n            var circlePath: Vector3[];\r\n            var rad: number;\r\n            var normal: Vector3;\r\n            var rotated: Vector3;\r\n            var rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n            var index = (cap === Mesh.NO_CAP || cap === Mesh.CAP_END) ? 0 : 2;\r\n            for (var i = 0; i < path.length; i++) {\r\n                rad = radiusFunctionFinal(i, distances[i]); // current radius\r\n                circlePath = Array<Vector3>();              // current circle array\r\n                normal = normals[i];                        // current normal\r\n                for (var t = 0; t < tessellation; t++) {\r\n                    Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\r\n                    rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\r\n                    Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\r\n                    rotated.scaleInPlace(rad).addInPlace(path[i]);\r\n                    circlePath[t] = rotated;\r\n                }\r\n                circlePaths[index] = circlePath;\r\n                index++;\r\n            }\r\n            // cap\r\n            var capPath = (nbPoints: number, pathIndex: number): Array<Vector3> => {\r\n                var pointCap = Array<Vector3>();\r\n                for (var i = 0; i < nbPoints; i++) {\r\n                    pointCap.push(path[pathIndex]);\r\n                }\r\n                return pointCap;\r\n            };\r\n            switch (cap) {\r\n                case Mesh.NO_CAP:\r\n                    break;\r\n                case Mesh.CAP_START:\r\n                    circlePaths[0] = capPath(tessellation, 0);\r\n                    circlePaths[1] = circlePaths[2].slice(0);\r\n                    break;\r\n                case Mesh.CAP_END:\r\n                    circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                    circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                    break;\r\n                case Mesh.CAP_ALL:\r\n                    circlePaths[0] = capPath(tessellation, 0);\r\n                    circlePaths[1] = circlePaths[2].slice(0);\r\n                    circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                    circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            return circlePaths;\r\n        };\r\n\r\n        var path3D;\r\n        var pathArray;\r\n        if (instance) { // tube update\r\n            let storage = instance._creationDataStorage!;\r\n            var arc = options.arc || storage.arc;\r\n            path3D = storage.path3D.update(path);\r\n            pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\r\n            instance = RibbonBuilder.CreateRibbon(\"\", { pathArray: pathArray, instance: instance });\r\n            // Update mode, no need to recreate the storage.\r\n            storage.path3D = path3D;\r\n            storage.pathArray = pathArray;\r\n            storage.arc = arc;\r\n            storage.radius = radius;\r\n\r\n            return instance;\r\n        }\r\n\r\n        // tube creation\r\n        path3D = <any>new Path3D(path);\r\n        var newPathArray = new Array<Array<Vector3>>();\r\n        cap = (cap < 0 || cap > 3) ? 0 : cap;\r\n        pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\r\n        var tube = RibbonBuilder.CreateRibbon(name, { pathArray: pathArray, closePath: true, closeArray: false, updatable: updatable, sideOrientation: sideOrientation, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);\r\n        tube._creationDataStorage!.pathArray = pathArray;\r\n        tube._creationDataStorage!.path3D = path3D;\r\n        tube._creationDataStorage!.tessellation = tessellation;\r\n        tube._creationDataStorage!.cap = cap;\r\n        tube._creationDataStorage!.arc = options.arc;\r\n        tube._creationDataStorage!.radius = radius;\r\n\r\n        return tube;\r\n    }\r\n}"]}