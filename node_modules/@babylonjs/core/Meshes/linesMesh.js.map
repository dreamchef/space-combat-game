{"version":3,"file":"linesMesh.js","sourceRoot":"","sources":["../../../sourceES6/core/Meshes/linesMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport { MaterialHelper } from '../Materials/materialHelper';\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _colorShader: ShaderMaterial;\r\n\r\n    private color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        var defines: string[] = [];\r\n        var options = {\r\n            attributes: [VertexBuffer.PositionKind, \"world0\", \"world1\", \"world2\", \"world3\"],\r\n            uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this.color4 = new Color4();\r\n        }\r\n        else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        this._colorShader = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options);\r\n    }\r\n\r\n    private _addClipPlaneDefine(label: string) {\r\n        const define = \"#define \" + label;\r\n        let index = this._colorShader.options.defines.indexOf(define);\r\n\r\n        if (index !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._colorShader.options.defines.push(define);\r\n    }\r\n\r\n    private _removeClipPlaneDefine(label: string) {\r\n        const define = \"#define \" + label;\r\n        let index = this._colorShader.options.defines.indexOf(define);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._colorShader.options.defines.splice(index, 1);\r\n    }\r\n\r\n    public isReady() {\r\n        const scene = this.getScene();\r\n\r\n        // Clip planes\r\n        scene.clipPlane ? this._addClipPlaneDefine(\"CLIPPLANE\") : this._removeClipPlaneDefine(\"CLIPPLANE\");\r\n        scene.clipPlane2 ? this._addClipPlaneDefine(\"CLIPPLANE2\") : this._removeClipPlaneDefine(\"CLIPPLANE2\");\r\n        scene.clipPlane3 ? this._addClipPlaneDefine(\"CLIPPLANE3\") : this._removeClipPlaneDefine(\"CLIPPLANE3\");\r\n        scene.clipPlane4 ? this._addClipPlaneDefine(\"CLIPPLANE4\") : this._removeClipPlaneDefine(\"CLIPPLANE4\");\r\n        scene.clipPlane5 ? this._addClipPlaneDefine(\"CLIPPLANE5\") : this._removeClipPlaneDefine(\"CLIPPLANE5\");\r\n        scene.clipPlane6 ? this._addClipPlaneDefine(\"CLIPPLANE6\") : this._removeClipPlaneDefine(\"CLIPPLANE6\");\r\n\r\n        if (!this._colorShader.isReady(this)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public get material(): Material {\r\n        return this._colorShader;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public set material(value: Material) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _bind(subMesh: SubMesh, effect: Effect, fillMode: number): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        const colorEffect = this._colorShader.getEffect();\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        this._geometry._bind(colorEffect, indexToBind);\r\n\r\n        // Color\r\n        if (!this.useVertexColor) {\r\n            const { r, g, b } = this.color;\r\n            this.color4.set(r, g, b, this.alpha);\r\n            this._colorShader.setColor4(\"color\", this.color4);\r\n        }\r\n\r\n        // Clip planes\r\n        MaterialHelper.BindClipPlane(colorEffect!, this.getScene());\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        var engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        }\r\n        else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     */\r\n    public dispose(doNotRecurse?: boolean): void {\r\n        this._colorShader.dispose(false, false, true);\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        return new InstancedLinesMesh(name, this);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initilized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n"]}