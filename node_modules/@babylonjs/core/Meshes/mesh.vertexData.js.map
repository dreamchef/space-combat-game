{"version":3,"file":"mesh.vertexData.js","sourceRoot":"","sources":["../../../sourceES6/core/Meshes/mesh.vertexData.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport { Matrix, Vector3, Vector2, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { _DevTools } from '../Misc/devTools';\r\nimport { Color4, Color3 } from '../Maths/math.color';\r\nimport { Logger } from '../Misc/logger';\r\n\r\ndeclare type Geometry = import(\"../Meshes/geometry\").Geometry;\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\nimport { ICreateCapsuleOptions } from \"./Builders/capsuleBuilder\";\r\n\r\n/**\r\n * Define an interface for all classes that will get and set the data on vertices\r\n */\r\nexport interface IGetSetVerticesData {\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    isVerticesDataPresent(kind: string): boolean;\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    setVerticesData(kind: string, data: FloatArray, updatable: boolean): void;\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     */\r\n    updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;\r\n}\r\n\r\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\r\nexport class VertexData {\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    public static readonly FRONTSIDE = 0;\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    public static readonly BACKSIDE = 1;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    public static readonly DOUBLESIDE = 2;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    public static readonly DEFAULTSIDE = 0;\r\n\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public normals: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public tangents: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs2: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs3: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs4: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs5: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs6: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    public colors: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    public matricesIndices: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    public matricesWeights: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    public matricesIndicesExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    public matricesWeightsExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    public indices: Nullable<IndicesArray>;\r\n\r\n    /**\r\n     * Uses the passed data array to set the set the values for the specified kind of data\r\n     * @param data a linear array of floating numbers\r\n     * @param kind the type of data that is being set, eg positions, colors etc\r\n     */\r\n    public set(data: FloatArray, kind: string) {\r\n        if (!data.length) {\r\n            Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\r\n        }\r\n\r\n        switch (kind) {\r\n            case VertexBuffer.PositionKind:\r\n                this.positions = data;\r\n                break;\r\n            case VertexBuffer.NormalKind:\r\n                this.normals = data;\r\n                break;\r\n            case VertexBuffer.TangentKind:\r\n                this.tangents = data;\r\n                break;\r\n            case VertexBuffer.UVKind:\r\n                this.uvs = data;\r\n                break;\r\n            case VertexBuffer.UV2Kind:\r\n                this.uvs2 = data;\r\n                break;\r\n            case VertexBuffer.UV3Kind:\r\n                this.uvs3 = data;\r\n                break;\r\n            case VertexBuffer.UV4Kind:\r\n                this.uvs4 = data;\r\n                break;\r\n            case VertexBuffer.UV5Kind:\r\n                this.uvs5 = data;\r\n                break;\r\n            case VertexBuffer.UV6Kind:\r\n                this.uvs6 = data;\r\n                break;\r\n            case VertexBuffer.ColorKind:\r\n                this.colors = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesKind:\r\n                this.matricesIndices = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsKind:\r\n                this.matricesWeights = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n                this.matricesIndicesExtra = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n                this.matricesWeightsExtra = data;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Mesh.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param mesh the mesh the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns the VertexData\r\n     */\r\n    public applyToMesh(mesh: Mesh, updatable?: boolean): VertexData {\r\n        this._applyTo(mesh, updatable);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Geometry.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param geometry the geometry the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns VertexData\r\n     */\r\n    public applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData {\r\n        this._applyTo(geometry, updatable);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated mesh\r\n     * @param mesh the mesh to be updated\r\n     * @param updateExtends when true the mesh BoundingInfo will be renewed when and if position kind is updated, optional with default false\r\n     * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be  created from these positions and set to the mesh, optional with default false\r\n     * @returns VertexData\r\n     */\r\n    public updateMesh(mesh: Mesh): VertexData {\r\n        this._update(mesh);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated geometry\r\n     * @param geometry the geometry to be updated\r\n     * @param updateExtends when true BoundingInfo will be renewed when and if position kind is updated, optional with default false\r\n     * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be created from these positions and set to the mesh, optional with default false\r\n     * @returns VertexData.\r\n     */\r\n    public updateGeometry(geometry: Geometry): VertexData {\r\n        this._update(geometry);\r\n        return this;\r\n    }\r\n\r\n    private _applyTo(meshOrGeometry: IGetSetVerticesData, updatable: boolean = false): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null, updatable);\r\n        } else {\r\n            meshOrGeometry.setIndices([], null);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _update(meshOrGeometry: IGetSetVerticesData, updateExtends?: boolean, makeItUnique?: boolean): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n     * @param matrix the transforming matrix\r\n     * @returns the VertexData\r\n     */\r\n    public transform(matrix: Matrix): VertexData {\r\n        var flip = matrix.determinant() < 0;\r\n        var transformed = Vector3.Zero();\r\n        var index: number;\r\n        if (this.positions) {\r\n            var position = Vector3.Zero();\r\n\r\n            for (index = 0; index < this.positions.length; index += 3) {\r\n                Vector3.FromArrayToRef(this.positions, index, position);\r\n\r\n                Vector3.TransformCoordinatesToRef(position, matrix, transformed);\r\n                this.positions[index] = transformed.x;\r\n                this.positions[index + 1] = transformed.y;\r\n                this.positions[index + 2] = transformed.z;\r\n            }\r\n        }\r\n\r\n        if (this.normals) {\r\n            var normal = Vector3.Zero();\r\n\r\n            for (index = 0; index < this.normals.length; index += 3) {\r\n                Vector3.FromArrayToRef(this.normals, index, normal);\r\n\r\n                Vector3.TransformNormalToRef(normal, matrix, transformed);\r\n                this.normals[index] = transformed.x;\r\n                this.normals[index + 1] = transformed.y;\r\n                this.normals[index + 2] = transformed.z;\r\n            }\r\n        }\r\n\r\n        if (this.tangents) {\r\n            var tangent = Vector4.Zero();\r\n            var tangentTransformed = Vector4.Zero();\r\n\r\n            for (index = 0; index < this.tangents.length; index += 4) {\r\n                Vector4.FromArrayToRef(this.tangents, index, tangent);\r\n\r\n                Vector4.TransformNormalToRef(tangent, matrix, tangentTransformed);\r\n                this.tangents[index] = tangentTransformed.x;\r\n                this.tangents[index + 1] = tangentTransformed.y;\r\n                this.tangents[index + 2] = tangentTransformed.z;\r\n                this.tangents[index + 3] = tangentTransformed.w;\r\n            }\r\n        }\r\n\r\n        if (flip && this.indices) {\r\n            for (index = 0; index < this.indices!.length; index += 3) {\r\n                let tmp = this.indices[index + 1];\r\n                this.indices[index + 1] = this.indices[index + 2];\r\n                this.indices[index + 2] = tmp;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Merges the passed VertexData into the current one\r\n     * @param other the VertexData to be merged into the current one\r\n     * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n     * @returns the modified VertexData\r\n     */\r\n    public merge(other: VertexData, use32BitsIndices = false): VertexData {\r\n        this._validate();\r\n        other._validate();\r\n\r\n        if (!this.normals !== !other.normals ||\r\n            !this.tangents !== !other.tangents ||\r\n            !this.uvs !== !other.uvs ||\r\n            !this.uvs2 !== !other.uvs2 ||\r\n            !this.uvs3 !== !other.uvs3 ||\r\n            !this.uvs4 !== !other.uvs4 ||\r\n            !this.uvs5 !== !other.uvs5 ||\r\n            !this.uvs6 !== !other.uvs6 ||\r\n            !this.colors !== !other.colors ||\r\n            !this.matricesIndices !== !other.matricesIndices ||\r\n            !this.matricesWeights !== !other.matricesWeights ||\r\n            !this.matricesIndicesExtra !== !other.matricesIndicesExtra ||\r\n            !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\r\n            throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\r\n        }\r\n\r\n        if (other.indices) {\r\n            if (!this.indices) {\r\n                this.indices = [];\r\n            }\r\n\r\n            var offset = this.positions ? this.positions.length / 3 : 0;\r\n\r\n            var isSrcTypedArray = (<any>this.indices).BYTES_PER_ELEMENT !== undefined;\r\n\r\n            if (isSrcTypedArray) {\r\n                var len = this.indices.length + other.indices.length;\r\n                var temp = use32BitsIndices || this.indices instanceof Uint32Array ? new Uint32Array(len) : new Uint16Array(len);\r\n                temp.set(this.indices);\r\n\r\n                let decal = this.indices.length;\r\n                for (var index = 0; index < other.indices.length; index++) {\r\n                    temp[decal + index] = other.indices[index] + offset;\r\n                }\r\n\r\n                this.indices = temp;\r\n            } else {\r\n                for (var index = 0; index < other.indices.length; index++) {\r\n                    (<number[]>this.indices).push(other.indices[index] + offset);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.positions = this._mergeElement(this.positions, other.positions);\r\n        this.normals = this._mergeElement(this.normals, other.normals);\r\n        this.tangents = this._mergeElement(this.tangents, other.tangents);\r\n        this.uvs = this._mergeElement(this.uvs, other.uvs);\r\n        this.uvs2 = this._mergeElement(this.uvs2, other.uvs2);\r\n        this.uvs3 = this._mergeElement(this.uvs3, other.uvs3);\r\n        this.uvs4 = this._mergeElement(this.uvs4, other.uvs4);\r\n        this.uvs5 = this._mergeElement(this.uvs5, other.uvs5);\r\n        this.uvs6 = this._mergeElement(this.uvs6, other.uvs6);\r\n        this.colors = this._mergeElement(this.colors, other.colors);\r\n        this.matricesIndices = this._mergeElement(this.matricesIndices, other.matricesIndices);\r\n        this.matricesWeights = this._mergeElement(this.matricesWeights, other.matricesWeights);\r\n        this.matricesIndicesExtra = this._mergeElement(this.matricesIndicesExtra, other.matricesIndicesExtra);\r\n        this.matricesWeightsExtra = this._mergeElement(this.matricesWeightsExtra, other.matricesWeightsExtra);\r\n        return this;\r\n    }\r\n\r\n    private _mergeElement(source: Nullable<FloatArray>, other: Nullable<FloatArray>): Nullable<FloatArray> {\r\n        if (!source) {\r\n            return other;\r\n        }\r\n\r\n        if (!other) {\r\n            return source;\r\n        }\r\n\r\n        var len = other.length + source.length;\r\n        var isSrcTypedArray = source instanceof Float32Array;\r\n        var isOthTypedArray = other instanceof Float32Array;\r\n\r\n        // use non-loop method when the source is Float32Array\r\n        if (isSrcTypedArray) {\r\n            var ret32 = new Float32Array(len);\r\n            ret32.set(source);\r\n            ret32.set(other, source.length);\r\n            return ret32;\r\n\r\n            // source is number[], when other is also use concat\r\n        } else if (!isOthTypedArray) {\r\n            return (<number[]>source).concat(<number[]>other);\r\n\r\n            // source is a number[], but other is a Float32Array, loop required\r\n        } else {\r\n            var ret = (<number[]>source).slice(0); // copy source to a separate array\r\n            for (var i = 0, len = other.length; i < len; i++) {\r\n                ret.push(other[i]);\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    private _validate(): void {\r\n        if (!this.positions) {\r\n            throw new Error(\"Positions are required\");\r\n        }\r\n\r\n        const getElementCount = (kind: string, values: FloatArray) => {\r\n            const stride = VertexBuffer.DeduceStride(kind);\r\n            if ((values.length % stride) !== 0) {\r\n                throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\r\n            }\r\n\r\n            return values.length / stride;\r\n        };\r\n\r\n        const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\r\n\r\n        const validateElementCount = (kind: string, values: FloatArray) => {\r\n            const elementCount = getElementCount(kind, values);\r\n            if (elementCount !== positionsElementCount) {\r\n                throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\r\n            }\r\n        };\r\n\r\n        if (this.normals) { validateElementCount(VertexBuffer.NormalKind, this.normals); }\r\n        if (this.tangents) { validateElementCount(VertexBuffer.TangentKind, this.tangents); }\r\n        if (this.uvs) { validateElementCount(VertexBuffer.UVKind, this.uvs); }\r\n        if (this.uvs2) { validateElementCount(VertexBuffer.UV2Kind, this.uvs2); }\r\n        if (this.uvs3) { validateElementCount(VertexBuffer.UV3Kind, this.uvs3); }\r\n        if (this.uvs4) { validateElementCount(VertexBuffer.UV4Kind, this.uvs4); }\r\n        if (this.uvs5) { validateElementCount(VertexBuffer.UV5Kind, this.uvs5); }\r\n        if (this.uvs6) { validateElementCount(VertexBuffer.UV6Kind, this.uvs6); }\r\n        if (this.colors) { validateElementCount(VertexBuffer.ColorKind, this.colors); }\r\n        if (this.matricesIndices) { validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices); }\r\n        if (this.matricesWeights) { validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights); }\r\n        if (this.matricesIndicesExtra) { validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra); }\r\n        if (this.matricesWeightsExtra) { validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra); }\r\n    }\r\n\r\n    /**\r\n     * Serializes the VertexData\r\n     * @returns a serialized object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = this.serialize();\r\n\r\n        if (this.positions) {\r\n            serializationObject.positions = this.positions;\r\n        }\r\n\r\n        if (this.normals) {\r\n            serializationObject.normals = this.normals;\r\n        }\r\n\r\n        if (this.tangents) {\r\n            serializationObject.tangents = this.tangents;\r\n        }\r\n\r\n        if (this.uvs) {\r\n            serializationObject.uvs = this.uvs;\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            serializationObject.uvs2 = this.uvs2;\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            serializationObject.uvs3 = this.uvs3;\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            serializationObject.uvs4 = this.uvs4;\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            serializationObject.uvs5 = this.uvs5;\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            serializationObject.uvs6 = this.uvs6;\r\n        }\r\n\r\n        if (this.colors) {\r\n            serializationObject.colors = this.colors;\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            serializationObject.matricesIndices = this.matricesIndices;\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            serializationObject.matricesWeights = this.matricesWeights;\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\r\n            serializationObject.matricesIndicesExtra._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\r\n        }\r\n\r\n        serializationObject.indices = this.indices;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Extracts the vertexData from a mesh\r\n     * @param mesh the mesh from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Extracts the vertexData from the geometry\r\n     * @param geometry the geometry from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when the geometrty is shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    private static _ExtractFrom(meshOrGeometry: IGetSetVerticesData, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        var result = new VertexData();\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\r\n            result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n            result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ribbon\r\n     * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n      * * pathArray array of paths, each of which an array of successive Vector3\r\n      * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n      * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n      * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n      * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n      * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n      * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n     * @returns the VertexData of the ribbon\r\n     */\r\n    public static CreateRibbon(options: { pathArray: Vector3[][], closeArray?: boolean, closePath?: boolean, offset?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, invertUV?: boolean, uvs?: Vector2[], colors?: Color4[] }): VertexData {\r\n        throw _DevTools.WarnImport(\"ribbonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n      * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n      * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n      * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n      * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n      * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     */\r\n    public static CreateBox(options: { size?: number, width?: number, height?: number, depth?: number, faceUV?: Vector4[], faceColors?: Color4[], sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"boxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n      * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n      * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @returns the VertexData of the box\r\n     */\r\n    public static CreateTiledBox(options: { pattern?: number, width?: number, height?: number, depth?: number, tileSize?: number, tileWidth?: number, tileHeight?: number, alignHorizontal?: number, alignVertical?: number, faceUV?: Vector4[], faceColors?: Color4[], sideOrientation?: number }): VertexData {\r\n        throw _DevTools.WarnImport(\"tiledBoxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled plane\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * pattern a limited pattern arrangement depending on the number\r\n      * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n      * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n      * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the tiled plane\r\n     */\r\n    public static CreateTiledPlane(options: { pattern?: number, tileSize?: number, tileWidth?: number, tileHeight?: number, size?: number, width?: number, height?: number, alignHorizontal?: number, alignVertical?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"tiledPlaneBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * segments sets the number of horizontal strips optional, default 32\r\n      * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n      * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n      * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n      * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n      * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n      * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the ellipsoid\r\n     */\r\n    public static CreateSphere(options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"sphereBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a cylinder, cone or prism\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * height sets the height (y direction) of the cylinder, optional, default 2\r\n      * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n      * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n      * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n      * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n      * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n      * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n      * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n      * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n      * * hasRings when true makes each subdivision independantly treated as a face for faceUV and faceColors, optional, default false\r\n      * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the cylinder, cone or prism\r\n     */\r\n    public static CreateCylinder(options: { height?: number, diameterTop?: number, diameterBottom?: number, diameter?: number, tessellation?: number, subdivisions?: number, arc?: number, faceColors?: Color4[], faceUV?: Vector4[], hasRings?: boolean, enclose?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"cylinderBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a torus\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * diameter the diameter of the torus, optional default 1\r\n      * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n      * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the torus\r\n     */\r\n    public static CreateTorus(options: { diameter?: number, thickness?: number, tessellation?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"torusBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the LineSystem\r\n     * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n     *  - lines an array of lines, each line being an array of successive Vector3\r\n     *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n     * @returns the VertexData of the LineSystem\r\n     */\r\n    public static CreateLineSystem(options: { lines: Vector3[][], colors?: Nullable<Color4[][]> }): VertexData {\r\n        throw _DevTools.WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Create the VertexData for a DashedLines\r\n     * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n     *  - points an array successive Vector3\r\n     *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n     *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n     *  - dashNb the intended total number of dashes, optional, default 200\r\n     * @returns the VertexData for the DashedLines\r\n     */\r\n    public static CreateDashedLines(options: { points: Vector3[], dashSize?: number, gapSize?: number, dashNb?: number }): VertexData {\r\n        throw _DevTools.WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ground\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     *  - width the width (x direction) of the ground, optional, default 1\r\n     *  - height the height (z direction) of the ground, optional, default 1\r\n     *  - subdivisions the number of subdivisions per side, optional, default 1\r\n     * @returns the VertexData of the Ground\r\n     */\r\n    public static CreateGround(options: { width?: number, height?: number, subdivisions?: number, subdivisionsX?: number, subdivisionsY?: number }): VertexData {\r\n        throw _DevTools.WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n      * * xmin the ground minimum X coordinate, optional, default -1\r\n      * * zmin the ground minimum Z coordinate, optional, default -1\r\n      * * xmax the ground maximum X coordinate, optional, default 1\r\n      * * zmax the ground maximum Z coordinate, optional, default 1\r\n      * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n      * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n     * @returns the VertexData of the TiledGround\r\n     */\r\n    public static CreateTiledGround(options: { xmin: number, zmin: number, xmax: number, zmax: number, subdivisions?: { w: number; h: number; }, precision?: { w: number; h: number; } }): VertexData {\r\n        throw _DevTools.WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Ground designed from a heightmap\r\n     * @param options an object used to set the following parameters for the Ground, required and provided by MeshBuilder.CreateGroundFromHeightMap\r\n      * * width the width (x direction) of the ground\r\n      * * height the height (z direction) of the ground\r\n      * * subdivisions the number of subdivisions per side\r\n      * * minHeight the minimum altitude on the ground, optional, default 0\r\n      * * maxHeight the maximum altitude on the ground, optional default 1\r\n      * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n      * * buffer the array holding the image color data\r\n      * * bufferWidth the width of image\r\n      * * bufferHeight the height of image\r\n      * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * @returns the VertexData of the Ground designed from a heightmap\r\n     */\r\n    public static CreateGroundFromHeightMap(options: { width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, colorFilter: Color3, buffer: Uint8Array, bufferWidth: number, bufferHeight: number, alphaFilter: number }): VertexData {\r\n        throw _DevTools.WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Plane\r\n     * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n      * * size sets the width and height of the plane to the value of size, optional default 1\r\n      * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n      * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     */\r\n    public static CreatePlane(options: { size?: number, width?: number, height?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"planeBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Disc or regular Polygon\r\n     * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n      * * radius the radius of the disc, optional default 0.5\r\n      * * tessellation the number of polygon sides, optional, default 64\r\n      * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     */\r\n    public static CreateDisc(options: { radius?: number, tessellation?: number, arc?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"discBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n     * All parameters are provided by MeshBuilder.CreatePolygon as needed\r\n     * @param polygon a mesh built from polygonTriangulation.build()\r\n     * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n     * @returns the VertexData of the Polygon\r\n     */\r\n    public static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean): VertexData {\r\n        throw _DevTools.WarnImport(\"polygonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the IcoSphere\r\n     * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n      * * radius the radius of the IcoSphere, optional default 1\r\n      * * radiusX allows stretching in the x direction, optional, default radius\r\n      * * radiusY allows stretching in the y direction, optional, default radius\r\n      * * radiusZ allows stretching in the z direction, optional, default radius\r\n      * * flat when true creates a flat shaded mesh, optional, default true\r\n      * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the IcoSphere\r\n     */\r\n    public static CreateIcoSphere(options: { radius?: number, radiusX?: number, radiusY?: number, radiusZ?: number, flat?: boolean, subdivisions?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"icoSphereBuilder\");\r\n    }\r\n\r\n    // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n    /**\r\n     * Creates the VertexData for a Polyhedron\r\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n     * * type provided types are:\r\n     *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n     *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n     * * size the size of the IcoSphere, optional default 1\r\n     * * sizeX allows stretching in the x direction, optional, default size\r\n     * * sizeY allows stretching in the y direction, optional, default size\r\n     * * sizeZ allows stretching in the z direction, optional, default size\r\n     * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the Polyhedron\r\n     */\r\n    public static CreatePolyhedron(options: { type?: number, size?: number, sizeX?: number, sizeY?: number, sizeZ?: number, custom?: any, faceUV?: Vector4[], faceColors?: Color4[], flat?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"polyhedronBuilder\");\r\n    }\r\n\r\n    //\r\n    /**\r\n     * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n     * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n     * @returns the VertexData of the Capsule\r\n     */\r\n    public static CreateCapsule(options: ICreateCapsuleOptions = {\r\n        orientation : Vector3.Up(),\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6\r\n    }): VertexData {\r\n        throw _DevTools.WarnImport(\"capsuleBuilder\");\r\n    }\r\n\r\n    // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n    /**\r\n     * Creates the VertexData for a TorusKnot\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n      * * radius the radius of the torus knot, optional, default 2\r\n      * * tube the thickness of the tube, optional, default 0.5\r\n      * * radialSegments the number of sides on each tube segments, optional, default 32\r\n      * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n      * * p the number of windings around the z axis, optional,  default 2\r\n      * * q the number of windings around the x axis, optional,  default 3\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the Torus Knot\r\n     */\r\n    public static CreateTorusKnot(options: { radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"torusKnotBuilder\");\r\n    }\r\n\r\n    // Tools\r\n\r\n    /**\r\n     * Compute normals for given positions and indices\r\n     * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n     * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n     * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n      * * facetNormals : optional array of facet normals (vector3)\r\n      * * facetPositions : optional array of facet positions (vector3)\r\n      * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n      * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n      * * bInfo : optional bounding info, required for facetPartitioning computation\r\n      * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n      * * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation\r\n      * * useRightHandedSystem: optional boolean to for right handed system computation\r\n      * * depthSort : optional boolean to enable the facet depth sort computation\r\n      * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n      * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n     */\r\n    public static ComputeNormals(positions: any, indices: any, normals: any,\r\n        options?: {\r\n            facetNormals?: any, facetPositions?: any, facetPartitioning?: any, ratio?: number, bInfo?: any, bbSize?: Vector3, subDiv?: any,\r\n            useRightHandedSystem?: boolean, depthSort?: boolean, distanceTo?: Vector3, depthSortedFacets?: any\r\n        }): void {\r\n\r\n        // temporary scalar variables\r\n        var index = 0;                      // facet index\r\n        var p1p2x = 0.0;                    // p1p2 vector x coordinate\r\n        var p1p2y = 0.0;                    // p1p2 vector y coordinate\r\n        var p1p2z = 0.0;                    // p1p2 vector z coordinate\r\n        var p3p2x = 0.0;                    // p3p2 vector x coordinate\r\n        var p3p2y = 0.0;                    // p3p2 vector y coordinate\r\n        var p3p2z = 0.0;                    // p3p2 vector z coordinate\r\n        var faceNormalx = 0.0;              // facet normal x coordinate\r\n        var faceNormaly = 0.0;              // facet normal y coordinate\r\n        var faceNormalz = 0.0;              // facet normal z coordinate\r\n        var length = 0.0;                   // facet normal length before normalization\r\n        var v1x = 0;                        // vector1 x index in the positions array\r\n        var v1y = 0;                        // vector1 y index in the positions array\r\n        var v1z = 0;                        // vector1 z index in the positions array\r\n        var v2x = 0;                        // vector2 x index in the positions array\r\n        var v2y = 0;                        // vector2 y index in the positions array\r\n        var v2z = 0;                        // vector2 z index in the positions array\r\n        var v3x = 0;                        // vector3 x index in the positions array\r\n        var v3y = 0;                        // vector3 y index in the positions array\r\n        var v3z = 0;                        // vector3 z index in the positions array\r\n        var computeFacetNormals = false;\r\n        var computeFacetPositions = false;\r\n        var computeFacetPartitioning = false;\r\n        var computeDepthSort = false;\r\n        var faceNormalSign = 1;\r\n        let ratio = 0;\r\n        var distanceTo: Nullable<Vector3> = null;\r\n        if (options) {\r\n            computeFacetNormals = (options.facetNormals) ? true : false;\r\n            computeFacetPositions = (options.facetPositions) ? true : false;\r\n            computeFacetPartitioning = (options.facetPartitioning) ? true : false;\r\n            faceNormalSign = (options.useRightHandedSystem === true) ? -1 : 1;\r\n            ratio = options.ratio || 0;\r\n            computeDepthSort = (options.depthSort) ? true : false;\r\n            distanceTo = <Vector3>(options.distanceTo);\r\n            if (computeDepthSort) {\r\n                if (distanceTo === undefined) {\r\n                    distanceTo = Vector3.Zero();\r\n                }\r\n                var depthSortedFacets = options.depthSortedFacets;\r\n            }\r\n        }\r\n\r\n        // facetPartitioning reinit if needed\r\n        let xSubRatio = 0;\r\n        let ySubRatio = 0;\r\n        let zSubRatio = 0;\r\n        let subSq = 0;\r\n        if (computeFacetPartitioning && options && options.bbSize) {\r\n            var ox = 0;                 // X partitioning index for facet position\r\n            var oy = 0;                 // Y partinioning index for facet position\r\n            var oz = 0;                 // Z partinioning index for facet position\r\n            var b1x = 0;                // X partitioning index for facet v1 vertex\r\n            var b1y = 0;                // Y partitioning index for facet v1 vertex\r\n            var b1z = 0;                // z partitioning index for facet v1 vertex\r\n            var b2x = 0;                // X partitioning index for facet v2 vertex\r\n            var b2y = 0;                // Y partitioning index for facet v2 vertex\r\n            var b2z = 0;                // Z partitioning index for facet v2 vertex\r\n            var b3x = 0;                // X partitioning index for facet v3 vertex\r\n            var b3y = 0;                // Y partitioning index for facet v3 vertex\r\n            var b3z = 0;                // Z partitioning index for facet v3 vertex\r\n            var block_idx_o = 0;        // facet barycenter block index\r\n            var block_idx_v1 = 0;       // v1 vertex block index\r\n            var block_idx_v2 = 0;       // v2 vertex block index\r\n            var block_idx_v3 = 0;       // v3 vertex block index\r\n\r\n            var bbSizeMax = (options.bbSize.x > options.bbSize.y) ? options.bbSize.x : options.bbSize.y;\r\n            bbSizeMax = (bbSizeMax > options.bbSize.z) ? bbSizeMax : options.bbSize.z;\r\n            xSubRatio = options.subDiv.X * ratio / options.bbSize.x;\r\n            ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;\r\n            zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;\r\n            subSq = options.subDiv.max * options.subDiv.max;\r\n            options.facetPartitioning.length = 0;\r\n        }\r\n\r\n        // reset the normals\r\n        for (index = 0; index < positions.length; index++) {\r\n            normals[index] = 0.0;\r\n        }\r\n\r\n        // Loop : 1 indice triplet = 1 facet\r\n        var nbFaces = (indices.length / 3) | 0;\r\n        for (index = 0; index < nbFaces; index++) {\r\n\r\n            // get the indexes of the coordinates of each vertex of the facet\r\n            v1x = indices[index * 3] * 3;\r\n            v1y = v1x + 1;\r\n            v1z = v1x + 2;\r\n            v2x = indices[index * 3 + 1] * 3;\r\n            v2y = v2x + 1;\r\n            v2z = v2x + 2;\r\n            v3x = indices[index * 3 + 2] * 3;\r\n            v3y = v3x + 1;\r\n            v3z = v3x + 2;\r\n\r\n            p1p2x = positions[v1x] - positions[v2x];          // compute two vectors per facet : p1p2 and p3p2\r\n            p1p2y = positions[v1y] - positions[v2y];\r\n            p1p2z = positions[v1z] - positions[v2z];\r\n\r\n            p3p2x = positions[v3x] - positions[v2x];\r\n            p3p2y = positions[v3y] - positions[v2y];\r\n            p3p2z = positions[v3z] - positions[v2z];\r\n\r\n            // compute the face normal with the cross product\r\n            faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\r\n            faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\r\n            faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\r\n            // normalize this normal and store it in the array facetData\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = (length === 0) ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            if (computeFacetNormals && options) {\r\n                options.facetNormals[index].x = faceNormalx;\r\n                options.facetNormals[index].y = faceNormaly;\r\n                options.facetNormals[index].z = faceNormalz;\r\n            }\r\n\r\n            if (computeFacetPositions && options) {\r\n                // compute and the facet barycenter coordinates in the array facetPositions\r\n                options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\r\n                options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\r\n                options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\r\n            }\r\n\r\n            if (computeFacetPartitioning && options) {\r\n                // store the facet indexes in arrays in the main facetPartitioning array :\r\n                // compute each facet vertex (+ facet barycenter) index in the partiniong array\r\n                ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n\r\n                block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\r\n                block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\r\n                block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\r\n                block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\r\n\r\n                options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\r\n                options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\r\n                options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\r\n                options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\r\n\r\n                // push each facet index in each block containing the vertex\r\n                options.facetPartitioning[block_idx_v1].push(index);\r\n                if (block_idx_v2 != block_idx_v1) {\r\n                    options.facetPartitioning[block_idx_v2].push(index);\r\n                }\r\n                if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\r\n                    options.facetPartitioning[block_idx_v3].push(index);\r\n                }\r\n                if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\r\n                    options.facetPartitioning[block_idx_o].push(index);\r\n                }\r\n            }\r\n\r\n            if (computeDepthSort && options && options.facetPositions) {\r\n                var dsf = depthSortedFacets[index];\r\n                dsf.ind = index * 3;\r\n                dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo!);\r\n            }\r\n\r\n            // compute the normals anyway\r\n            normals[v1x] += faceNormalx;                         // accumulate all the normals per face\r\n            normals[v1y] += faceNormaly;\r\n            normals[v1z] += faceNormalz;\r\n            normals[v2x] += faceNormalx;\r\n            normals[v2y] += faceNormaly;\r\n            normals[v2z] += faceNormalz;\r\n            normals[v3x] += faceNormalx;\r\n            normals[v3y] += faceNormaly;\r\n            normals[v3z] += faceNormalz;\r\n        }\r\n        // last normalization of each normal\r\n        for (index = 0; index < normals.length / 3; index++) {\r\n            faceNormalx = normals[index * 3];\r\n            faceNormaly = normals[index * 3 + 1];\r\n            faceNormalz = normals[index * 3 + 2];\r\n\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = (length === 0) ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            normals[index * 3] = faceNormalx;\r\n            normals[index * 3 + 1] = faceNormaly;\r\n            normals[index * 3 + 2] = faceNormalz;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _ComputeSides(sideOrientation: number, positions: FloatArray, indices: FloatArray, normals: FloatArray, uvs: FloatArray, frontUVs?: Vector4, backUVs?: Vector4) {\r\n        var li: number = indices.length;\r\n        var ln: number = normals.length;\r\n        var i: number;\r\n        var n: number;\r\n        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n        switch (sideOrientation) {\r\n\r\n            case VertexData.FRONTSIDE:\r\n                // nothing changed\r\n                break;\r\n\r\n            case VertexData.BACKSIDE:\r\n                var tmp: number;\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    tmp = indices[i];\r\n                    indices[i] = indices[i + 2];\r\n                    indices[i + 2] = tmp;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[n] = -normals[n];\r\n                }\r\n                break;\r\n\r\n            case VertexData.DOUBLESIDE:\r\n                // positions\r\n                var lp: number = positions.length;\r\n                var l: number = lp / 3;\r\n                for (var p = 0; p < lp; p++) {\r\n                    positions[lp + p] = positions[p];\r\n                }\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    indices[i + li] = indices[i + 2] + l;\r\n                    indices[i + 1 + li] = indices[i + 1] + l;\r\n                    indices[i + 2 + li] = indices[i] + l;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[ln + n] = -normals[n];\r\n                }\r\n\r\n                // uvs\r\n                var lu: number = uvs.length;\r\n                var u: number = 0;\r\n                for (u = 0; u < lu; u++) {\r\n                    uvs[u + lu] = uvs[u];\r\n                }\r\n                frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                u = 0;\r\n                for (i = 0; i < lu / 2; i++) {\r\n                    uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\r\n                    uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\r\n                    uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\r\n                    uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\r\n                    u += 2;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies VertexData created from the imported parameters to the geometry\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @param geometry the geometry to apply the VertexData to\r\n     */\r\n    public static ImportVertexData(parsedVertexData: any, geometry: Geometry) {\r\n        var vertexData = new VertexData();\r\n\r\n        // positions\r\n        var positions = parsedVertexData.positions;\r\n        if (positions) {\r\n            vertexData.set(positions, VertexBuffer.PositionKind);\r\n        }\r\n\r\n        // normals\r\n        var normals = parsedVertexData.normals;\r\n        if (normals) {\r\n            vertexData.set(normals, VertexBuffer.NormalKind);\r\n        }\r\n\r\n        // tangents\r\n        var tangents = parsedVertexData.tangents;\r\n        if (tangents) {\r\n            vertexData.set(tangents, VertexBuffer.TangentKind);\r\n        }\r\n\r\n        // uvs\r\n        var uvs = parsedVertexData.uvs;\r\n        if (uvs) {\r\n            vertexData.set(uvs, VertexBuffer.UVKind);\r\n        }\r\n\r\n        // uv2s\r\n        var uv2s = parsedVertexData.uv2s;\r\n        if (uv2s) {\r\n            vertexData.set(uv2s, VertexBuffer.UV2Kind);\r\n        }\r\n\r\n        // uv3s\r\n        var uv3s = parsedVertexData.uv3s;\r\n        if (uv3s) {\r\n            vertexData.set(uv3s, VertexBuffer.UV3Kind);\r\n        }\r\n\r\n        // uv4s\r\n        var uv4s = parsedVertexData.uv4s;\r\n        if (uv4s) {\r\n            vertexData.set(uv4s, VertexBuffer.UV4Kind);\r\n        }\r\n\r\n        // uv5s\r\n        var uv5s = parsedVertexData.uv5s;\r\n        if (uv5s) {\r\n            vertexData.set(uv5s, VertexBuffer.UV5Kind);\r\n        }\r\n\r\n        // uv6s\r\n        var uv6s = parsedVertexData.uv6s;\r\n        if (uv6s) {\r\n            vertexData.set(uv6s, VertexBuffer.UV6Kind);\r\n        }\r\n\r\n        // colors\r\n        var colors = parsedVertexData.colors;\r\n        if (colors) {\r\n            vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\r\n        }\r\n\r\n        // matricesIndices\r\n        var matricesIndices = parsedVertexData.matricesIndices;\r\n        if (matricesIndices) {\r\n            vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\r\n        }\r\n\r\n        // matricesWeights\r\n        var matricesWeights = parsedVertexData.matricesWeights;\r\n        if (matricesWeights) {\r\n            vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\r\n        }\r\n\r\n        // indices\r\n        var indices = parsedVertexData.indices;\r\n        if (indices) {\r\n            vertexData.indices = indices;\r\n        }\r\n\r\n        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\r\n    }\r\n}\r\n"]}