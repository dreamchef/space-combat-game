{"version":3,"file":"subMesh.js","sourceRoot":"","sources":["../../../sourceES6/core/Meshes/subMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, IndicesArray, DeepImmutable, FloatArray } from \"../types\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"./buffer\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport { ICullable, BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport { DataBuffer } from './dataBuffer';\r\nimport { extractMinAndMaxIndexed } from '../Maths/math.functions';\r\nimport { Plane } from '../Maths/math.plane';\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\ndeclare type Material = import(\"../Materials/material\").Material;\r\ndeclare type MaterialDefines = import(\"../Materials/materialDefines\").MaterialDefines;\r\ndeclare type MultiMaterial = import(\"../Materials/multiMaterial\").MultiMaterial;\r\ndeclare type AbstractMesh = import(\"./abstractMesh\").AbstractMesh;\r\ndeclare type Mesh = import(\"./mesh\").Mesh;\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\ndeclare type TrianglePickingPredicate = import(\"../Culling/ray\").TrianglePickingPredicate;\r\n\r\n/**\r\n * Defines a subdivision inside a mesh\r\n */\r\nexport class SubMesh implements ICullable {\r\n    /** @hidden */\r\n    public _materialDefines: Nullable<MaterialDefines> = null;\r\n    /** @hidden */\r\n    public _materialEffect: Nullable<Effect> = null;\r\n    /** @hidden */\r\n    public _effectOverride: Nullable<Effect> = null;\r\n\r\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public get materialDefines(): Nullable<MaterialDefines> {\r\n        return this._materialDefines;\r\n    }\r\n\r\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public set materialDefines(defines: Nullable<MaterialDefines>) {\r\n        this._materialDefines = defines;\r\n    }\r\n\r\n    /**\r\n     * Gets associated effect\r\n     */\r\n    public get effect(): Nullable<Effect> {\r\n        return this._effectOverride ?? this._materialEffect;\r\n    }\r\n\r\n    /**\r\n     * Sets associated effect (effect used to render this submesh)\r\n     * @param effect defines the effect to associate with\r\n     * @param defines defines the set of defines used to compile this effect\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines: Nullable<MaterialDefines> = null) {\r\n        if (this._materialEffect === effect) {\r\n            if (!effect) {\r\n                this._materialDefines = null;\r\n            }\r\n            return;\r\n        }\r\n        this._materialDefines = defines;\r\n        this._materialEffect = effect;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _linesIndexCount: number = 0;\r\n    private _mesh: AbstractMesh;\r\n    private _renderingMesh: Mesh;\r\n    private _boundingInfo: BoundingInfo;\r\n    private _linesIndexBuffer: Nullable<DataBuffer> = null;\r\n    /** @hidden */\r\n    public _lastColliderWorldVertices: Nullable<Vector3[]> = null;\r\n    /** @hidden */\r\n    public _trianglePlanes: Plane[];\r\n    /** @hidden */\r\n    public _lastColliderTransformMatrix: Nullable<Matrix> = null;\r\n\r\n    /** @hidden */\r\n    public _renderId = 0;\r\n    /** @hidden */\r\n    public _alphaIndex: number = 0;\r\n    /** @hidden */\r\n    public _distanceToCamera: number = 0;\r\n    /** @hidden */\r\n    public _id: number;\r\n\r\n    private _currentMaterial: Nullable<Material> = null;\r\n\r\n    /**\r\n     * Add a new submesh to a mesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns the new submesh\r\n     */\r\n    public static AddToMesh(materialIndex: number, verticesStart: number, verticesCount: number, indexStart: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh, createBoundingBox: boolean = true): SubMesh {\r\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n\r\n    /**\r\n     * Creates a new submesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n     */\r\n    constructor(\r\n        /** the material index to use */\r\n        public materialIndex: number,\r\n        /** vertex index start */\r\n        public verticesStart: number,\r\n        /** vertices count */\r\n        public verticesCount: number,\r\n        /** index start */\r\n        public indexStart: number,\r\n        /** indices count */\r\n        public indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh, createBoundingBox: boolean = true, addToMesh = true) {\r\n        this._mesh = mesh;\r\n        this._renderingMesh = renderingMesh || <Mesh>mesh;\r\n        if (addToMesh) {\r\n            mesh.subMeshes.push(this);\r\n        }\r\n\r\n        this._trianglePlanes = [];\r\n\r\n        this._id = mesh.subMeshes.length - 1;\r\n\r\n        if (createBoundingBox) {\r\n            this.refreshBoundingInfo();\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\r\n    public get IsGlobal(): boolean {\r\n        return (this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices());\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh BoudingInfo object\r\n     * @returns current bounding info (or mesh's one if the submesh is global)\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this.IsGlobal) {\r\n            return this._mesh.getBoundingInfo();\r\n        }\r\n\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Sets the submesh BoundingInfo\r\n     * @param boundingInfo defines the new bounding info to use\r\n     * @returns the SubMesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): SubMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh of the current submesh\r\n     * @return the parent mesh\r\n     */\r\n    public getMesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the rendering mesh of the submesh\r\n     * @returns the rendering mesh (could be different from parent mesh)\r\n     */\r\n    public getRenderingMesh(): Mesh {\r\n        return this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the replacement mesh of the submesh\r\n     * @returns the replacement mesh (could be different from parent mesh)\r\n     */\r\n    public getReplacementMesh(): Nullable<AbstractMesh> {\r\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the effective mesh of the submesh\r\n     * @returns the effective mesh (could be different from parent mesh)\r\n     */\r\n    public getEffectiveMesh(): AbstractMesh {\r\n        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n\r\n        return replacementMesh ? replacementMesh : this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh material\r\n     * @returns null or the current material\r\n     */\r\n    public getMaterial(): Nullable<Material> {\r\n        var rootMaterial = this._renderingMesh.material;\r\n\r\n        if (rootMaterial === null || rootMaterial === undefined) {\r\n            return this._mesh.getScene().defaultMaterial;\r\n        } else if (this._IsMultiMaterial(rootMaterial)) {\r\n            var effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\r\n\r\n            if (this._currentMaterial !== effectiveMaterial) {\r\n                this._currentMaterial = effectiveMaterial;\r\n                this._materialDefines = null;\r\n            }\r\n\r\n            return effectiveMaterial;\r\n        }\r\n\r\n        return rootMaterial;\r\n    }\r\n\r\n    private _IsMultiMaterial(material: Material): material is MultiMaterial {\r\n        return (material as MultiMaterial).getSubMaterial !== undefined;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Sets a new updated BoundingInfo object to the submesh\r\n     * @param data defines an optional position array to use to determine the bounding info\r\n     * @returns the SubMesh\r\n     */\r\n    public refreshBoundingInfo(data: Nullable<FloatArray> = null): SubMesh {\r\n        this._lastColliderWorldVertices = null;\r\n\r\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (!data) {\r\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        }\r\n\r\n        if (!data) {\r\n            this._boundingInfo = this._mesh.getBoundingInfo();\r\n            return this;\r\n        }\r\n\r\n        var indices = <IndicesArray>this._renderingMesh.getIndices();\r\n        var extend: { minimum: Vector3, maximum: Vector3 };\r\n\r\n        //is this the only submesh?\r\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\r\n            let boundingInfo = this._renderingMesh.getBoundingInfo();\r\n\r\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\r\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\r\n        } else {\r\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\r\n        }\r\n\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        }\r\n        else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        return boundingInfo._checkCollision(collider);\r\n    }\r\n\r\n    /**\r\n     * Updates the submesh BoundingInfo\r\n     * @param world defines the world matrix to use to update the bounding info\r\n     * @returns the submesh\r\n     */\r\n    public updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            this.refreshBoundingInfo();\r\n            boundingInfo = this.getBoundingInfo();\r\n        }\r\n        if (boundingInfo) {\r\n            (<BoundingInfo>boundingInfo).update(world);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is intersecting with the frustum\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is inside the frustum\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh\r\n     * @param enableAlphaMode defines if alpha needs to be used\r\n     * @returns the submesh\r\n     */\r\n    public render(enableAlphaMode: boolean): SubMesh {\r\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _getLinesIndexBuffer(indices: IndicesArray, engine: Engine): DataBuffer {\r\n        if (!this._linesIndexBuffer) {\r\n            var linesIndices = [];\r\n\r\n            for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                linesIndices.push(indices[index], indices[index + 1],\r\n                    indices[index + 1], indices[index + 2],\r\n                    indices[index + 2], indices[index]);\r\n            }\r\n\r\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\r\n            this._linesIndexCount = linesIndices.length;\r\n        }\r\n        return this._linesIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submesh intersects with a ray\r\n     * @param ray defines the ray to test\r\n     * @returns true is the passed ray intersects the submesh bounding box\r\n     */\r\n    public canIntersects(ray: Ray): boolean {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return ray.intersectsBox(boundingInfo.boundingBox);\r\n    }\r\n\r\n    /**\r\n     * Intersects current submesh with a ray\r\n     * @param ray defines the ray to test\r\n     * @param positions defines mesh's positions array\r\n     * @param indices defines mesh's indices array\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns intersection info or null if no intersection\r\n     */\r\n    public intersects(ray: Ray, positions: Vector3[], indices: IndicesArray,\r\n        fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        const material = this.getMaterial();\r\n        if (!material) {\r\n            return null;\r\n        }\r\n        let step = 3;\r\n        let checkStopper = false;\r\n\r\n        switch (material.fillMode) {\r\n            case 3:\r\n            case 4:\r\n            case 5:\r\n            case 6:\r\n            case 8:\r\n                return null;\r\n            case 7:\r\n                step = 1;\r\n                checkStopper = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // LineMesh first as it's also a Mesh...\r\n        if (this._mesh.getClassName() === \"InstancedLinesMesh\" || this._mesh.getClassName() === \"LinesMesh\") {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length) {\r\n                return this._intersectUnIndexedLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n            }\r\n            return this._intersectLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n        }\r\n        else {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length && this._mesh._unIndexed) {\r\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\r\n            }\r\n\r\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    private _intersectLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        var intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\r\n            var p0 = positions[indices[index]];\r\n            var p1 = positions[indices[index + 1]];\r\n\r\n            var length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @hidden */\r\n    private _intersectUnIndexedLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        var intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\r\n            var p0 = positions[index];\r\n            var p1 = positions[index + 1];\r\n\r\n            var length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @hidden */\r\n    private _intersectTriangles(ray: Ray, positions: Vector3[], indices: IndicesArray,\r\n        step: number, checkStopper: boolean,\r\n        fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        var intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Triangles test\r\n        let faceID = -1;\r\n        for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += step) {\r\n            faceID++;\r\n            const indexA = indices[index];\r\n            const indexB = indices[index + 1];\r\n            const indexC = indices[index + 2];\r\n\r\n            if (checkStopper && indexC === 0xFFFFFFFF) {\r\n                index += 2;\r\n                continue;\r\n            }\r\n\r\n            var p0 = positions[indexA];\r\n            var p1 = positions[indexB];\r\n            var p2 = positions[indexC];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\r\n                continue;\r\n            }\r\n\r\n            var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = faceID;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @hidden */\r\n    private _intersectUnIndexedTriangles(ray: Ray, positions: Vector3[], indices: IndicesArray,\r\n        fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        var intersectInfo: Nullable<IntersectionInfo> = null;\r\n        // Triangles test\r\n        for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n            var p0 = positions[index];\r\n            var p1 = positions[index + 1];\r\n            var p2 = positions[index + 2];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\r\n                continue;\r\n            }\r\n\r\n            var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = index / 3;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._linesIndexBuffer = null;\r\n        }\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Creates a new submesh from the passed mesh\r\n     * @param newMesh defines the new hosting mesh\r\n     * @param newRenderingMesh defines an optional rendering mesh\r\n     * @returns the new submesh\r\n     */\r\n    public clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh {\r\n        var result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\r\n\r\n        if (!this.IsGlobal) {\r\n            let boundingInfo = this.getBoundingInfo();\r\n\r\n            if (!boundingInfo) {\r\n                return result;\r\n            }\r\n\r\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Dispose\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        // Remove from mesh\r\n        var index = this._mesh.subMeshes.indexOf(this);\r\n        this._mesh.subMeshes.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"SubMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubMesh\";\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new submesh from indices data\r\n     * @param materialIndex the index of the main mesh material\r\n     * @param startIndex the index where to start the copy in the mesh indices array\r\n     * @param indexCount the number of indices to copy then from the startIndex\r\n     * @param mesh the main mesh to create the submesh from\r\n     * @param renderingMesh the optional rendering mesh\r\n     * @returns a new submesh\r\n     */\r\n    public static CreateFromIndices(materialIndex: number, startIndex: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh): SubMesh {\r\n        var minVertexIndex = Number.MAX_VALUE;\r\n        var maxVertexIndex = -Number.MAX_VALUE;\r\n\r\n        const whatWillRender = (renderingMesh || mesh);\r\n        var indices = whatWillRender!.getIndices()!;\r\n\r\n        for (var index = startIndex; index < startIndex + indexCount; index++) {\r\n            var vertexIndex = indices[index];\r\n\r\n            if (vertexIndex < minVertexIndex) {\r\n                minVertexIndex = vertexIndex;\r\n            }\r\n            if (vertexIndex > maxVertexIndex) {\r\n                maxVertexIndex = vertexIndex;\r\n            }\r\n        }\r\n\r\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh);\r\n    }\r\n}\r\n"]}