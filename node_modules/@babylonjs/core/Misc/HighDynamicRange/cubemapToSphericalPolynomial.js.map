{"version":3,"file":"cubemapToSphericalPolynomial.js","sourceRoot":"","sources":["../../../../sourceES6/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Nullable } from \"../../types\";\r\n\r\nimport { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from '../../Maths/math.constants';\r\nimport { Color3 } from '../../Maths/math.color';\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n\r\n    private static FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0))// -Z bottom\r\n    ];\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @return The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture) {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        var size = texture.getSize().width;\r\n        var right = texture.readPixels(0);\r\n        var left = texture.readPixels(1);\r\n\r\n        var up: Nullable<ArrayBufferView>;\r\n        var down: Nullable<ArrayBufferView>;\r\n        if (texture.isRenderTarget) {\r\n            up = texture.readPixels(3);\r\n            down = texture.readPixels(2);\r\n        }\r\n        else {\r\n            up = texture.readPixels(2);\r\n            down = texture.readPixels(3);\r\n        }\r\n\r\n        var front = texture.readPixels(4);\r\n        var back = texture.readPixels(5);\r\n\r\n        var gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        var format = 5;\r\n        var type = 0;\r\n        if (texture.textureType == 1 || texture.textureType == 2) {\r\n            type = 1;\r\n        }\r\n\r\n        var cubeInfo: CubeMapInfo = {\r\n            size,\r\n            right,\r\n            left,\r\n            up,\r\n            down,\r\n            front,\r\n            back,\r\n            format,\r\n            type,\r\n            gammaSpace,\r\n        };\r\n\r\n        return this.ConvertCubeMapToSphericalPolynomial(cubeInfo);\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @return The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        var sphericalHarmonics = new SphericalHarmonics();\r\n        var totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        var du = 2.0 / cubeInfo.size;\r\n        var dv = du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        var minUV = du * 0.5 - 1.0;\r\n\r\n        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            var fileFace = this.FileFaces[faceIndex];\r\n            var dataArray = (<any>cubeInfo)[fileFace.name];\r\n            var v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === 5 ? 4 : 3;\r\n            for (var y = 0; y < cubeInfo.size; y++) {\r\n                var u = minUV;\r\n\r\n                for (var x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    var worldDirection =\r\n                        fileFace.worldAxisForFileX.scale(u).add(\r\n                            fileFace.worldAxisForFileY.scale(v)).add(\r\n                                fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    var deltaSolidAngle = Math.pow(1.0 + u * u + v * v, -3.0 / 2.0);\r\n\r\n                    var r = dataArray[(y * cubeInfo.size * stride) + (x * stride) + 0];\r\n                    var g = dataArray[(y * cubeInfo.size * stride) + (x * stride) + 1];\r\n                    var b = dataArray[(y * cubeInfo.size * stride) + (x * stride) + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) { r = 0; }\r\n                    if (isNaN(g)) { g = 0; }\r\n                    if (isNaN(b)) { b = 0; }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === 0) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = 4096;\r\n                    r = Scalar.Clamp(r, 0, max);\r\n                    g = Scalar.Clamp(g, 0, max);\r\n                    b = Scalar.Clamp(b, 0, max);\r\n\r\n                    var color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        var sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        var facesProcessed = 6.0;\r\n        var expectedSolidAngle = sphereSolidAngle * facesProcessed / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        var correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n"]}