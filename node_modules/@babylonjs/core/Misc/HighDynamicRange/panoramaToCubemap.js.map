{"version":3,"file":"panoramaToCubemap.js","sourceRoot":"","sources":["../../../../sourceES6/core/Misc/HighDynamicRange/panoramaToCubemap.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\n\r\n\r\n/**\r\n * CubeMap information grouping all the data for each faces as well as the cubemap size.\r\n */\r\nexport interface CubeMapInfo {\r\n    /**\r\n     * The pixel array for the front face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    front: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the back face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    back: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the left face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    left: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the right face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    right: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the up face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    up: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the down face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    down: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The size of the cubemap stored.\r\n     *\r\n     * Each faces will be size * size pixels.\r\n     */\r\n    size: number;\r\n\r\n    /**\r\n     * The format of the texture.\r\n     *\r\n     * RGBA, RGB.\r\n     */\r\n    format: number;\r\n\r\n    /**\r\n     * The type of the texture data.\r\n     *\r\n     * UNSIGNED_INT, FLOAT.\r\n     */\r\n    type: number;\r\n\r\n    /**\r\n     * Specifies whether the texture is in gamma space.\r\n     */\r\n    gammaSpace: boolean;\r\n}\r\n\r\n/**\r\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\r\n */\r\nexport class PanoramaToCubeMapTools {\r\n\r\n    private static FACE_LEFT = [\r\n        new Vector3(-1.0, -1.0, -1.0),\r\n        new Vector3(1.0, -1.0, -1.0),\r\n        new Vector3(-1.0, 1.0, -1.0),\r\n        new Vector3(1.0, 1.0, -1.0)\r\n    ];\r\n    private static FACE_RIGHT = [\r\n        new Vector3(1.0, -1.0, 1.0),\r\n        new Vector3(-1.0, -1.0, 1.0),\r\n        new Vector3(1.0, 1.0, 1.0),\r\n        new Vector3(-1.0, 1.0, 1.0)\r\n    ];\r\n    private static FACE_FRONT = [\r\n        new Vector3(1.0, -1.0, -1.0),\r\n        new Vector3(1.0, -1.0, 1.0),\r\n        new Vector3(1.0, 1.0, -1.0),\r\n        new Vector3(1.0, 1.0, 1.0)\r\n    ];\r\n    private static FACE_BACK = [\r\n        new Vector3(-1.0, -1.0, 1.0),\r\n        new Vector3(-1.0, -1.0, -1.0),\r\n        new Vector3(-1.0, 1.0, 1.0),\r\n        new Vector3(-1.0, 1.0, -1.0)\r\n    ];\r\n    private static FACE_DOWN = [\r\n        new Vector3(1.0, 1.0, -1.0),\r\n        new Vector3(1.0, 1.0, 1.0),\r\n        new Vector3(-1.0, 1.0, -1.0),\r\n        new Vector3(-1.0, 1.0, 1.0),\r\n    ];\r\n    private static FACE_UP = [\r\n        new Vector3(-1.0, -1.0, -1.0),\r\n        new Vector3(-1.0, -1.0, 1.0),\r\n        new Vector3(1.0, -1.0, -1.0),\r\n        new Vector3(1.0, -1.0, 1.0),\r\n    ];\r\n\r\n    /**\r\n     * Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).\r\n     *\r\n     * @param float32Array The source data.\r\n     * @param inputWidth The width of the input panorama.\r\n     * @param inputHeight The height of the input panorama.\r\n     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\r\n     * @return The cubemap data\r\n     */\r\n    public static ConvertPanoramaToCubemap(float32Array: Float32Array, inputWidth: number, inputHeight: number, size: number): CubeMapInfo {\r\n        if (!float32Array) {\r\n            throw \"ConvertPanoramaToCubemap: input cannot be null\";\r\n        }\r\n\r\n        if (float32Array.length != inputWidth * inputHeight * 3) {\r\n            throw \"ConvertPanoramaToCubemap: input size is wrong\";\r\n        }\r\n\r\n        var textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);\r\n        var textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);\r\n        var textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);\r\n        var textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);\r\n        var textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);\r\n        var textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);\r\n\r\n        return {\r\n            front: textureFront,\r\n            back: textureBack,\r\n            left: textureLeft,\r\n            right: textureRight,\r\n            up: textureUp,\r\n            down: textureDown,\r\n            size: size,\r\n            type: 1,\r\n            format: 4,\r\n            gammaSpace: false,\r\n        };\r\n    }\r\n\r\n    private static CreateCubemapTexture(texSize: number, faceData: Vector3[], float32Array: Float32Array, inputWidth: number, inputHeight: number) {\r\n        var buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\r\n        var textureArray = new Float32Array(buffer);\r\n\r\n        var rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);\r\n        var rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);\r\n\r\n        var dy = 1 / texSize;\r\n        var fy = 0;\r\n\r\n        for (var y = 0; y < texSize; y++) {\r\n            var xv1 = faceData[0];\r\n            var xv2 = faceData[2];\r\n\r\n            for (var x = 0; x < texSize; x++) {\r\n                var v = xv2.subtract(xv1).scale(fy).add(xv1);\r\n                v.normalize();\r\n\r\n                var color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\r\n\r\n                // 3 channels per pixels\r\n                textureArray[y * texSize * 3 + (x * 3) + 0] = color.r;\r\n                textureArray[y * texSize * 3 + (x * 3) + 1] = color.g;\r\n                textureArray[y * texSize * 3 + (x * 3) + 2] = color.b;\r\n\r\n                xv1 = xv1.add(rotDX1);\r\n                xv2 = xv2.add(rotDX2);\r\n            }\r\n\r\n            fy += dy;\r\n        }\r\n\r\n        return textureArray;\r\n    }\r\n\r\n    private static CalcProjectionSpherical(vDir: Vector3, float32Array: Float32Array, inputWidth: number, inputHeight: number): any {\r\n        var theta = Math.atan2(vDir.z, vDir.x);\r\n        var phi = Math.acos(vDir.y);\r\n\r\n        while (theta < -Math.PI) { theta += 2 * Math.PI; }\r\n        while (theta > Math.PI) { theta -= 2 * Math.PI; }\r\n\r\n        var dx = theta / Math.PI;\r\n        var dy = phi / Math.PI;\r\n\r\n        // recenter.\r\n        dx = dx * 0.5 + 0.5;\r\n\r\n        var px = Math.round(dx * inputWidth);\r\n        if (px < 0) { px = 0; }\r\n        else if (px >= inputWidth) { px = inputWidth - 1; }\r\n\r\n        var py = Math.round(dy * inputHeight);\r\n        if (py < 0) { py = 0; }\r\n        else if (py >= inputHeight) { py = inputHeight - 1; }\r\n\r\n        var inputY = (inputHeight - py - 1);\r\n        var r = float32Array[inputY * inputWidth * 3 + (px * 3) + 0];\r\n        var g = float32Array[inputY * inputWidth * 3 + (px * 3) + 1];\r\n        var b = float32Array[inputY * inputWidth * 3 + (px * 3) + 2];\r\n\r\n        return {\r\n            r: r,\r\n            g: g,\r\n            b: b\r\n        };\r\n    }\r\n}\r\n"]}