{"version":3,"file":"andOrNotEvaluator.js","sourceRoot":"","sources":["../../../sourceES6/core/Misc/andOrNotEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Class used to evalaute queries containing `and` and `or` operators\r\n */\r\nexport class AndOrNotEvaluator {\r\n    /**\r\n     * Evaluate a query\r\n     * @param query defines the query to evaluate\r\n     * @param evaluateCallback defines the callback used to filter result\r\n     * @returns true if the query matches\r\n     */\r\n    public static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean {\r\n        if (!query.match(/\\([^\\(\\)]*\\)/g)) {\r\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\r\n        }\r\n        else {\r\n            query = query.replace(/\\([^\\(\\)]*\\)/g, (r) => {\r\n                // remove parenthesis\r\n                r = r.slice(1, r.length - 1);\r\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\r\n            });\r\n        }\r\n\r\n        if (query === \"true\") {\r\n            return true;\r\n        }\r\n\r\n        if (query === \"false\") {\r\n            return false;\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\r\n    }\r\n\r\n    private static _HandleParenthesisContent(parenthesisContent: string, evaluateCallback: (val: string) => boolean): string {\r\n        evaluateCallback = evaluateCallback || ((r) => {\r\n            return r === \"true\" ? true : false;\r\n        });\r\n\r\n        var result;\r\n        var or = parenthesisContent.split(\"||\");\r\n\r\n        for (var i in or) {\r\n            if (or.hasOwnProperty(i)) {\r\n                var ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\r\n                var and = ori.split(\"&&\");\r\n\r\n                if (and.length > 1) {\r\n                    for (var j = 0; j < and.length; ++j) {\r\n                        var andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\r\n                        if (andj !== \"true\" && andj !== \"false\") {\r\n                            if (andj[0] === \"!\") {\r\n                                result = !evaluateCallback(andj.substring(1));\r\n                            }\r\n                            else {\r\n                                result = evaluateCallback(andj);\r\n                            }\r\n                        }\r\n                        else {\r\n                            result = andj === \"true\" ? true : false;\r\n                        }\r\n                        if (!result) { // no need to continue since 'false && ... && ...' will always return false\r\n                            ori = \"false\";\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (result || ori === \"true\") { // no need to continue since 'true || ... || ...' will always return true\r\n                    result = true;\r\n                    break;\r\n                }\r\n\r\n                // result equals false (or undefined)\r\n\r\n                if (ori !== \"true\" && ori !== \"false\") {\r\n                    if (ori[0] === \"!\") {\r\n                        result = !evaluateCallback(ori.substring(1));\r\n                    }\r\n                    else {\r\n                        result = evaluateCallback(ori);\r\n                    }\r\n                }\r\n                else {\r\n                    result = ori === \"true\" ? true : false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // the whole parenthesis scope is replaced by 'true' or 'false'\r\n        return result ? \"true\" : \"false\";\r\n    }\r\n\r\n    private static _SimplifyNegation(booleanString: string): string {\r\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\r\n            // remove whitespaces\r\n            r = r.replace(/[\\s]/g, () => \"\");\r\n            return r.length % 2 ? \"!\" : \"\";\r\n        });\r\n\r\n        booleanString = booleanString.trim();\r\n\r\n        if (booleanString === \"!true\") {\r\n            booleanString = \"false\";\r\n        }\r\n        else if (booleanString === \"!false\") {\r\n            booleanString = \"true\";\r\n        }\r\n\r\n        return booleanString;\r\n    }\r\n}\r\n"]}