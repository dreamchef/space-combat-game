{"version":3,"file":"filesInput.js","sourceRoot":"","sources":["../../../sourceES6/core/Misc/filesInput.ts"],"names":[],"mappings":"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","sourcesContent":["import { Engine } from \"../Engines/engine\";\r\nimport { Scene } from \"../scene\";\r\nimport { ISceneLoaderProgressEvent, SceneLoader } from \"../Loading/sceneLoader\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { FilesInputStore } from \"./filesInputStore\";\r\nimport { Nullable } from '../types';\r\n\r\n/**\r\n * Class used to help managing file picking and drag'n'drop\r\n */\r\nexport class FilesInput {\r\n    /**\r\n     * List of files ready to be loaded\r\n     */\r\n    public static get FilesToLoad() {\r\n        return FilesInputStore.FilesToLoad;\r\n    }\r\n\r\n    /**\r\n     * Callback called when a file is processed\r\n     */\r\n    public onProcessFileCallback: (file: File, name: string, extension: string) => boolean = () => { return true; };\r\n\r\n    private _engine: Engine;\r\n    private _currentScene: Nullable<Scene>;\r\n    private _sceneLoadedCallback: Nullable<(sceneFile: File, scene: Scene) => void>;\r\n    private _progressCallback: Nullable<(progress: ISceneLoaderProgressEvent) => void>;\r\n    private _additionalRenderLoopLogicCallback: Nullable<() => void>;\r\n    private _textureLoadingCallback: Nullable<(remaining: number) => void>;\r\n    private _startingProcessingFilesCallback: Nullable<(files?: File[]) => void>;\r\n    private _onReloadCallback: Nullable<(sceneFile: File) => void>;\r\n    private _errorCallback: Nullable<(sceneFile: File, scene: Nullable<Scene>, message: string) => void>;\r\n    private _elementToMonitor: HTMLElement;\r\n\r\n    private _sceneFileToLoad: File;\r\n    private _filesToLoad: File[];\r\n\r\n    /**\r\n     * Creates a new FilesInput\r\n     * @param engine defines the rendering engine\r\n     * @param scene defines the hosting scene\r\n     * @param sceneLoadedCallback callback called when scene is loaded\r\n     * @param progressCallback callback called to track progress\r\n     * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\r\n     * @param textureLoadingCallback callback called when a texture is loading\r\n     * @param startingProcessingFilesCallback callback called when the system is about to process all files\r\n     * @param onReloadCallback callback called when a reload is requested\r\n     * @param errorCallback callback call if an error occurs\r\n     */\r\n    constructor(engine: Engine, scene: Nullable<Scene>,\r\n        sceneLoadedCallback: Nullable<(sceneFile: File, scene: Scene) => void>,\r\n        progressCallback: Nullable<(progress: ISceneLoaderProgressEvent) => void>,\r\n        additionalRenderLoopLogicCallback: Nullable<() => void>,\r\n        textureLoadingCallback: Nullable<(remaining: number) => void>,\r\n        startingProcessingFilesCallback: Nullable<(files?: File[]) => void>,\r\n        onReloadCallback: Nullable<(sceneFile: File) => void>,\r\n        errorCallback: Nullable<(sceneFile: File, scene: Nullable<Scene>, message: string) => void>) {\r\n        this._engine = engine;\r\n        this._currentScene = scene;\r\n\r\n        this._sceneLoadedCallback = sceneLoadedCallback;\r\n        this._progressCallback = progressCallback;\r\n        this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\r\n        this._textureLoadingCallback = textureLoadingCallback;\r\n        this._startingProcessingFilesCallback = startingProcessingFilesCallback;\r\n        this._onReloadCallback = onReloadCallback;\r\n        this._errorCallback = errorCallback;\r\n    }\r\n\r\n    private _dragEnterHandler: (e: any) => void;\r\n    private _dragOverHandler: (e: any) => void;\r\n    private _dropHandler: (e: any) => void;\r\n\r\n    /**\r\n     * Calls this function to listen to drag'n'drop events on a specific DOM element\r\n     * @param elementToMonitor defines the DOM element to track\r\n     */\r\n    public monitorElementForDragNDrop(elementToMonitor: HTMLElement): void {\r\n        if (elementToMonitor) {\r\n            this._elementToMonitor = elementToMonitor;\r\n\r\n            this._dragEnterHandler = (e) => { this.drag(e); };\r\n            this._dragOverHandler = (e) => { this.drag(e); };\r\n            this._dropHandler = (e) => { this.drop(e); };\r\n\r\n            this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\r\n            this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\r\n            this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\r\n        }\r\n    }\r\n\r\n    /** Gets the current list of files to load */\r\n    public get filesToLoad() {\r\n        return this._filesToLoad;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources\r\n     */\r\n    public dispose() {\r\n        if (!this._elementToMonitor) {\r\n            return;\r\n        }\r\n\r\n        this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\r\n        this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\r\n        this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\r\n    }\r\n\r\n    private renderFunction(): void {\r\n        if (this._additionalRenderLoopLogicCallback) {\r\n            this._additionalRenderLoopLogicCallback();\r\n        }\r\n\r\n        if (this._currentScene) {\r\n            if (this._textureLoadingCallback) {\r\n                var remaining = this._currentScene.getWaitingItemsCount();\r\n\r\n                if (remaining > 0) {\r\n                    this._textureLoadingCallback(remaining);\r\n                }\r\n            }\r\n            this._currentScene.render();\r\n        }\r\n    }\r\n\r\n    private drag(e: DragEvent): void {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    }\r\n\r\n    private drop(eventDrop: DragEvent): void {\r\n        eventDrop.stopPropagation();\r\n        eventDrop.preventDefault();\r\n\r\n        this.loadFiles(eventDrop);\r\n    }\r\n\r\n    private _traverseFolder(folder: any, files: Array<any>, remaining: { count: number }, callback: () => void) {\r\n        var reader = folder.createReader();\r\n        var relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\r\n        reader.readEntries((entries: any) => {\r\n            remaining.count += entries.length;\r\n            for (let entry of entries) {\r\n                if (entry.isFile) {\r\n                    entry.file((file: any) => {\r\n                        file.correctName = relativePath + file.name;\r\n                        files.push(file);\r\n\r\n                        if (--remaining.count === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                }\r\n                else if (entry.isDirectory) {\r\n                    this._traverseFolder(entry, files, remaining, callback);\r\n                }\r\n            }\r\n\r\n            if (--remaining.count === 0) {\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n\r\n    private _processFiles(files: Array<any>): void {\r\n        for (var i = 0; i < files.length; i++) {\r\n            var name = files[i].correctName.toLowerCase();\r\n            var extension = name.split('.').pop();\r\n\r\n            if (!this.onProcessFileCallback(files[i], name, extension)) {\r\n                continue;\r\n            }\r\n\r\n            if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\r\n                this._sceneFileToLoad = files[i];\r\n            }\r\n\r\n            FilesInput.FilesToLoad[name] = files[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load files from a drop event\r\n     * @param event defines the drop event to use as source\r\n     */\r\n    public loadFiles(event: any): void {\r\n        // Handling data transfer via drag'n'drop\r\n        if (event && event.dataTransfer && event.dataTransfer.files) {\r\n            this._filesToLoad = event.dataTransfer.files;\r\n        }\r\n\r\n        // Handling files from input files\r\n        if (event && event.target && event.target.files) {\r\n            this._filesToLoad = event.target.files;\r\n        }\r\n\r\n        if (!this._filesToLoad || this._filesToLoad.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this._startingProcessingFilesCallback) {\r\n            this._startingProcessingFilesCallback(this._filesToLoad);\r\n        }\r\n\r\n        if (this._filesToLoad && this._filesToLoad.length > 0) {\r\n            let files = new Array<File>();\r\n            let folders = [];\r\n            var items = event.dataTransfer ? event.dataTransfer.items : null;\r\n\r\n            for (var i = 0; i < this._filesToLoad.length; i++) {\r\n                let fileToLoad: any = this._filesToLoad[i];\r\n                let name = fileToLoad.name.toLowerCase();\r\n                let entry;\r\n\r\n                fileToLoad.correctName = name;\r\n\r\n                if (items) {\r\n                    let item = items[i];\r\n                    if (item.getAsEntry) {\r\n                        entry = item.getAsEntry();\r\n                    } else if (item.webkitGetAsEntry) {\r\n                        entry = item.webkitGetAsEntry();\r\n                    }\r\n                }\r\n\r\n                if (!entry) {\r\n                    files.push(fileToLoad);\r\n                } else {\r\n                    if (entry.isDirectory) {\r\n                        folders.push(entry);\r\n                    } else {\r\n                        files.push(fileToLoad);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (folders.length === 0) {\r\n                this._processFiles(files);\r\n                this._processReload();\r\n            } else {\r\n                var remaining = { count: folders.length };\r\n                for (var folder of folders) {\r\n                    this._traverseFolder(folder, files, remaining, () => {\r\n                        this._processFiles(files);\r\n\r\n                        if (remaining.count === 0) {\r\n                            this._processReload();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    private _processReload() {\r\n        if (this._onReloadCallback) {\r\n            this._onReloadCallback(this._sceneFileToLoad);\r\n        }\r\n        else {\r\n            this.reload();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reload the current scene from the loaded files\r\n     */\r\n    public reload() {\r\n        // If a scene file has been provided\r\n        if (this._sceneFileToLoad) {\r\n            if (this._currentScene) {\r\n                if (Logger.errorsCount > 0) {\r\n                    Logger.ClearLogCache();\r\n                }\r\n                this._engine.stopRenderLoop();\r\n            }\r\n\r\n            SceneLoader.ShowLoadingScreen = false;\r\n            this._engine.displayLoadingUI();\r\n            SceneLoader.LoadAsync(\"file:\", this._sceneFileToLoad, this._engine, (progress) => {\r\n                if (this._progressCallback) {\r\n                    this._progressCallback(progress);\r\n                }\r\n            }).then((scene) => {\r\n                if (this._currentScene) {\r\n                    this._currentScene.dispose();\r\n                }\r\n\r\n                this._currentScene = scene;\r\n\r\n                if (this._sceneLoadedCallback) {\r\n                    this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);\r\n                }\r\n\r\n                // Wait for textures and shaders to be ready\r\n                this._currentScene.executeWhenReady(() => {\r\n                    this._engine.hideLoadingUI();\r\n                    this._engine.runRenderLoop(() => {\r\n                        this.renderFunction();\r\n                    });\r\n                });\r\n            }).catch((error) => {\r\n                this._engine.hideLoadingUI();\r\n                if (this._errorCallback) {\r\n                    this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            Logger.Error(\"Please provide a valid .babylon file.\");\r\n        }\r\n    }\r\n}\r\n"]}