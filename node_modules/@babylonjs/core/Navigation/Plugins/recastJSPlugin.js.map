{"version":3,"file":"recastJSPlugin.js","sourceRoot":"","sources":["../../../../sourceES6/core/Navigation/Plugins/recastJSPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { INavigationEnginePlugin, ICrowd, IAgentParameters, INavMeshParameters } from \"../../Navigation/INavigationEngine\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Epsilon, Vector3 } from '../../Maths/math';\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\n\r\ndeclare var Recast: any;\r\n\r\n/**\r\n * RecastJS navigation plugin\r\n */\r\nexport class RecastJSPlugin implements INavigationEnginePlugin {\r\n    /**\r\n     * Reference to the Recast library\r\n     */\r\n    public bjsRECAST: any = {};\r\n\r\n    /**\r\n     * plugin name\r\n     */\r\n    public name: string = \"RecastJSPlugin\";\r\n\r\n    /**\r\n     * the first navmesh created. We might extend this to support multiple navmeshes\r\n     */\r\n    public navMesh: any;\r\n\r\n    private _maximumSubStepCount: number = 10;\r\n    private _timeStep: number = 1 / 60;\r\n\r\n    /**\r\n     * Initializes the recastJS plugin\r\n     * @param recastInjection can be used to inject your own recast reference\r\n     */\r\n    public constructor(recastInjection: any = Recast) {\r\n        if (typeof recastInjection === \"function\") {\r\n            recastInjection(this.bjsRECAST);\r\n        } else {\r\n            this.bjsRECAST = recastInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n        this.setTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the navigation tick update.\r\n     * Default is 1/60.\r\n     * A value of 0 will disable fixed time update\r\n     * @param newTimeStep the new timestep to apply to this world.\r\n     */\r\n    setTimeStep(newTimeStep: number = 1 / 60): void {\r\n        this._timeStep = newTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the navigation tick update.\r\n     * @returns the current time step\r\n     */\r\n    getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * If delta time in navigation tick update is greater than the time step\r\n     * a number of sub iterations are done. If more iterations are need to reach deltatime\r\n     * they will be discarded.\r\n     * A value of 0 will set to no maximum and update will use as many substeps as needed\r\n     * @param newStepCount the maximum number of iterations\r\n     */\r\n    setMaximumSubStepCount(newStepCount: number = 10): void {\r\n        this._maximumSubStepCount = newStepCount;\r\n    }\r\n\r\n    /**\r\n     * Get the maximum number of iterations per navigation tick update\r\n     * @returns the maximum number of iterations\r\n     */\r\n    getMaximumSubStepCount(): number\r\n    {\r\n        return this._maximumSubStepCount;\r\n    }\r\n\r\n    /**\r\n     * Creates a navigation mesh\r\n     * @param meshes array of all the geometry used to compute the navigatio mesh\r\n     * @param parameters bunch of parameters used to filter geometry\r\n     */\r\n    createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParameters): void {\r\n        const rc = new this.bjsRECAST.rcConfig();\r\n        rc.cs = parameters.cs;\r\n        rc.ch = parameters.ch;\r\n        rc.borderSize = 0;\r\n        rc.tileSize = 0;\r\n        rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\r\n        rc.walkableHeight = parameters.walkableHeight;\r\n        rc.walkableClimb = parameters.walkableClimb;\r\n        rc.walkableRadius = parameters.walkableRadius;\r\n        rc.maxEdgeLen = parameters.maxEdgeLen;\r\n        rc.maxSimplificationError = parameters.maxSimplificationError;\r\n        rc.minRegionArea = parameters.minRegionArea;\r\n        rc.mergeRegionArea = parameters.mergeRegionArea;\r\n        rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\r\n        rc.detailSampleDist = parameters.detailSampleDist;\r\n        rc.detailSampleMaxError = parameters.detailSampleMaxError;\r\n\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n\r\n        var index: number;\r\n        var tri: number;\r\n        var pt: number;\r\n\r\n        var indices = [];\r\n        var positions = [];\r\n        var offset = 0;\r\n        for (index = 0; index < meshes.length; index++) {\r\n            if (meshes[index]) {\r\n                var mesh = meshes[index];\r\n\r\n                const meshIndices = mesh.getIndices();\r\n                if (!meshIndices) {\r\n                    continue;\r\n                }\r\n                const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\r\n                if (!meshPositions) {\r\n                    continue;\r\n                }\r\n\r\n                const wm = mesh.computeWorldMatrix(true);\r\n\r\n                for (tri = 0; tri < meshIndices.length; tri++) {\r\n                    indices.push(meshIndices[tri] + offset);\r\n                }\r\n\r\n                var transformed = Vector3.Zero();\r\n                var position = Vector3.Zero();\r\n                for (pt = 0; pt < meshPositions.length; pt += 3) {\r\n                    Vector3.FromArrayToRef(meshPositions, pt, position);\r\n                    Vector3.TransformCoordinatesToRef(position, wm, transformed);\r\n                    positions.push(transformed.x, transformed.y, transformed.z);\r\n                }\r\n\r\n                offset += meshPositions.length / 3;\r\n            }\r\n        }\r\n\r\n        this.navMesh.build(positions, offset, indices, indices.length, rc);\r\n    }\r\n\r\n    /**\r\n     * Create a navigation mesh debug mesh\r\n     * @param scene is where the mesh will be added\r\n     * @returns debug display mesh\r\n     */\r\n    createDebugNavMesh(scene: Scene): Mesh {\r\n        var tri: number;\r\n        var pt: number;\r\n        var debugNavMesh = this.navMesh.getDebugNavMesh();\r\n        let triangleCount = debugNavMesh.getTriangleCount();\r\n\r\n        var indices = [];\r\n        var positions = [];\r\n        for (tri = 0; tri < triangleCount * 3; tri++)\r\n        {\r\n            indices.push(tri);\r\n        }\r\n        for (tri = 0; tri < triangleCount; tri++)\r\n        {\r\n            for (pt = 0; pt < 3 ; pt++)\r\n            {\r\n                let point = debugNavMesh.getTriangle(tri).getPoint(pt);\r\n                positions.push(point.x, point.y, point.z);\r\n            }\r\n        }\r\n\r\n        var mesh = new Mesh(\"NavMeshDebug\", scene);\r\n        var vertexData = new VertexData();\r\n\r\n        vertexData.indices = indices;\r\n        vertexData.positions = positions;\r\n        vertexData.applyToMesh(mesh, false);\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPoint(position: Vector3) : Vector3\r\n    {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var ret = this.navMesh.getClosestPoint(p);\r\n        var pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPointToRef(position: Vector3, result: Vector3) : void {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var ret = this.navMesh.getClosestPoint(p);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAround(position: Vector3, maxRadius: number): Vector3 {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var ret = this.navMesh.getRandomPointAround(p, maxRadius);\r\n        var pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAroundToRef(position: Vector3, maxRadius: number, result: Vector3): void {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var ret = this.navMesh.getRandomPointAround(p, maxRadius);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @returns the resulting point along the navmesh\r\n     */\r\n    moveAlong(position: Vector3, destination: Vector3): Vector3 {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var d = new this.bjsRECAST.Vec3(destination.x, destination.y, destination.z);\r\n        var ret = this.navMesh.moveAlong(p, d);\r\n        var pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @param result output the resulting point along the navmesh\r\n     */\r\n    moveAlongToRef(position: Vector3, destination: Vector3, result: Vector3): void {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var d = new this.bjsRECAST.Vec3(destination.x, destination.y, destination.z);\r\n        var ret = this.navMesh.moveAlong(p, d);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed\r\n     * @param start world position\r\n     * @param end world position\r\n     * @returns array containing world position composing the path\r\n     */\r\n    computePath(start: Vector3, end: Vector3): Vector3[]\r\n    {\r\n        var pt: number;\r\n        let startPos = new this.bjsRECAST.Vec3(start.x, start.y, start.z);\r\n        let endPos = new this.bjsRECAST.Vec3(end.x, end.y, end.z);\r\n        let navPath = this.navMesh.computePath(startPos, endPos);\r\n        let pointCount = navPath.getPointCount();\r\n        var positions = [];\r\n        for (pt = 0; pt < pointCount; pt++)\r\n        {\r\n            let p = navPath.getPoint(pt);\r\n            positions.push(new Vector3(p.x, p.y, p.z));\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Create a new Crowd so you can add agents\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene) : ICrowd\r\n    {\r\n        var crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\r\n        return crowd;\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void\r\n    {\r\n        let ext = new this.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\r\n        this.navMesh.setDefaultQueryExtent(ext);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3\r\n    {\r\n        let p = this.navMesh.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * build the navmesh from a previously saved state using getNavmeshData\r\n     * @param data the Uint8Array returned by getNavmeshData\r\n     */\r\n    buildFromNavmeshData(data: Uint8Array): void\r\n    {\r\n        var nDataBytes = data.length * data.BYTES_PER_ELEMENT;\r\n        var dataPtr = this.bjsRECAST._malloc(nDataBytes);\r\n\r\n        var dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\r\n        dataHeap.set(data);\r\n\r\n        let buf = new this.bjsRECAST.NavmeshData();\r\n        buf.dataPointer = dataHeap.byteOffset;\r\n        buf.size = data.length;\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n        this.navMesh.buildFromNavmeshData(buf);\r\n\r\n        // Free memory\r\n        this.bjsRECAST._free(dataHeap.byteOffset);\r\n    }\r\n\r\n    /**\r\n     * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\r\n     * @returns data the Uint8Array that can be saved and reused\r\n     */\r\n    getNavmeshData(): Uint8Array\r\n    {\r\n        let navmeshData = this.navMesh.getNavmeshData();\r\n        var arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\r\n        var ret = new Uint8Array(navmeshData.size);\r\n        ret.set(arrView);\r\n        this.navMesh.freeNavmeshData(navmeshData);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void\r\n    {\r\n        let p = this.navMesh.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Disposes\r\n     */\r\n    public dispose() {\r\n\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if plugin is supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsRECAST !== undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Recast detour crowd implementation\r\n */\r\nexport class RecastJSCrowd implements ICrowd {\r\n    /**\r\n     * Recast/detour plugin\r\n     */\r\n    public bjsRECASTPlugin: RecastJSPlugin;\r\n    /**\r\n     * Link to the detour crowd\r\n     */\r\n    public recastCrowd: any = {};\r\n    /**\r\n     * One transform per agent\r\n     */\r\n    public transforms: TransformNode[] = new Array<TransformNode>();\r\n    /**\r\n     * All agents created\r\n     */\r\n    public agents: number[] = new Array<number>();\r\n    /**\r\n     * Link to the scene is kept to unregister the crowd from the scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Observer for crowd updates\r\n     */\r\n    private _onBeforeAnimationsObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param plugin recastJS plugin\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    public constructor(plugin: RecastJSPlugin, maxAgents: number, maxAgentRadius: number, scene: Scene) {\r\n        this.bjsRECASTPlugin = plugin;\r\n        this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\r\n        this._scene = scene;\r\n\r\n        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n            this.update(scene.getEngine().getDeltaTime() * 0.001);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\r\n     * You can attach anything to that node. The node position is updated in the scene update tick.\r\n     * @param pos world position that will be constrained by the navigation mesh\r\n     * @param parameters agent parameters\r\n     * @param transform hooked to the agent that will be update by the scene\r\n     * @returns agent index\r\n     */\r\n    addAgent(pos: Vector3, parameters: IAgentParameters, transform: TransformNode): number\r\n    {\r\n        var agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\r\n        agentParams.radius = parameters.radius;\r\n        agentParams.height = parameters.height;\r\n        agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        agentParams.maxSpeed = parameters.maxSpeed;\r\n        agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        agentParams.separationWeight = parameters.separationWeight;\r\n        agentParams.updateFlags = 7;\r\n        agentParams.obstacleAvoidanceType = 0;\r\n        agentParams.queryFilterType = 0;\r\n        agentParams.userData = 0;\r\n\r\n        var agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\r\n        this.transforms.push(transform);\r\n        this.agents.push(agentIndex);\r\n        return agentIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentPosition(index: number): Vector3 {\r\n        var agentPos = this.recastCrowd.getAgentPosition(index);\r\n        return new Vector3(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentPositionToRef(index: number, result: Vector3): void {\r\n        var agentPos = this.recastCrowd.getAgentPosition(index);\r\n        result.set(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space velocity\r\n     */\r\n    getAgentVelocity(index: number): Vector3 {\r\n        var agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        return new Vector3(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space velocity\r\n     */\r\n    getAgentVelocityToRef(index: number, result: Vector3): void {\r\n        var agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        result.set(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentNextTargetPath(index: number): Vector3 {\r\n        var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentNextTargetPathToRef(index: number, result: Vector3): void {\r\n        var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Gets the agent state\r\n     * @param index agent index returned by addAgent\r\n     * @returns agent state\r\n     */\r\n    getAgentState(index: number): number {\r\n        return this.recastCrowd.getAgentState(index);\r\n    }\r\n\r\n    /**\r\n     * returns true if the agent in over an off mesh link connection\r\n     * @param index agent index returned by addAgent\r\n     * @returns true if over an off mesh link connection\r\n     */\r\n    overOffmeshConnection(index: number): boolean {\r\n        return this.recastCrowd.overOffmeshConnection(index);\r\n    }\r\n\r\n    /**\r\n     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentGoto(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n    }\r\n\r\n    /**\r\n     * Teleport the agent to a new position\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentTeleport(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n    }\r\n\r\n    /**\r\n     * Update agent parameters\r\n     * @param index agent index returned by addAgent\r\n     * @param parameters agent parameters\r\n     */\r\n    updateAgentParameters(index: number, parameters: IAgentParameters): void {\r\n        var agentParams = this.recastCrowd.getAgentParameters(index);\r\n\r\n        if (parameters.radius !== undefined) {\r\n            agentParams.radius = parameters.radius;\r\n        }\r\n        if (parameters.height !== undefined) {\r\n            agentParams.height = parameters.height;\r\n        }\r\n        if (parameters.maxAcceleration !== undefined) {\r\n            agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        }\r\n        if (parameters.maxSpeed !== undefined) {\r\n            agentParams.maxSpeed = parameters.maxSpeed;\r\n        }\r\n        if (parameters.collisionQueryRange !== undefined) {\r\n            agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        }\r\n        if (parameters.pathOptimizationRange !== undefined) {\r\n            agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        }\r\n        if (parameters.separationWeight !== undefined) {\r\n            agentParams.separationWeight = parameters.separationWeight;\r\n        }\r\n\r\n        this.recastCrowd.setAgentParameters(index, agentParams);\r\n    }\r\n\r\n    /**\r\n     * remove a particular agent previously created\r\n     * @param index agent index returned by addAgent\r\n     */\r\n    removeAgent(index: number): void {\r\n        this.recastCrowd.removeAgent(index);\r\n\r\n        var item = this.agents.indexOf(index);\r\n        if (item > -1) {\r\n            this.agents.splice(item, 1);\r\n            this.transforms.splice(item, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the list of all agents attached to this crowd\r\n     * @returns list of agent indices\r\n     */\r\n    getAgents(): number[] {\r\n        return this.agents;\r\n    }\r\n\r\n    /**\r\n     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\r\n     * @param deltaTime in seconds\r\n     */\r\n    update(deltaTime: number): void {\r\n        // update crowd\r\n        var timeStep = this.bjsRECASTPlugin.getTimeStep();\r\n        var maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\r\n        if (timeStep <= Epsilon) {\r\n            this.recastCrowd.update(deltaTime);\r\n        } else {\r\n            var iterationCount = deltaTime / timeStep;\r\n            if (maxStepCount && iterationCount > maxStepCount) {\r\n                iterationCount = maxStepCount;\r\n            }\r\n            if (iterationCount < 1) {\r\n                iterationCount = 1;\r\n            }\r\n            for (let i = 0; i < iterationCount; i++) {\r\n                this.recastCrowd.update(timeStep);\r\n            }\r\n        }\r\n\r\n        // update transforms\r\n        for (let index = 0; index < this.agents.length; index++) {\r\n            this.transforms[index].position = this.getAgentPosition(this.agents[index]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void\r\n    {\r\n        let ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\r\n        this.recastCrowd.setDefaultQueryExtent(ext);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3\r\n    {\r\n        let p = this.recastCrowd.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void\r\n    {\r\n        let p = this.recastCrowd.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose() : void\r\n    {\r\n        this.recastCrowd.destroy();\r\n        this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\r\n        this._onBeforeAnimationsObserver = null;\r\n    }\r\n}"]}