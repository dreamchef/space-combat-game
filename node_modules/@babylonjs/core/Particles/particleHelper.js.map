{"version":3,"file":"particleHelper.js","sourceRoot":"","sources":["../../../sourceES6/core/Particles/particleHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\nimport { Scene } from \"../scene\";\nimport { Tools } from \"../Misc/tools\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Color4 } from '../Maths/math.color';\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { IParticleSystem } from \"./IParticleSystem\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\nimport { ParticleSystemSet } from \"./particleSystemSet\";\nimport { ParticleSystem } from \"./particleSystem\";\nimport { WebRequest } from '../Misc/webRequest';\n/**\n * This class is made for on one-liner static method to help creating particle system set.\n */\nexport class ParticleHelper {\n    /**\n     * Gets or sets base Assets URL\n     */\n    public static BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;\n\n    /** Define the Url to load snippets */\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\n\n    /**\n     * Create a default particle system that you can tweak\n     * @param emitter defines the emitter to use\n     * @param capacity defines the system capacity (default is 500 particles)\n     * @param scene defines the hosting scene\n     * @param useGPU defines if a GPUParticleSystem must be created (default is false)\n     * @returns the new Particle system\n     */\n    public static CreateDefault(emitter: Nullable<AbstractMesh | Vector3>, capacity = 500, scene?: Scene, useGPU = false): IParticleSystem {\n        var system: IParticleSystem;\n\n        if (useGPU) {\n            system = new GPUParticleSystem(\"default system\", { capacity: capacity }, scene!);\n        } else {\n            system = new ParticleSystem(\"default system\", capacity, scene!);\n        }\n\n        system.emitter = emitter;\n        system.particleTexture = new Texture(\"https://www.babylonjs.com/assets/Flare.png\", system.getScene());\n        system.createConeEmitter(0.1, Math.PI / 4);\n\n        // Particle color\n        system.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\n        system.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\n        system.colorDead = new Color4(1.0, 1.0, 1.0, 0.0);\n\n        // Particle Size\n        system.minSize = 0.1;\n        system.maxSize = 0.1;\n\n        // Emission speed\n        system.minEmitPower = 2;\n        system.maxEmitPower = 2;\n\n        // Update speed\n        system.updateSpeed = 1 / 60;\n\n        system.emitRate = 30;\n\n        return system;\n    }\n\n    /**\n     * This is the main static method (one-liner) of this helper to create different particle systems\n     * @param type This string represents the type to the particle system to create\n     * @param scene The scene where the particle system should live\n     * @param gpu If the system will use gpu\n     * @returns the ParticleSystemSet created\n     */\n    public static CreateAsync(type: string, scene: Nullable<Scene>, gpu: boolean = false): Promise<ParticleSystemSet> {\n\n        if (!scene) {\n            scene = EngineStore.LastCreatedScene;\n        }\n\n        let token = {};\n\n        scene!._addPendingData(token);\n\n        return new Promise((resolve, reject) => {\n            if (gpu && !GPUParticleSystem.IsSupported) {\n                scene!._removePendingData(token);\n                return reject(\"Particle system with GPU is not supported.\");\n            }\n\n            Tools.LoadFile(`${ParticleHelper.BaseAssetsUrl}/systems/${type}.json`, (data) => {\n                scene!._removePendingData(token);\n                const newData = JSON.parse(data.toString());\n                return resolve(ParticleSystemSet.Parse(newData, scene!, gpu));\n            }, undefined, undefined, undefined, () => {\n                scene!._removePendingData(token);\n                return reject(`An error occured while the creation of your particle system. Check if your type '${type}' exists.`);\n            });\n\n        });\n    }\n\n    /**\n     * Static function used to export a particle system to a ParticleSystemSet variable.\n     * Please note that the emitter shape is not exported\n     * @param systems defines the particle systems to export\n     * @returns the created particle system set\n     */\n    public static ExportSet(systems: IParticleSystem[]): ParticleSystemSet {\n        var set = new ParticleSystemSet();\n\n        for (var system of systems) {\n            set.systems.push(system);\n        }\n\n        return set;\n    }\n\n    /**\n     * Creates a particle system from a snippet saved in a remote file\n     * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)\n     * @param url defines the url to load from\n     * @param scene defines the hosting scene\n     * @param gpu If the system will use gpu\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a promise that will resolve to the new particle system\n     */\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, gpu: boolean = false, rootUrl: string = \"\"): Promise<IParticleSystem> {\n\n        return new Promise((resolve, reject) => {\n            var request = new WebRequest();\n            request.addEventListener(\"readystatechange\", () => {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        let serializationObject = JSON.parse(request.responseText);\n                        let output: IParticleSystem;\n\n                        if (gpu) {\n                            output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl);\n                        } else {\n                            output = ParticleSystem.Parse(serializationObject, scene, rootUrl);\n                        }\n\n                        if (name) {\n                            output.name = name;\n                        }\n\n                        resolve(output);\n                    } else {\n                        reject(\"Unable to load the particle system\");\n                    }\n                }\n            });\n\n            request.open(\"GET\", url);\n            request.send();\n        });\n    }\n\n    /**\n     * Creates a particle system from a snippet saved by the particle system editor\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n     * @param scene defines the hosting scene\n     * @param gpu If the system will use gpu\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a promise that will resolve to the new particle system\n     */\n    public static CreateFromSnippetAsync(snippetId: string, scene: Scene, gpu: boolean = false, rootUrl: string = \"\"): Promise<IParticleSystem> {\n        if (snippetId === \"_BLANK\") {\n            let system = this.CreateDefault(null);\n            system.start();\n            return Promise.resolve(system);\n        }\n\n        return new Promise((resolve, reject) => {\n            var request = new WebRequest();\n            request.addEventListener(\"readystatechange\", () => {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n                        let serializationObject = JSON.parse(snippet.particleSystem);\n                        let output: IParticleSystem;\n\n                        if (gpu) {\n                            output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl);\n                        } else {\n                            output = ParticleSystem.Parse(serializationObject, scene, rootUrl);\n                        }\n                        output.snippetId = snippetId;\n\n                        resolve(output);\n                    } else {\n                        reject(\"Unable to load the snippet \" + snippetId);\n                    }\n                }\n            });\n\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n            request.send();\n        });\n    }\n}\n"]}