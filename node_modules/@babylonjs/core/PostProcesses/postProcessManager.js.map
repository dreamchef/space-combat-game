{"version":3,"file":"postProcessManager.js","sourceRoot":"","sources":["../../../sourceES6/core/PostProcesses/postProcessManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\n\r\nimport { DataBuffer } from '../Meshes/dataBuffer';\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * PostProcessManager is used to manage one or more post processes or post process pipelines\r\n * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses\r\n */\r\nexport class PostProcessManager {\r\n    private _scene: Scene;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param scene The scene that the post process is associated with.\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n    }\r\n\r\n    private _prepareBuffers(): void {\r\n        if (this._vertexBuffers[VertexBuffer.PositionKind]) {\r\n            return;\r\n        }\r\n\r\n        // VBO\r\n        var vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._buildIndexBuffer();\r\n    }\r\n\r\n    private _buildIndexBuffer(): void {\r\n        // Indices\r\n        var indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the vertex buffers of the manager.\r\n     * @hidden\r\n     */\r\n    public _rebuild(): void {\r\n        let vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (!vb) {\r\n            return;\r\n        }\r\n        vb._rebuild();\r\n        this._buildIndexBuffer();\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Prepares a frame to be run through a post process.\r\n     * @param sourceTexture The input texture to the post procesess. (default: null)\r\n     * @param postProcesses An array of post processes to be run. (default: null)\r\n     * @returns True if the post processes were able to be run.\r\n     * @hidden\r\n     */\r\n    public _prepareFrame(sourceTexture: Nullable<InternalTexture> = null, postProcesses: Nullable<PostProcess[]> = null): boolean {\r\n        let camera = this._scene.activeCamera;\r\n        if (!camera) {\r\n            return false;\r\n        }\r\n\r\n        postProcesses = postProcesses || (<Nullable<PostProcess[]>>camera._postProcesses.filter((pp) => { return pp != null; }));\r\n\r\n        if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\r\n            return false;\r\n        }\r\n\r\n        postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== undefined);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Manually render a set of post processes to a texture.\r\n     * Please note, the frame buffer won't be unbound after the call in case you have more render to do.\r\n     * @param postProcesses An array of post processes to be run.\r\n     * @param targetTexture The target texture to render to.\r\n     * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight\r\n     * @param faceIndex defines the face to render to if a cubemap is defined as the target\r\n     * @param lodLevel defines which lod of the texture to render to\r\n     * @param doNotBindFrambuffer If set to true, assumes that the framebuffer has been bound previously\r\n     */\r\n    public directRender(postProcesses: PostProcess[], targetTexture: Nullable<InternalTexture> = null, forceFullscreenViewport = false, faceIndex = 0, lodLevel = 0, doNotBindFrambuffer = false): void {\r\n        var engine = this._scene.getEngine();\r\n\r\n        for (var index = 0; index < postProcesses.length; index++) {\r\n            if (index < postProcesses.length - 1) {\r\n                postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture);\r\n            } else {\r\n                if (targetTexture) {\r\n                    engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport, lodLevel);\r\n                } else if (!doNotBindFrambuffer) {\r\n                    engine.restoreDefaultFramebuffer();\r\n                }\r\n            }\r\n\r\n            var pp = postProcesses[index];\r\n            var effect = pp.apply();\r\n\r\n            if (effect) {\r\n                pp.onBeforeRenderObservable.notifyObservers(effect);\r\n\r\n                // VBOs\r\n                this._prepareBuffers();\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n\r\n                pp.onAfterRenderObservable.notifyObservers(effect);\r\n            }\r\n        }\r\n\r\n        // Restore depth buffer\r\n        engine.setDepthBuffer(true);\r\n        engine.setDepthWrite(true);\r\n    }\r\n\r\n    /**\r\n     * Finalize the result of the output of the postprocesses.\r\n     * @param doNotPresent If true the result will not be displayed to the screen.\r\n     * @param targetTexture The target texture to render to.\r\n     * @param faceIndex The index of the face to bind the target texture to.\r\n     * @param postProcesses The array of post processes to render.\r\n     * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)\r\n     * @hidden\r\n     */\r\n    public _finalizeFrame(doNotPresent?: boolean, targetTexture?: InternalTexture, faceIndex?: number, postProcesses?: Array<PostProcess>, forceFullscreenViewport = false): void {\r\n        let camera = this._scene.activeCamera;\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        postProcesses = postProcesses || <Array<PostProcess>>camera._postProcesses.filter((pp) => { return pp != null; });\r\n        if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\r\n            return;\r\n        }\r\n        var engine = this._scene.getEngine();\r\n\r\n        for (var index = 0, len = postProcesses.length; index < len; index++) {\r\n            var pp = postProcesses[index];\r\n\r\n            if (index < len - 1) {\r\n                pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture);\r\n            } else {\r\n                if (targetTexture) {\r\n                    engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport);\r\n                    pp._outputTexture = targetTexture;\r\n                } else {\r\n                    engine.restoreDefaultFramebuffer();\r\n                    pp._outputTexture = null;\r\n                }\r\n            }\r\n\r\n            if (doNotPresent) {\r\n                break;\r\n            }\r\n\r\n            var effect = pp.apply();\r\n\r\n            if (effect) {\r\n                pp.onBeforeRenderObservable.notifyObservers(effect);\r\n\r\n                // VBOs\r\n                this._prepareBuffers();\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n\r\n                pp.onAfterRenderObservable.notifyObservers(effect);\r\n            }\r\n        }\r\n\r\n        // Restore states\r\n        engine.setDepthBuffer(true);\r\n        engine.setDepthWrite(true);\r\n        engine.setAlphaMode(0);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the post process manager.\r\n     */\r\n    public dispose(): void {\r\n        var buffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n    }\r\n}\r\n"]}