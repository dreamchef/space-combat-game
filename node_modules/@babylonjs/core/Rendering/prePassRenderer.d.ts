import { MultiRenderTarget } from "../Materials/Textures/multiRenderTarget";
import { Scene } from "../scene";
import { ImageProcessingPostProcess } from "../PostProcesses/imageProcessingPostProcess";
import { Effect } from "../Materials/effect";
import { PrePassEffectConfiguration } from "./prePassEffectConfiguration";
import { AbstractMesh } from '../Meshes/abstractMesh';
import { Material } from '../Materials/material';
import { SubMesh } from '../Meshes/subMesh';
/**
 * Renders a pre pass of the scene
 * This means every mesh in the scene will be rendered to a render target texture
 * And then this texture will be composited to the rendering canvas with post processes
 * It is necessary for effects like subsurface scattering or deferred shading
 */
export declare class PrePassRenderer {
    /** @hidden */
    static _SceneComponentInitialization: (scene: Scene) => void;
    private _textureFormats;
    /**
     * To save performance, we can excluded skinned meshes from the prepass
     */
    excludedSkinnedMesh: AbstractMesh[];
    /**
     * Force material to be excluded from the prepass
     * Can be useful when `useGeometryBufferFallback` is set to `true`
     * and you don't want a material to show in the effect.
     */
    excludedMaterials: Material[];
    private _textureIndices;
    private _scene;
    private _engine;
    private _isDirty;
    /**
     * Number of textures in the multi render target texture where the scene is directly rendered
     */
    mrtCount: number;
    /**
     * The render target where the scene is directly rendered
     */
    prePassRT: MultiRenderTarget;
    private _multiRenderAttachments;
    private _defaultAttachments;
    private _clearAttachments;
    private _postProcesses;
    private readonly _clearColor;
    /**
     * Image processing post process for composition
     */
    imageProcessingPostProcess: ImageProcessingPostProcess;
    /**
     * Configuration for prepass effects
     */
    private _effectConfigurations;
    private _mrtFormats;
    private _mrtLayout;
    private _enabled;
    /**
     * Indicates if the prepass is enabled
     */
    get enabled(): boolean;
    /**
     * How many samples are used for MSAA of the scene render target
     */
    get samples(): number;
    set samples(n: number);
    private _geometryBuffer;
    private _useGeometryBufferFallback;
    /**
     * Uses the geometry buffer renderer as a fallback for non prepass capable effects
     */
    get useGeometryBufferFallback(): boolean;
    set useGeometryBufferFallback(value: boolean);
    /**
     * Set to true to disable gamma transform in PrePass.
     * Can be useful in case you already proceed to gamma transform on a material level
     * and your post processes don't need to be in linear color space.
     */
    disableGammaTransform: boolean;
    /**
     * Instanciates a prepass renderer
     * @param scene The scene
     */
    constructor(scene: Scene);
    private _initializeAttachments;
    private _createCompositionEffect;
    /**
     * Indicates if rendering a prepass is supported
     */
    get isSupported(): boolean;
    /**
     * Sets the proper output textures to draw in the engine.
     * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.
     * @param subMesh Submesh on which the effect is applied
     */
    bindAttachmentsForEffect(effect: Effect, subMesh: SubMesh): void;
    /**
     * Restores attachments for single texture draw.
     */
    restoreAttachments(): void;
    /**
     * @hidden
     */
    _beforeCameraDraw(): void;
    /**
     * @hidden
     */
    _afterCameraDraw(): void;
    private _checkRTSize;
    private _bindFrameBuffer;
    /**
     * Clears the scene render target (in the sense of settings pixels to the scene clear color value)
     */
    clear(): void;
    private _setState;
    private _updateGeometryBufferLayout;
    /**
     * Adds an effect configuration to the prepass.
     * If an effect has already been added, it won't add it twice and will return the configuration
     * already present.
     * @param cfg the effect configuration
     * @return the effect configuration now used by the prepass
     */
    addEffectConfiguration(cfg: PrePassEffectConfiguration): PrePassEffectConfiguration;
    /**
     * Returns the index of a texture in the multi render target texture array.
     * @param type Texture type
     * @return The index
     */
    getIndex(type: number): number;
    private _enable;
    private _disable;
    private _resetLayout;
    private _resetPostProcessChain;
    private _bindPostProcessChain;
    /**
     * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.
     */
    markAsDirty(): void;
    /**
     * Enables a texture on the MultiRenderTarget for prepass
     */
    private _enableTextures;
    private _update;
    private _markAllMaterialsAsPrePassDirty;
    /**
     * Disposes the prepass renderer.
     */
    dispose(): void;
}
