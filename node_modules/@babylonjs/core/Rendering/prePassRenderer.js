import { MultiRenderTarget } from "../Materials/Textures/multiRenderTarget";
import { ImageProcessingPostProcess } from "../PostProcesses/imageProcessingPostProcess";
import { _DevTools } from '../Misc/devTools';
import { Color4 } from "../Maths/math.color";
import { Material } from '../Materials/material';
import { GeometryBufferRenderer } from '../Rendering/geometryBufferRenderer';
/**
 * Renders a pre pass of the scene
 * This means every mesh in the scene will be rendered to a render target texture
 * And then this texture will be composited to the rendering canvas with post processes
 * It is necessary for effects like subsurface scattering or deferred shading
 */
var PrePassRenderer = /** @class */ (function () {
    /**
     * Instanciates a prepass renderer
     * @param scene The scene
     */
    function PrePassRenderer(scene) {
        this._textureFormats = [
            {
                type: 0,
                format: 2,
            },
            {
                type: 1,
                format: 2,
            },
            {
                type: 2,
                format: 2,
            },
            {
                type: 3,
                format: 0,
            },
            {
                type: 4,
                format: 2,
            },
            {
                type: 5,
                format: 2,
            },
            {
                type: 6,
                format: 0,
            },
        ];
        /**
         * To save performance, we can excluded skinned meshes from the prepass
         */
        this.excludedSkinnedMesh = [];
        /**
         * Force material to be excluded from the prepass
         * Can be useful when `useGeometryBufferFallback` is set to `true`
         * and you don't want a material to show in the effect.
         */
        this.excludedMaterials = [];
        this._textureIndices = [];
        this._isDirty = false;
        /**
         * Number of textures in the multi render target texture where the scene is directly rendered
         */
        this.mrtCount = 0;
        this._postProcesses = [];
        this._clearColor = new Color4(0, 0, 0, 0);
        /**
         * Configuration for prepass effects
         */
        this._effectConfigurations = [];
        this._mrtFormats = [];
        this._enabled = false;
        this._useGeometryBufferFallback = false;
        /**
         * Set to true to disable gamma transform in PrePass.
         * Can be useful in case you already proceed to gamma transform on a material level
         * and your post processes don't need to be in linear color space.
         */
        this.disableGammaTransform = false;
        this._scene = scene;
        this._engine = scene.getEngine();
        PrePassRenderer._SceneComponentInitialization(this._scene);
        this._resetLayout();
    }
    Object.defineProperty(PrePassRenderer.prototype, "enabled", {
        /**
         * Indicates if the prepass is enabled
         */
        get: function () {
            return this._enabled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PrePassRenderer.prototype, "samples", {
        /**
         * How many samples are used for MSAA of the scene render target
         */
        get: function () {
            return this.prePassRT.samples;
        },
        set: function (n) {
            if (!this.imageProcessingPostProcess) {
                this._createCompositionEffect();
            }
            this.prePassRT.samples = n;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PrePassRenderer.prototype, "useGeometryBufferFallback", {
        /**
         * Uses the geometry buffer renderer as a fallback for non prepass capable effects
         */
        get: function () {
            return this._useGeometryBufferFallback;
        },
        set: function (value) {
            this._useGeometryBufferFallback = value;
            if (value) {
                this._geometryBuffer = this._scene.enableGeometryBufferRenderer();
                if (!this._geometryBuffer) {
                    // Not supported
                    this._useGeometryBufferFallback = false;
                    return;
                }
                this._geometryBuffer.renderList = [];
                this._geometryBuffer._linkPrePassRenderer(this);
                this._updateGeometryBufferLayout();
            }
            else {
                if (this._geometryBuffer) {
                    this._geometryBuffer._unlinkPrePassRenderer();
                }
                this._geometryBuffer = null;
                this._scene.disableGeometryBufferRenderer();
            }
        },
        enumerable: false,
        configurable: true
    });
    PrePassRenderer.prototype._initializeAttachments = function () {
        var multiRenderLayout = [];
        var clearLayout = [false];
        var defaultLayout = [true];
        for (var i = 0; i < this.mrtCount; i++) {
            multiRenderLayout.push(true);
            if (i > 0) {
                clearLayout.push(true);
                defaultLayout.push(false);
            }
        }
        this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);
        this._clearAttachments = this._engine.buildTextureLayout(clearLayout);
        this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);
    };
    PrePassRenderer.prototype._createCompositionEffect = function () {
        this.prePassRT = new MultiRenderTarget("sceneprePassRT", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, this.mrtCount, this._scene, { generateMipMaps: false, generateDepthTexture: true, defaultType: 0, types: this._mrtFormats });
        this.prePassRT.samples = 1;
        this._initializeAttachments();
        if (this._useGeometryBufferFallback && !this._geometryBuffer) {
            // Initializes the link with geometry buffer
            this.useGeometryBufferFallback = true;
        }
        this.imageProcessingPostProcess = new ImageProcessingPostProcess("sceneCompositionPass", 1, null, undefined, this._engine);
        this.imageProcessingPostProcess.autoClear = false;
    };
    Object.defineProperty(PrePassRenderer.prototype, "isSupported", {
        /**
         * Indicates if rendering a prepass is supported
         */
        get: function () {
            return this._engine.webGLVersion > 1 || this._scene.getEngine().getCaps().drawBuffersExtension;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets the proper output textures to draw in the engine.
     * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.
     * @param subMesh Submesh on which the effect is applied
     */
    PrePassRenderer.prototype.bindAttachmentsForEffect = function (effect, subMesh) {
        if (this.enabled) {
            if (effect._multiTarget) {
                this._engine.bindAttachments(this._multiRenderAttachments);
            }
            else {
                this._engine.bindAttachments(this._defaultAttachments);
                if (this._geometryBuffer) {
                    var material = subMesh.getMaterial();
                    if (material && this.excludedMaterials.indexOf(material) === -1) {
                        this._geometryBuffer.renderList.push(subMesh.getRenderingMesh());
                    }
                }
            }
        }
    };
    /**
     * Restores attachments for single texture draw.
     */
    PrePassRenderer.prototype.restoreAttachments = function () {
        if (this.enabled && this._defaultAttachments) {
            this._engine.bindAttachments(this._defaultAttachments);
        }
    };
    /**
     * @hidden
     */
    PrePassRenderer.prototype._beforeCameraDraw = function () {
        if (this._isDirty) {
            this._update();
        }
        if (this._geometryBuffer) {
            this._geometryBuffer.renderList.length = 0;
        }
        this._bindFrameBuffer();
    };
    /**
     * @hidden
     */
    PrePassRenderer.prototype._afterCameraDraw = function () {
        if (this._enabled) {
            var firstCameraPP = this._scene.activeCamera && this._scene.activeCamera._getFirstPostProcess();
            if (firstCameraPP && this._postProcesses.length) {
                this._scene.postProcessManager._prepareFrame();
            }
            this._scene.postProcessManager.directRender(this._postProcesses, firstCameraPP ? firstCameraPP.inputTexture : null);
        }
    };
    PrePassRenderer.prototype._checkRTSize = function () {
        var requiredWidth = this._engine.getRenderWidth(true);
        var requiredHeight = this._engine.getRenderHeight(true);
        var width = this.prePassRT.getRenderWidth();
        var height = this.prePassRT.getRenderHeight();
        if (width !== requiredWidth || height !== requiredHeight) {
            this.prePassRT.resize({ width: requiredWidth, height: requiredHeight });
            this._updateGeometryBufferLayout();
            this._bindPostProcessChain();
        }
    };
    PrePassRenderer.prototype._bindFrameBuffer = function () {
        if (this._enabled) {
            this._checkRTSize();
            var internalTexture = this.prePassRT.getInternalTexture();
            if (internalTexture) {
                this._engine.bindFramebuffer(internalTexture);
            }
        }
    };
    /**
     * Clears the scene render target (in the sense of settings pixels to the scene clear color value)
     */
    PrePassRenderer.prototype.clear = function () {
        if (this._enabled) {
            this._bindFrameBuffer();
            // Regular clear color with the scene clear color of the 1st attachment
            this._engine.clear(this._scene.clearColor, this._scene.autoClear || this._scene.forceWireframe || this._scene.forcePointsCloud, this._scene.autoClearDepthAndStencil, this._scene.autoClearDepthAndStencil);
            // Clearing other attachment with 0 on all other attachments
            this._engine.bindAttachments(this._clearAttachments);
            this._engine.clear(this._clearColor, true, false, false);
            this._engine.bindAttachments(this._defaultAttachments);
        }
    };
    PrePassRenderer.prototype._setState = function (enabled) {
        this._enabled = enabled;
        this._scene.prePass = enabled;
        if (this.imageProcessingPostProcess) {
            this.imageProcessingPostProcess.imageProcessingConfiguration.applyByPostProcess = enabled;
        }
    };
    PrePassRenderer.prototype._updateGeometryBufferLayout = function () {
        if (this._geometryBuffer) {
            this._geometryBuffer._resetLayout();
            var texturesActivated = [];
            for (var i = 0; i < this._mrtLayout.length; i++) {
                texturesActivated.push(false);
            }
            this._geometryBuffer._linkInternalTexture(this.prePassRT.getInternalTexture());
            var matches = [
                {
                    prePassConstant: 5,
                    geometryBufferConstant: GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE,
                },
                {
                    prePassConstant: 1,
                    geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE,
                },
                {
                    prePassConstant: 3,
                    geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE,
                },
                {
                    prePassConstant: 2,
                    geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE,
                }
            ];
            // replace textures in the geometryBuffer RT
            for (var i = 0; i < matches.length; i++) {
                var index = this._mrtLayout.indexOf(matches[i].prePassConstant);
                if (index !== -1) {
                    this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);
                    texturesActivated[index] = true;
                }
            }
            this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));
        }
    };
    /**
     * Adds an effect configuration to the prepass.
     * If an effect has already been added, it won't add it twice and will return the configuration
     * already present.
     * @param cfg the effect configuration
     * @return the effect configuration now used by the prepass
     */
    PrePassRenderer.prototype.addEffectConfiguration = function (cfg) {
        // Do not add twice
        for (var i = 0; i < this._effectConfigurations.length; i++) {
            if (this._effectConfigurations[i].name === cfg.name) {
                return this._effectConfigurations[i];
            }
        }
        this._effectConfigurations.push(cfg);
        return cfg;
    };
    /**
     * Returns the index of a texture in the multi render target texture array.
     * @param type Texture type
     * @return The index
     */
    PrePassRenderer.prototype.getIndex = function (type) {
        return this._textureIndices[type];
    };
    PrePassRenderer.prototype._enable = function () {
        var _a, _b;
        var previousMrtCount = this.mrtCount;
        for (var i = 0; i < this._effectConfigurations.length; i++) {
            if (this._effectConfigurations[i].enabled) {
                this._enableTextures(this._effectConfigurations[i].texturesRequired);
            }
        }
        if (this.prePassRT && this.mrtCount !== previousMrtCount) {
            this.prePassRT.updateCount(this.mrtCount, { types: this._mrtFormats });
        }
        this._updateGeometryBufferLayout();
        this._resetPostProcessChain();
        for (var i = 0; i < this._effectConfigurations.length; i++) {
            if (this._effectConfigurations[i].enabled) {
                if (!this._effectConfigurations[i].postProcess && this._effectConfigurations[i].createPostProcess) {
                    this._effectConfigurations[i].createPostProcess();
                }
                if (this._effectConfigurations[i].postProcess) {
                    this._postProcesses.push(this._effectConfigurations[i].postProcess);
                }
            }
        }
        this._initializeAttachments();
        if (!this.imageProcessingPostProcess) {
            this._createCompositionEffect();
        }
        var isIPPAlreadyPresent = false;
        if ((_a = this._scene.activeCamera) === null || _a === void 0 ? void 0 : _a._postProcesses) {
            for (var i = 0; i < this._scene.activeCamera._postProcesses.length; i++) {
                if (((_b = this._scene.activeCamera._postProcesses[i]) === null || _b === void 0 ? void 0 : _b.getClassName()) === "ImageProcessingPostProcess") {
                    isIPPAlreadyPresent = true;
                }
            }
        }
        if (!isIPPAlreadyPresent && !this.disableGammaTransform) {
            this._postProcesses.push(this.imageProcessingPostProcess);
        }
        this._bindPostProcessChain();
        this._setState(true);
    };
    PrePassRenderer.prototype._disable = function () {
        this._setState(false);
        this._resetLayout();
        for (var i = 0; i < this._effectConfigurations.length; i++) {
            this._effectConfigurations[i].enabled = false;
        }
    };
    PrePassRenderer.prototype._resetLayout = function () {
        for (var i = 0; i < this._textureFormats.length; i++) {
            this._textureIndices[this._textureFormats[i].type] = -1;
        }
        this._textureIndices[4] = 0;
        this._mrtLayout = [4];
        this._mrtFormats = [2];
        this.mrtCount = 1;
    };
    PrePassRenderer.prototype._resetPostProcessChain = function () {
        this._postProcesses = [];
        if (this.imageProcessingPostProcess) {
            this.imageProcessingPostProcess.restoreDefaultInputTexture();
        }
        for (var i = 0; i < this._effectConfigurations.length; i++) {
            if (this._effectConfigurations[i].postProcess) {
                this._effectConfigurations[i].postProcess.restoreDefaultInputTexture();
            }
        }
    };
    PrePassRenderer.prototype._bindPostProcessChain = function () {
        var _a;
        if (this._postProcesses.length) {
            this._postProcesses[0].inputTexture = this.prePassRT.getInternalTexture();
        }
        else {
            var pp = (_a = this._scene.activeCamera) === null || _a === void 0 ? void 0 : _a._getFirstPostProcess();
            if (pp) {
                pp.inputTexture = this.prePassRT.getInternalTexture();
            }
        }
    };
    /**
     * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.
     */
    PrePassRenderer.prototype.markAsDirty = function () {
        this._isDirty = true;
    };
    /**
     * Enables a texture on the MultiRenderTarget for prepass
     */
    PrePassRenderer.prototype._enableTextures = function (types) {
        for (var i = 0; i < types.length; i++) {
            var type = types[i];
            if (this._textureIndices[type] === -1) {
                this._textureIndices[type] = this._mrtLayout.length;
                this._mrtLayout.push(type);
                this._mrtFormats.push(this._textureFormats[type].format);
                this.mrtCount++;
            }
        }
    };
    PrePassRenderer.prototype._update = function () {
        this._disable();
        var enablePrePass = false;
        for (var i = 0; i < this._scene.materials.length; i++) {
            if (this._scene.materials[i].setPrePassRenderer(this)) {
                enablePrePass = true;
            }
        }
        var camera = this._scene.activeCamera;
        if (!camera) {
            return;
        }
        var postProcesses = camera._postProcesses.filter(function (pp) { return pp != null; });
        if (postProcesses) {
            for (var i = 0; i < postProcesses.length; i++) {
                if (postProcesses[i].setPrePassRenderer(this)) {
                    enablePrePass = true;
                }
            }
        }
        this._markAllMaterialsAsPrePassDirty();
        this._isDirty = false;
        if (enablePrePass) {
            this._enable();
        }
        if (!this.enabled) {
            // Prepass disabled, we render only on 1 color attachment
            this._engine.restoreDefaultFramebuffer();
            this._engine.restoreSingleAttachment();
        }
    };
    PrePassRenderer.prototype._markAllMaterialsAsPrePassDirty = function () {
        var materials = this._scene.materials;
        for (var i = 0; i < materials.length; i++) {
            materials[i].markAsDirty(Material.PrePassDirtyFlag);
        }
    };
    /**
     * Disposes the prepass renderer.
     */
    PrePassRenderer.prototype.dispose = function () {
        for (var i = 0; i < this._effectConfigurations.length; i++) {
            if (this._effectConfigurations[i].dispose) {
                this._effectConfigurations[i].dispose();
            }
        }
        this.imageProcessingPostProcess.dispose();
        this.prePassRT.dispose();
    };
    /** @hidden */
    PrePassRenderer._SceneComponentInitialization = function (_) {
        throw _DevTools.WarnImport("PrePassRendererSceneComponent");
    };
    return PrePassRenderer;
}());
export { PrePassRenderer };
//# sourceMappingURL=prePassRenderer.js.map