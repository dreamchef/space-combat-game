import { WebXRAbstractFeature } from "./WebXRAbstractFeature";
import { WebXRSessionManager } from "../webXRSessionManager";
import { AbstractMesh } from "../../Meshes/abstractMesh";
import { Mesh } from "../../Meshes/mesh";
import { WebXRInput } from "../webXRInput";
import { WebXRInputSource } from "../webXRInputSource";
import { Nullable } from "../../types";
import { IDisposable } from "../../scene";
import { Observable } from "../../Misc/observable";
import { InstancedMesh } from "../../Meshes/instancedMesh";
/**
 * Configuration interface for the hand tracking feature
 */
export interface IWebXRHandTrackingOptions {
    /**
     * The xrInput that will be used as source for new hands
     */
    xrInput: WebXRInput;
    /**
     * Configuration object for the joint meshes
     */
    jointMeshes?: {
        /**
         * Should the meshes created be invisible (defaults to false)
         */
        invisible?: boolean;
        /**
         * A source mesh to be used to create instances. Defaults to a sphere.
         * This mesh will be the source for all other (25) meshes.
         * It should have the general size of a single unit, as the instances will be scaled according to the provided radius
         */
        sourceMesh?: Mesh;
        /**
         * This function will be called after a mesh was created for a specific joint.
         * Using this function you can either manipulate the instance or return a new mesh.
         * When returning a new mesh the instance created before will be disposed
         */
        onHandJointMeshGenerated?: (meshInstance: InstancedMesh, jointId: number, controllerId: string) => Mesh | undefined;
        /**
         * Should the source mesh stay visible. Defaults to false
         */
        keepOriginalVisible?: boolean;
        /**
         * Scale factor for all instances (defaults to 2)
         */
        scaleFactor?: number;
        /**
         * Should each instance have its own physics impostor
         */
        enablePhysics?: boolean;
        /**
         * If enabled, override default physics properties
         */
        physicsProps?: {
            friction?: number;
            restitution?: number;
            impostorType?: number;
        };
        /**
         * Should the default hand mesh be disabled. In this case, the spheres will be visible (unless set invisible).
         */
        disableDefaultHandMesh?: boolean;
        /**
         * a rigged hand-mesh that will be updated according to the XRHand data provided. This will override the default hand mesh
         */
        handMeshes?: {
            right: AbstractMesh;
            left: AbstractMesh;
        };
        /**
         * If a hand mesh was provided, this array will define what axis will update which node. This will override the default hand mesh
         */
        rigMapping?: {
            right: string[];
            left: string[];
        };
    };
}
/**
 * Parts of the hands divided to writs and finger names
 */
export declare const enum HandPart {
    /**
     * HandPart - Wrist
     */
    WRIST = "wrist",
    /**
     * HandPart - The THumb
     */
    THUMB = "thumb",
    /**
     * HandPart - Index finger
     */
    INDEX = "index",
    /**
     * HandPart - Middle finger
     */
    MIDDLE = "middle",
    /**
     * HandPart - Ring finger
     */
    RING = "ring",
    /**
     * HandPart - Little finger
     */
    LITTLE = "little"
}
/**
 * Representing a single hand (with its corresponding native XRHand object)
 */
export declare class WebXRHand implements IDisposable {
    /** the controller to which the hand correlates */
    readonly xrController: WebXRInputSource;
    /** the meshes to be used to track the hand joints */
    readonly trackedMeshes: AbstractMesh[];
    private _handMesh?;
    private _rigMapping?;
    private _scene;
    private _defaultHandMesh;
    private _transformNodeMapping;
    /**
     * Hand-parts definition (key is HandPart)
     */
    handPartsDefinition: {
        [key: string]: number[];
    };
    /**
     * Populate the HandPartsDefinition object.
     * This is called as a side effect since certain browsers don't have XRHand defined.
     */
    private generateHandPartsDefinition;
    /**
     * Construct a new hand object
     * @param xrController the controller to which the hand correlates
     * @param trackedMeshes the meshes to be used to track the hand joints
     * @param _handMesh an optional hand mesh. if not provided, ours will be used
     * @param _rigMapping an optional rig mapping for the hand mesh. if not provided, ours will be used
     * @param disableDefaultHandMesh should the default mesh creation be disabled
     */
    constructor(
    /** the controller to which the hand correlates */
    xrController: WebXRInputSource, 
    /** the meshes to be used to track the hand joints */
    trackedMeshes: AbstractMesh[], _handMesh?: AbstractMesh | undefined, _rigMapping?: string[] | undefined, disableDefaultHandMesh?: boolean);
    /**
     * Update this hand from the latest xr frame
     * @param xrFrame xrFrame to update from
     * @param referenceSpace The current viewer reference space
     * @param scaleFactor optional scale factor for the meshes
     */
    updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace, scaleFactor?: number): void;
    /**
     * Get meshes of part of the hand
     * @param part the part of hand to get
     * @returns An array of meshes that correlate to the hand part requested
     */
    getHandPartMeshes(part: HandPart): AbstractMesh[];
    /**
     * Dispose this Hand object
     */
    dispose(): void;
    private _generateDefaultHandMesh;
}
/**
 * WebXR Hand Joint tracking feature, available for selected browsers and devices
 */
export declare class WebXRHandTracking extends WebXRAbstractFeature {
    /**
     * options to use when constructing this feature
     */
    readonly options: IWebXRHandTrackingOptions;
    private static _idCounter;
    /**
     * The module's name
     */
    static readonly Name = "xr-hand-tracking";
    /**
     * The (Babylon) version of this module.
     * This is an integer representing the implementation version.
     * This number does not correspond to the WebXR specs version
     */
    static readonly Version = 1;
    /**
     * This observable will notify registered observers when a new hand object was added and initialized
     */
    onHandAddedObservable: Observable<WebXRHand>;
    /**
     * This observable will notify its observers right before the hand object is disposed
     */
    onHandRemovedObservable: Observable<WebXRHand>;
    private _hands;
    /**
     * Creates a new instance of the hit test feature
     * @param _xrSessionManager an instance of WebXRSessionManager
     * @param options options to use when constructing this feature
     */
    constructor(_xrSessionManager: WebXRSessionManager, 
    /**
     * options to use when constructing this feature
     */
    options: IWebXRHandTrackingOptions);
    /**
     * Check if the needed objects are defined.
     * This does not mean that the feature is enabled, but that the objects needed are well defined.
     */
    isCompatible(): boolean;
    /**
     * attach this feature
     * Will usually be called by the features manager
     *
     * @returns true if successful.
     */
    attach(): boolean;
    /**
     * detach this feature.
     * Will usually be called by the features manager
     *
     * @returns true if successful.
     */
    detach(): boolean;
    /**
     * Dispose this feature and all of the resources attached
     */
    dispose(): void;
    /**
     * Get the hand object according to the controller id
     * @param controllerId the controller id to which we want to get the hand
     * @returns null if not found or the WebXRHand object if found
     */
    getHandByControllerId(controllerId: string): Nullable<WebXRHand>;
    /**
     * Get a hand object according to the requested handedness
     * @param handedness the handedness to request
     * @returns null if not found or the WebXRHand object if found
     */
    getHandByHandedness(handedness: XRHandedness): Nullable<WebXRHand>;
    protected _onXRFrame(_xrFrame: XRFrame): void;
    private _attachHand;
    private _detachHand;
}
