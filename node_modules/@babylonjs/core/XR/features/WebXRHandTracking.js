import { __assign, __awaiter, __extends, __generator } from "tslib";
import { WebXRAbstractFeature } from "./WebXRAbstractFeature";
import { WebXRFeatureName } from "../webXRFeaturesManager";
import { SphereBuilder } from "../../Meshes/Builders/sphereBuilder";
import { Quaternion } from "../../Maths/math.vector";
import { PhysicsImpostor } from "../../Physics/physicsImpostor";
import { WebXRFeaturesManager } from "../webXRFeaturesManager";
import { Observable } from "../../Misc/observable";
import { SceneLoader } from "../../Loading/sceneLoader";
import { Color3 } from "../../Maths/math.color";
import { NodeMaterial } from "../../Materials/Node/nodeMaterial";
import { Material } from "../../Materials/material";
import { Engine } from "../../Engines/engine";
import { Tools } from "../../Misc/tools";
import { Axis } from "../../Maths/math.axis";
/**
 * Representing a single hand (with its corresponding native XRHand object)
 */
var WebXRHand = /** @class */ (function () {
    /**
     * Construct a new hand object
     * @param xrController the controller to which the hand correlates
     * @param trackedMeshes the meshes to be used to track the hand joints
     * @param _handMesh an optional hand mesh. if not provided, ours will be used
     * @param _rigMapping an optional rig mapping for the hand mesh. if not provided, ours will be used
     * @param disableDefaultHandMesh should the default mesh creation be disabled
     */
    function WebXRHand(
    /** the controller to which the hand correlates */
    xrController, 
    /** the meshes to be used to track the hand joints */
    trackedMeshes, _handMesh, _rigMapping, disableDefaultHandMesh) {
        this.xrController = xrController;
        this.trackedMeshes = trackedMeshes;
        this._handMesh = _handMesh;
        this._rigMapping = _rigMapping;
        this._defaultHandMesh = false;
        this._transformNodeMapping = [];
        this.handPartsDefinition = this.generateHandPartsDefinition(xrController.inputSource.hand);
        this._scene = trackedMeshes[0].getScene();
        if (this._handMesh && this._rigMapping) {
            this._defaultHandMesh = false;
        }
        else {
            if (!disableDefaultHandMesh) {
                this._generateDefaultHandMesh();
            }
        }
        // hide the motion controller, if available/loaded
        if (this.xrController.motionController) {
            if (this.xrController.motionController.rootMesh) {
                this.xrController.motionController.rootMesh.setEnabled(false);
            }
            else {
                this.xrController.motionController.onModelLoadedObservable.add(function (controller) {
                    if (controller.rootMesh) {
                        controller.rootMesh.setEnabled(false);
                    }
                });
            }
        }
        this.xrController.onMotionControllerInitObservable.add(function (motionController) {
            motionController.onModelLoadedObservable.add(function (controller) {
                if (controller.rootMesh) {
                    controller.rootMesh.setEnabled(false);
                }
            });
            if (motionController.rootMesh) {
                motionController.rootMesh.setEnabled(false);
            }
        });
    }
    /**
     * Populate the HandPartsDefinition object.
     * This is called as a side effect since certain browsers don't have XRHand defined.
     */
    WebXRHand.prototype.generateHandPartsDefinition = function (hand) {
        var _a;
        return _a = {},
            _a["wrist" /* WRIST */] = [hand.WRIST],
            _a["thumb" /* THUMB */] = [hand.THUMB_METACARPAL, hand.THUMB_PHALANX_PROXIMAL, hand.THUMB_PHALANX_DISTAL, hand.THUMB_PHALANX_TIP],
            _a["index" /* INDEX */] = [hand.INDEX_METACARPAL, hand.INDEX_PHALANX_PROXIMAL, hand.INDEX_PHALANX_INTERMEDIATE, hand.INDEX_PHALANX_DISTAL, hand.INDEX_PHALANX_TIP],
            _a["middle" /* MIDDLE */] = [hand.MIDDLE_METACARPAL, hand.MIDDLE_PHALANX_PROXIMAL, hand.MIDDLE_PHALANX_INTERMEDIATE, hand.MIDDLE_PHALANX_DISTAL, hand.MIDDLE_PHALANX_TIP],
            _a["ring" /* RING */] = [hand.RING_METACARPAL, hand.RING_PHALANX_PROXIMAL, hand.RING_PHALANX_INTERMEDIATE, hand.RING_PHALANX_DISTAL, hand.RING_PHALANX_TIP],
            _a["little" /* LITTLE */] = [hand.LITTLE_METACARPAL, hand.LITTLE_PHALANX_PROXIMAL, hand.LITTLE_PHALANX_INTERMEDIATE, hand.LITTLE_PHALANX_DISTAL, hand.LITTLE_PHALANX_TIP],
            _a;
    };
    /**
     * Update this hand from the latest xr frame
     * @param xrFrame xrFrame to update from
     * @param referenceSpace The current viewer reference space
     * @param scaleFactor optional scale factor for the meshes
     */
    WebXRHand.prototype.updateFromXRFrame = function (xrFrame, referenceSpace, scaleFactor) {
        var _this = this;
        if (scaleFactor === void 0) { scaleFactor = 2; }
        var hand = this.xrController.inputSource.hand;
        if (!hand) {
            return;
        }
        this.trackedMeshes.forEach(function (mesh, idx) {
            var xrJoint = hand[idx];
            if (xrJoint) {
                var pose = xrFrame.getJointPose(xrJoint, referenceSpace);
                if (!pose || !pose.transform) {
                    return;
                }
                // get the transformation. can be done with matrix decomposition as well
                var pos = pose.transform.position;
                var orientation_1 = pose.transform.orientation;
                mesh.position.set(pos.x, pos.y, pos.z);
                mesh.rotationQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w);
                // left handed system conversion
                // get the radius of the joint. In general it is static, but just in case it does change we update it on each frame.
                var radius = (pose.radius || 0.008) * scaleFactor;
                mesh.scaling.set(radius, radius, radius);
                // now check for the hand mesh
                if (_this._handMesh && _this._rigMapping) {
                    if (_this._rigMapping[idx]) {
                        _this._transformNodeMapping[idx] = _this._transformNodeMapping[idx] || _this._scene.getTransformNodeByName(_this._rigMapping[idx]);
                        if (_this._transformNodeMapping[idx]) {
                            _this._transformNodeMapping[idx].position.copyFrom(mesh.position);
                            _this._transformNodeMapping[idx].rotationQuaternion.copyFrom(mesh.rotationQuaternion);
                            // no scaling at the moment
                            // this._transformNodeMapping[idx].scaling.copyFrom(mesh.scaling).scaleInPlace(20);
                            mesh.isVisible = false;
                        }
                    }
                }
                if (!mesh.getScene().useRightHandedSystem) {
                    mesh.position.z *= -1;
                    mesh.rotationQuaternion.z *= -1;
                    mesh.rotationQuaternion.w *= -1;
                }
            }
        });
    };
    /**
     * Get meshes of part of the hand
     * @param part the part of hand to get
     * @returns An array of meshes that correlate to the hand part requested
     */
    WebXRHand.prototype.getHandPartMeshes = function (part) {
        var _this = this;
        return this.handPartsDefinition[part].map(function (idx) { return _this.trackedMeshes[idx]; });
    };
    /**
     * Dispose this Hand object
     */
    WebXRHand.prototype.dispose = function () {
        this.trackedMeshes.forEach(function (mesh) { return mesh.dispose(); });
        // dispose the hand mesh, if it is the default one
        if (this._defaultHandMesh && this._handMesh) {
            this._handMesh.dispose();
        }
    };
    WebXRHand.prototype._generateDefaultHandMesh = function () {
        return __awaiter(this, void 0, void 0, function () {
            var handedness_1, filename, loaded, handColors, handShader, handNodes, tm, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        handedness_1 = this.xrController.inputSource.handedness === "right" ? "right" : "left";
                        filename = (handedness_1 === "right" ? "r" : "l") + "_hand_" + (this._scene.useRightHandedSystem ? "r" : "l") + "hs.glb";
                        return [4 /*yield*/, SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/HandMeshes/", filename, this._scene)];
                    case 1:
                        loaded = _a.sent();
                        handColors = {
                            base: Color3.FromInts(116, 63, 203),
                            fresnel: Color3.FromInts(149, 102, 229),
                            fingerColor: Color3.FromInts(177, 130, 255),
                            tipFresnel: Color3.FromInts(220, 200, 255),
                        };
                        handShader = new NodeMaterial("leftHandShader", this._scene, { emitComments: false });
                        return [4 /*yield*/, handShader.loadAsync("https://patrickryanms.github.io/BabylonJStextures/Demos/xrHandMesh/handsShader.json")];
                    case 2:
                        _a.sent();
                        // build node materials
                        handShader.build(false);
                        // depth prepass and alpha mode
                        handShader.needDepthPrePass = true;
                        handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;
                        handShader.alphaMode = Engine.ALPHA_COMBINE;
                        handNodes = {
                            base: handShader.getBlockByName("baseColor"),
                            fresnel: handShader.getBlockByName("fresnelColor"),
                            fingerColor: handShader.getBlockByName("fingerColor"),
                            tipFresnel: handShader.getBlockByName("tipFresnelColor"),
                        };
                        handNodes.base.value = handColors.base;
                        handNodes.fresnel.value = handColors.fresnel;
                        handNodes.fingerColor.value = handColors.fingerColor;
                        handNodes.tipFresnel.value = handColors.tipFresnel;
                        loaded.meshes[1].material = handShader;
                        this._defaultHandMesh = true;
                        this._handMesh = loaded.meshes[0];
                        this._rigMapping = [
                            "wrist_",
                            "thumb_metacarpal_",
                            "thumb_proxPhalanx_",
                            "thumb_distPhalanx_",
                            "thumb_tip_",
                            "index_metacarpal_",
                            "index_proxPhalanx_",
                            "index_intPhalanx_",
                            "index_distPhalanx_",
                            "index_tip_",
                            "middle_metacarpal_",
                            "middle_proxPhalanx_",
                            "middle_intPhalanx_",
                            "middle_distPhalanx_",
                            "middle_tip_",
                            "ring_metacarpal_",
                            "ring_proxPhalanx_",
                            "ring_intPhalanx_",
                            "ring_distPhalanx_",
                            "ring_tip_",
                            "little_metacarpal_",
                            "little_proxPhalanx_",
                            "little_intPhalanx_",
                            "little_distPhalanx_",
                            "little_tip_",
                        ].map(function (joint) { return "" + joint + (handedness_1 === "right" ? "R" : "L"); });
                        tm = this._scene.getTransformNodeByName(this._rigMapping[0]);
                        if (!tm) {
                            throw new Error("could not find the wrist node");
                        }
                        else {
                            tm.parent && tm.parent.rotate(Axis.Y, Math.PI);
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        Tools.Error("error loading hand mesh");
                        console.log(e_1);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return WebXRHand;
}());
export { WebXRHand };
/**
 * WebXR Hand Joint tracking feature, available for selected browsers and devices
 */
var WebXRHandTracking = /** @class */ (function (_super) {
    __extends(WebXRHandTracking, _super);
    /**
     * Creates a new instance of the hit test feature
     * @param _xrSessionManager an instance of WebXRSessionManager
     * @param options options to use when constructing this feature
     */
    function WebXRHandTracking(_xrSessionManager, 
    /**
     * options to use when constructing this feature
     */
    options) {
        var _this = _super.call(this, _xrSessionManager) || this;
        _this.options = options;
        /**
         * This observable will notify registered observers when a new hand object was added and initialized
         */
        _this.onHandAddedObservable = new Observable();
        /**
         * This observable will notify its observers right before the hand object is disposed
         */
        _this.onHandRemovedObservable = new Observable();
        _this._hands = {};
        _this._attachHand = function (xrController) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            if (!xrController.inputSource.hand || _this._hands[xrController.uniqueId]) {
                // already attached
                return;
            }
            var hand = xrController.inputSource.hand;
            var trackedMeshes = [];
            var originalMesh = ((_a = _this.options.jointMeshes) === null || _a === void 0 ? void 0 : _a.sourceMesh) || SphereBuilder.CreateSphere("jointParent", { diameter: 1 });
            originalMesh.isVisible = !!((_b = _this.options.jointMeshes) === null || _b === void 0 ? void 0 : _b.keepOriginalVisible);
            for (var i = 0; i < hand.length; ++i) {
                var newInstance = originalMesh.createInstance(xrController.uniqueId + "-handJoint-" + i);
                if ((_c = _this.options.jointMeshes) === null || _c === void 0 ? void 0 : _c.onHandJointMeshGenerated) {
                    var returnedMesh = _this.options.jointMeshes.onHandJointMeshGenerated(newInstance, i, xrController.uniqueId);
                    if (returnedMesh) {
                        if (returnedMesh !== newInstance) {
                            newInstance.dispose();
                            newInstance = returnedMesh;
                        }
                    }
                }
                newInstance.isPickable = false;
                if ((_d = _this.options.jointMeshes) === null || _d === void 0 ? void 0 : _d.enablePhysics) {
                    var props = _this.options.jointMeshes.physicsProps || {};
                    var type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;
                    newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, __assign({ mass: 0 }, props));
                }
                newInstance.rotationQuaternion = new Quaternion();
                if ((_e = _this.options.jointMeshes) === null || _e === void 0 ? void 0 : _e.invisible) {
                    newInstance.isVisible = false;
                }
                trackedMeshes.push(newInstance);
            }
            var handedness = xrController.inputSource.handedness === "right" ? "right" : "left";
            var handMesh = ((_f = _this.options.jointMeshes) === null || _f === void 0 ? void 0 : _f.handMeshes) && ((_g = _this.options.jointMeshes) === null || _g === void 0 ? void 0 : _g.handMeshes[handedness]);
            var rigMapping = ((_h = _this.options.jointMeshes) === null || _h === void 0 ? void 0 : _h.rigMapping) && ((_j = _this.options.jointMeshes) === null || _j === void 0 ? void 0 : _j.rigMapping[handedness]);
            var webxrHand = new WebXRHand(xrController, trackedMeshes, handMesh, rigMapping, (_k = _this.options.jointMeshes) === null || _k === void 0 ? void 0 : _k.disableDefaultHandMesh);
            // get two new meshes
            _this._hands[xrController.uniqueId] = {
                handObject: webxrHand,
                id: WebXRHandTracking._idCounter++,
            };
            _this.onHandAddedObservable.notifyObservers(webxrHand);
        };
        _this.xrNativeFeatureName = "hand-tracking";
        return _this;
    }
    /**
     * Check if the needed objects are defined.
     * This does not mean that the feature is enabled, but that the objects needed are well defined.
     */
    WebXRHandTracking.prototype.isCompatible = function () {
        return typeof XRHand !== "undefined";
    };
    /**
     * attach this feature
     * Will usually be called by the features manager
     *
     * @returns true if successful.
     */
    WebXRHandTracking.prototype.attach = function () {
        var _this = this;
        if (!_super.prototype.attach.call(this)) {
            return false;
        }
        this.options.xrInput.controllers.forEach(this._attachHand);
        this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);
        this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, function (controller) {
            // REMOVE the controller
            _this._detachHand(controller.uniqueId);
        });
        return true;
    };
    /**
     * detach this feature.
     * Will usually be called by the features manager
     *
     * @returns true if successful.
     */
    WebXRHandTracking.prototype.detach = function () {
        var _this = this;
        if (!_super.prototype.detach.call(this)) {
            return false;
        }
        Object.keys(this._hands).forEach(function (controllerId) {
            _this._detachHand(controllerId);
        });
        return true;
    };
    /**
     * Dispose this feature and all of the resources attached
     */
    WebXRHandTracking.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.onHandAddedObservable.clear();
    };
    /**
     * Get the hand object according to the controller id
     * @param controllerId the controller id to which we want to get the hand
     * @returns null if not found or the WebXRHand object if found
     */
    WebXRHandTracking.prototype.getHandByControllerId = function (controllerId) {
        var _a;
        return ((_a = this._hands[controllerId]) === null || _a === void 0 ? void 0 : _a.handObject) || null;
    };
    /**
     * Get a hand object according to the requested handedness
     * @param handedness the handedness to request
     * @returns null if not found or the WebXRHand object if found
     */
    WebXRHandTracking.prototype.getHandByHandedness = function (handedness) {
        var _this = this;
        var handednesses = Object.keys(this._hands).map(function (key) { return _this._hands[key].handObject.xrController.inputSource.handedness; });
        var found = handednesses.indexOf(handedness);
        if (found !== -1) {
            return this._hands[found].handObject;
        }
        return null;
    };
    WebXRHandTracking.prototype._onXRFrame = function (_xrFrame) {
        var _this = this;
        // iterate over the hands object
        Object.keys(this._hands).forEach(function (id) {
            var _a;
            _this._hands[id].handObject.updateFromXRFrame(_xrFrame, _this._xrSessionManager.referenceSpace, (_a = _this.options.jointMeshes) === null || _a === void 0 ? void 0 : _a.scaleFactor);
        });
    };
    WebXRHandTracking.prototype._detachHand = function (controllerId) {
        if (this._hands[controllerId]) {
            this.onHandRemovedObservable.notifyObservers(this._hands[controllerId].handObject);
            this._hands[controllerId].handObject.dispose();
        }
    };
    WebXRHandTracking._idCounter = 0;
    /**
     * The module's name
     */
    WebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;
    /**
     * The (Babylon) version of this module.
     * This is an integer representing the implementation version.
     * This number does not correspond to the WebXR specs version
     */
    WebXRHandTracking.Version = 1;
    return WebXRHandTracking;
}(WebXRAbstractFeature));
export { WebXRHandTracking };
//register the plugin
WebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, function (xrSessionManager, options) {
    return function () { return new WebXRHandTracking(xrSessionManager, options); };
}, WebXRHandTracking.Version, false);
//# sourceMappingURL=WebXRHandTracking.js.map