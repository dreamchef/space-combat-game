{"version":3,"file":"MSFT_lod.js","sourceRoot":"","sources":["../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"@babylonjs/core/types\";\nimport { Observable } from \"@babylonjs/core/Misc/observable\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { BaseTexture } from '@babylonjs/core/Materials/Textures/baseTexture';\nimport { INode, IMaterial, IBuffer, IScene } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { IProperty, IMSFTLOD } from 'babylonjs-gltf2interface';\n\nconst NAME = \"MSFT_lod\";\n\ninterface IBufferInfo {\n    start: number;\n    end: number;\n    loaded: Deferred<ArrayBufferView>;\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_lod)\n */\nexport class MSFT_lod implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n    public order = 100;\n\n    /**\n     * Maximum number of LODs to load, starting from the lowest LOD.\n     */\n    public maxLODsToLoad = 10;\n\n    /**\n     * Observable raised when all node LODs of one level are loaded.\n     * The event data is the index of the loaded LOD starting from zero.\n     * Dispose the loader to cancel the loading of the next level of LODs.\n     */\n    public onNodeLODsLoadedObservable = new Observable<number>();\n\n    /**\n     * Observable raised when all material LODs of one level are loaded.\n     * The event data is the index of the loaded LOD starting from zero.\n     * Dispose the loader to cancel the loading of the next level of LODs.\n     */\n    public onMaterialLODsLoadedObservable = new Observable<number>();\n\n    private _loader: GLTFLoader;\n\n    private _bufferLODs = new Array<IBufferInfo>();\n\n    private _nodeIndexLOD: Nullable<number> = null;\n    private _nodeSignalLODs = new Array<Deferred<void>>();\n    private _nodePromiseLODs = new Array<Array<Promise<any>>>();\n    private _nodeBufferLODs = new Array<IBufferInfo>();\n\n    private _materialIndexLOD: Nullable<number> = null;\n    private _materialSignalLODs = new Array<Deferred<void>>();\n    private _materialPromiseLODs = new Array<Array<Promise<any>>>();\n    private _materialBufferLODs = new Array<IBufferInfo>();\n\n    /** @hidden */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n\n    /** @hidden */\n    public dispose() {\n        (this._loader as any) = null;\n\n        this._nodeIndexLOD = null;\n        this._nodeSignalLODs.length = 0;\n        this._nodePromiseLODs.length = 0;\n        this._nodeBufferLODs.length = 0;\n\n        this._materialIndexLOD = null;\n        this._materialSignalLODs.length = 0;\n        this._materialPromiseLODs.length = 0;\n        this._materialBufferLODs.length = 0;\n\n        this.onMaterialLODsLoadedObservable.clear();\n        this.onNodeLODsLoadedObservable.clear();\n    }\n\n    /** @hidden */\n    public onReady(): void {\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\n                    this._loader.log(`Loaded node LOD ${indexLOD}`);\n                }\n\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\n\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\n                    this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\n                    if (this._nodeSignalLODs[indexLOD]) {\n                        this._nodeSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n\n            this._loader._completePromises.push(promise);\n        }\n\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\n                    this._loader.log(`Loaded material LOD ${indexLOD}`);\n                }\n\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\n\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\n                    this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\n                    if (this._materialSignalLODs[indexLOD]) {\n                        this._materialSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n\n            this._loader._completePromises.push(promise);\n        }\n    }\n\n    /** @hidden */\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\n        const promise = this._loader.loadSceneAsync(context, scene);\n        this._loadBufferLOD(this._bufferLODs, 0);\n        return promise;\n    }\n\n    /** @hidden */\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, TransformNode>(context, node, this.name, (extensionContext, extension) => {\n            let firstPromise: Promise<TransformNode>;\n\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\n                const nodeLOD = nodeLODs[indexLOD];\n\n                if (indexLOD !== 0) {\n                    this._nodeIndexLOD = indexLOD;\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\n                }\n\n                const assign = (babylonTransformNode: TransformNode) => { babylonTransformNode.setEnabled(false); };\n                const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assign).then((babylonMesh) => {\n                    if (indexLOD !== 0) {\n                        // TODO: should not rely on _babylonTransformNode\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\n                        if (previousNodeLOD._babylonTransformNode) {\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\n                            delete previousNodeLOD._babylonTransformNode;\n                        }\n                    }\n\n                    babylonMesh.setEnabled(true);\n                    return babylonMesh;\n                });\n\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\n\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._nodeIndexLOD = null;\n                    this._nodePromiseLODs[indexLOD].push(promise);\n                }\n            }\n\n            this._loader.logClose();\n            return firstPromise!;\n        });\n    }\n\n    /** @hidden */\n    public _loadMaterialAsync(context: string, material: IMaterial, babylonMesh: Nullable<Mesh>, babylonDrawMode: number, assign: (babylonMaterial: Material) => void): Nullable<Promise<Material>> {\n        // Don't load material LODs if already loading a node LOD.\n        if (this._nodeIndexLOD) {\n            return null;\n        }\n\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, Material>(context, material, this.name, (extensionContext, extension) => {\n            let firstPromise: Promise<Material>;\n\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\n                const materialLOD = materialLODs[indexLOD];\n\n                if (indexLOD !== 0) {\n                    this._materialIndexLOD = indexLOD;\n                }\n\n                const promise = this._loader._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                    if (indexLOD === 0) {\n                        assign(babylonMaterial);\n                    }\n                }).then((babylonMaterial) => {\n                    if (indexLOD !== 0) {\n                        assign(babylonMaterial);\n\n                        // TODO: should not rely on _data\n                        const previousDataLOD = materialLODs[indexLOD - 1]._data!;\n                        if (previousDataLOD[babylonDrawMode]) {\n                            this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\n                            delete previousDataLOD[babylonDrawMode];\n                        }\n                    }\n\n                    return babylonMaterial;\n                });\n\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\n\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._materialIndexLOD = null;\n                    this._materialPromiseLODs[indexLOD].push(promise);\n                }\n            }\n\n            this._loader.logClose();\n            return firstPromise!;\n        });\n    }\n\n    /** @hidden */\n    public _loadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\n        // Defer the loading of uris if loading a node or material LOD.\n        if (this._nodeIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._nodeIndexLOD - 1;\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred<void>();\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(() => {\n                return this._loader.loadUriAsync(context, property, uri);\n            });\n        }\n        else if (this._materialIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._materialIndexLOD - 1;\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred<void>();\n            return this._materialSignalLODs[previousIndexLOD].promise.then(() => {\n                return this._loader.loadUriAsync(context, property, uri);\n            });\n        }\n\n        return null;\n    }\n\n    /** @hidden */\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\n            if (!this._loader.bin) {\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\n            }\n\n            const loadAsync = (bufferLODs: Array<IBufferInfo>, indexLOD: number) => {\n                const start = byteOffset;\n                const end = start + byteLength - 1;\n                let bufferLOD = bufferLODs[indexLOD];\n                if (bufferLOD) {\n                    bufferLOD.start = Math.min(bufferLOD.start, start);\n                    bufferLOD.end = Math.max(bufferLOD.end, end);\n                }\n                else {\n                    bufferLOD = { start: start, end: end, loaded: new Deferred() };\n                    bufferLODs[indexLOD] = bufferLOD;\n                }\n\n                return bufferLOD.loaded.promise.then((data) => {\n                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\n                });\n            };\n\n            this._loader.log(`deferred`);\n\n            if (this._nodeIndexLOD !== null) {\n                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\n            }\n            else if (this._materialIndexLOD !== null) {\n                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\n            }\n            else {\n                return loadAsync(this._bufferLODs, 0);\n            }\n        }\n\n        return null;\n    }\n\n    private _loadBufferLOD(bufferLODs: Array<IBufferInfo>, indexLOD: number): void {\n        const bufferLOD = bufferLODs[indexLOD];\n        if (bufferLOD) {\n            this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\n            this._loader.bin!.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then((data) => {\n                bufferLOD.loaded.resolve(data);\n            }, (error) => {\n                bufferLOD.loaded.reject(error);\n            });\n        }\n    }\n\n    /**\n     * Gets an array of LOD properties from lowest to highest.\n     */\n    private _getLODs<T>(context: string, property: T, array: ArrayLike<T> | undefined, ids: number[]): T[] {\n        if (this.maxLODsToLoad <= 0) {\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\n        }\n\n        const properties = new Array<T>();\n\n        for (let i = ids.length - 1; i >= 0; i--) {\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\n            if (properties.length === this.maxLODsToLoad) {\n                return properties;\n            }\n        }\n\n        properties.push(property);\n        return properties;\n    }\n\n    private _disposeTransformNode(babylonTransformNode: TransformNode): void {\n        const babylonMaterials = new Array<Material>();\n        const babylonMaterial = (babylonTransformNode as Mesh).material;\n        if (babylonMaterial) {\n            babylonMaterials.push(babylonMaterial);\n        }\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\n            if (babylonMesh.material) {\n                babylonMaterials.push(babylonMesh.material);\n            }\n        }\n\n        babylonTransformNode.dispose();\n\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\n        this._disposeMaterials(babylonMaterialsToDispose);\n    }\n\n    private _disposeMaterials(babylonMaterials: Material[]): void {\n        const babylonTextures: { [uniqueId: number]: BaseTexture } = {};\n\n        for (const babylonMaterial of babylonMaterials) {\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\n            }\n\n            babylonMaterial.dispose();\n        }\n\n        for (const uniqueId in babylonTextures) {\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\n                    delete babylonTextures[uniqueId];\n                }\n            }\n        }\n\n        for (const uniqueId in babylonTextures) {\n            babylonTextures[uniqueId].dispose();\n        }\n    }\n}\n\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_lod(loader));"]}