{"version":3,"file":"glTFLoader.js","sourceRoot":"","sources":["../../../../sourceES6/loaders/src/glTF/2.0/glTFLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { IndicesArray, Nullable } from \"@babylonjs/core/types\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred\";\nimport { Quaternion, Vector3, Matrix } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera\";\nimport { AnimationGroup } from \"@babylonjs/core/Animations/animationGroup\";\nimport { Animation } from \"@babylonjs/core/Animations/animation\";\nimport { Bone } from \"@babylonjs/core/Bones/bone\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\nimport { Buffer, VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\nimport { InstancedMesh } from \"@babylonjs/core/Meshes/instancedMesh\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { MorphTarget } from \"@babylonjs/core/Morph/morphTarget\";\nimport { MorphTargetManager } from \"@babylonjs/core/Morph/morphTargetManager\";\nimport { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"@babylonjs/core/Loading/sceneLoader\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { IProperty, AccessorType, CameraType, AnimationChannelTargetPath, AnimationSamplerInterpolation, AccessorComponentType, MaterialAlphaMode, TextureMinFilter, TextureWrapMode, TextureMagFilter, MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\nimport { _IAnimationSamplerData, IGLTF, ISampler, INode, IScene, IMesh, IAccessor, ISkin, ICamera, IAnimation, IAnimationChannel, IAnimationSampler, IBuffer, IBufferView, IMaterialPbrMetallicRoughness, IMaterial, ITextureInfo, ITexture, IImage, IMeshPrimitive, IArrayItem as IArrItem, _ISamplerData } from \"./glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"./glTFLoaderExtension\";\nimport { IGLTFLoader, GLTFFileLoader, GLTFLoaderState, IGLTFLoaderData, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader\";\nimport { IAnimationKey, AnimationKeyInterpolation } from '@babylonjs/core/Animations/animationKey';\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\nimport { IDataBuffer } from '@babylonjs/core/Misc/dataReader';\nimport { LoadFileError } from '@babylonjs/core/Misc/fileTools';\nimport { Logger } from '@babylonjs/core/Misc/logger';\nimport { Light } from '@babylonjs/core/Lights/light';\nimport { TmpVectors } from '@babylonjs/core/Maths/math.vector';\nimport { BoundingInfo } from '@babylonjs/core/Culling/boundingInfo';\n\ninterface TypedArrayLike extends ArrayBufferView {\n    readonly length: number;\n    [n: number]: number;\n}\n\ninterface TypedArrayConstructor {\n    new(length: number): TypedArrayLike;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): TypedArrayLike;\n}\n\ninterface ILoaderProperty extends IProperty {\n    _activeLoaderExtensionFunctions: {\n        [id: string]: boolean\n    };\n}\n\ninterface IRegisteredExtension {\n    factory: (loader: GLTFLoader) => IGLTFLoaderExtension;\n}\n\n/**\n * Helper class for working with arrays when loading the glTF asset\n */\nexport class ArrayItem {\n    /**\n     * Gets an item from the given array.\n     * @param context The context when loading the asset\n     * @param array The array to get the item from\n     * @param index The index to the array\n     * @returns The array item\n     */\n    public static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T {\n        if (!array || index == undefined || !array[index]) {\n            throw new Error(`${context}: Failed to find index (${index})`);\n        }\n\n        return array[index];\n    }\n\n    /**\n     * Assign an `index` field to each item of the given array.\n     * @param array The array of items\n     */\n    public static Assign(array?: IArrItem[]): void {\n        if (array) {\n            for (let index = 0; index < array.length; index++) {\n                array[index].index = index;\n            }\n        }\n    }\n}\n\n/**\n * The glTF 2.0 loader\n */\nexport class GLTFLoader implements IGLTFLoader {\n    /** @hidden */\n    public _completePromises = new Array<Promise<any>>();\n\n    /** @hidden */\n    public _forAssetContainer = false;\n\n    /** Storage */\n    public _babylonLights: Light[] = [];\n\n    /** @hidden */\n    public _disableInstancedMesh = 0;\n\n    private _disposed = false;\n    private _parent: GLTFFileLoader;\n    private _state: Nullable<GLTFLoaderState> = null;\n    private _extensions = new Array<IGLTFLoaderExtension>();\n    private _rootUrl: string;\n    private _fileName: string;\n    private _uniqueRootUrl: string;\n    private _gltf: IGLTF;\n    private _bin: Nullable<IDataBuffer>;\n    private _babylonScene: Scene;\n    private _rootBabylonMesh: Mesh;\n    private _defaultBabylonMaterialData: { [drawMode: number]: Material } = {};\n\n    private static _RegisteredExtensions: { [name: string]: IRegisteredExtension } = {};\n\n    /**\n     * The default glTF sampler.\n     */\n    public static readonly DefaultSampler: ISampler = { index: -1 };\n\n    /**\n     * Registers a loader extension.\n     * @param name The name of the loader extension.\n     * @param factory The factory function that creates the loader extension.\n     */\n    public static RegisterExtension(name: string, factory: (loader: GLTFLoader) => IGLTFLoaderExtension): void {\n        if (GLTFLoader.UnregisterExtension(name)) {\n            Logger.Warn(`Extension with the name '${name}' already exists`);\n        }\n\n        GLTFLoader._RegisteredExtensions[name] = {\n            factory: factory\n        };\n    }\n\n    /**\n     * Unregisters a loader extension.\n     * @param name The name of the loader extension.\n     * @returns A boolean indicating whether the extension has been unregistered\n     */\n    public static UnregisterExtension(name: string): boolean {\n        if (!GLTFLoader._RegisteredExtensions[name]) {\n            return false;\n        }\n\n        delete GLTFLoader._RegisteredExtensions[name];\n        return true;\n    }\n\n    /**\n     * The loader state.\n     */\n    public get state(): Nullable<GLTFLoaderState> {\n        return this._state;\n    }\n\n    /**\n     * The object that represents the glTF JSON.\n     */\n    public get gltf(): IGLTF {\n        return this._gltf;\n    }\n\n    /**\n     * The BIN chunk of a binary glTF.\n     */\n    public get bin(): Nullable<IDataBuffer> {\n        return this._bin;\n    }\n\n    /**\n     * The parent file loader.\n     */\n    public get parent(): GLTFFileLoader {\n        return this._parent;\n    }\n\n    /**\n     * The Babylon scene when loading the asset.\n     */\n    public get babylonScene(): Scene {\n        return this._babylonScene;\n    }\n\n    /**\n     * The root Babylon mesh when loading the asset.\n     */\n    public get rootBabylonMesh(): Mesh {\n        return this._rootBabylonMesh;\n    }\n\n    /** @hidden */\n    constructor(parent: GLTFFileLoader) {\n        this._parent = parent;\n    }\n\n    /** @hidden */\n    public dispose(): void {\n        if (this._disposed) {\n            return;\n        }\n\n        this._disposed = true;\n\n        this._completePromises.length = 0;\n\n        for (const name in this._extensions) {\n            const extension = this._extensions[name];\n            extension.dispose && extension.dispose();\n            delete this._extensions[name];\n        }\n\n        (this._gltf as any) = null;\n        (this._babylonScene as any) = null;\n        (this._rootBabylonMesh as any) = null;\n\n        this._parent.dispose();\n    }\n\n    /** @hidden */\n    public importMeshAsync(meshesNames: any, scene: Scene, forAssetContainer: boolean, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<ISceneLoaderAsyncResult> {\n        return Promise.resolve().then(() => {\n            this._babylonScene = scene;\n            this._rootUrl = rootUrl;\n            this._fileName = fileName || \"scene\";\n            this._forAssetContainer = forAssetContainer;\n            this._loadData(data);\n\n            let nodes: Nullable<Array<number>> = null;\n\n            if (meshesNames) {\n                const nodeMap: { [name: string]: number } = {};\n                if (this._gltf.nodes) {\n                    for (const node of this._gltf.nodes) {\n                        if (node.name) {\n                            nodeMap[node.name] = node.index;\n                        }\n                    }\n                }\n\n                const names = (meshesNames instanceof Array) ? meshesNames : [meshesNames];\n                nodes = names.map((name) => {\n                    const node = nodeMap[name];\n                    if (node === undefined) {\n                        throw new Error(`Failed to find node '${name}'`);\n                    }\n\n                    return node;\n                });\n            }\n\n            return this._loadAsync(nodes, () => {\n                return {\n                    meshes: this._getMeshes(),\n                    particleSystems: [],\n                    skeletons: this._getSkeletons(),\n                    animationGroups: this._getAnimationGroups(),\n                    lights: this._babylonLights,\n                    transformNodes: this._getTransformNodes(),\n                    geometries: this._getGeometries()\n                };\n            });\n        });\n    }\n\n    /** @hidden */\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\n        return Promise.resolve().then(() => {\n            this._babylonScene = scene;\n            this._rootUrl = rootUrl;\n            this._fileName = fileName || \"scene\";\n            this._loadData(data);\n            return this._loadAsync(null, () => undefined);\n        });\n    }\n\n    private _loadAsync<T>(nodes: Nullable<Array<number>>, resultFunc: () => T): Promise<T> {\n        return Promise.resolve().then(() => {\n            this._uniqueRootUrl = (this._rootUrl.indexOf(\"file:\") === -1 && this._fileName) ? this._rootUrl : `${this._rootUrl}${Date.now()}/`;\n\n            this._loadExtensions();\n            this._checkExtensions();\n\n            const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\n            const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\n\n            this._parent._startPerformanceCounter(loadingToReadyCounterName);\n            this._parent._startPerformanceCounter(loadingToCompleteCounterName);\n\n            this._setState(GLTFLoaderState.LOADING);\n            this._extensionsOnLoading();\n\n            const promises = new Array<Promise<any>>();\n\n            // Block the marking of materials dirty until the scene is loaded.\n            const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;\n            this._babylonScene.blockMaterialDirtyMechanism = true;\n\n            if (nodes) {\n                promises.push(this.loadSceneAsync(\"/nodes\", { nodes: nodes, index: -1 }));\n            }\n            else if (this._gltf.scene != undefined || (this._gltf.scenes && this._gltf.scenes[0])) {\n                const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);\n                promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));\n            }\n\n            if (this.parent.loadAllMaterials && this._gltf.materials) {\n                for (let m = 0; m < this._gltf.materials.length; ++m) {\n                    const material = this._gltf.materials[m];\n                    const context = \"/materials/\" + m;\n                    const babylonDrawMode = Material.TriangleFillMode;\n\n                    promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, (material) => { }));\n                }\n            }\n\n            // Restore the blocking of material dirty.\n            this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\n\n            if (this._parent.compileMaterials) {\n                promises.push(this._compileMaterialsAsync());\n            }\n\n            if (this._parent.compileShadowGenerators) {\n                promises.push(this._compileShadowGeneratorsAsync());\n            }\n\n            const resultPromise = Promise.all(promises).then(() => {\n                if (this._rootBabylonMesh) {\n                    this._rootBabylonMesh.setEnabled(true);\n                }\n\n                this._extensionsOnReady();\n                this._setState(GLTFLoaderState.READY);\n\n                this._startAnimations();\n\n                return resultFunc();\n            });\n\n            resultPromise.then(() => {\n                this._parent._endPerformanceCounter(loadingToReadyCounterName);\n\n                Tools.SetImmediate(() => {\n                    if (!this._disposed) {\n                        Promise.all(this._completePromises).then(() => {\n                            this._parent._endPerformanceCounter(loadingToCompleteCounterName);\n\n                            this._setState(GLTFLoaderState.COMPLETE);\n\n                            this._parent.onCompleteObservable.notifyObservers(undefined);\n                            this._parent.onCompleteObservable.clear();\n\n                            this.dispose();\n                        }, (error) => {\n                            this._parent.onErrorObservable.notifyObservers(error);\n                            this._parent.onErrorObservable.clear();\n\n                            this.dispose();\n                        });\n                    }\n                });\n            });\n\n            return resultPromise;\n        }).catch((error) => {\n            if (!this._disposed) {\n                this._parent.onErrorObservable.notifyObservers(error);\n                this._parent.onErrorObservable.clear();\n\n                this.dispose();\n            }\n\n            throw error;\n        });\n    }\n\n    private _loadData(data: IGLTFLoaderData): void {\n        this._gltf = data.json as IGLTF;\n        this._setupData();\n\n        if (data.bin) {\n            const buffers = this._gltf.buffers;\n            if (buffers && buffers[0] && !buffers[0].uri) {\n                const binaryBuffer = buffers[0];\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\n                    Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\n                }\n\n                this._bin = data.bin;\n            }\n            else {\n                Logger.Warn(\"Unexpected BIN chunk\");\n            }\n        }\n    }\n\n    private _setupData(): void {\n        ArrayItem.Assign(this._gltf.accessors);\n        ArrayItem.Assign(this._gltf.animations);\n        ArrayItem.Assign(this._gltf.buffers);\n        ArrayItem.Assign(this._gltf.bufferViews);\n        ArrayItem.Assign(this._gltf.cameras);\n        ArrayItem.Assign(this._gltf.images);\n        ArrayItem.Assign(this._gltf.materials);\n        ArrayItem.Assign(this._gltf.meshes);\n        ArrayItem.Assign(this._gltf.nodes);\n        ArrayItem.Assign(this._gltf.samplers);\n        ArrayItem.Assign(this._gltf.scenes);\n        ArrayItem.Assign(this._gltf.skins);\n        ArrayItem.Assign(this._gltf.textures);\n\n        if (this._gltf.nodes) {\n            const nodeParents: { [index: number]: number } = {};\n            for (const node of this._gltf.nodes) {\n                if (node.children) {\n                    for (const index of node.children) {\n                        nodeParents[index] = node.index;\n                    }\n                }\n            }\n\n            const rootNode = this._createRootNode();\n            for (const node of this._gltf.nodes) {\n                const parentIndex = nodeParents[node.index];\n                node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\n            }\n        }\n    }\n\n    private _loadExtensions(): void {\n        for (const name in GLTFLoader._RegisteredExtensions) {\n            const extension = GLTFLoader._RegisteredExtensions[name].factory(this);\n            if (extension.name !== name) {\n                Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);\n            }\n\n            this._extensions.push(extension);\n            this._parent.onExtensionLoadedObservable.notifyObservers(extension);\n        }\n\n        this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));\n        this._parent.onExtensionLoadedObservable.clear();\n    }\n\n    private _checkExtensions(): void {\n        if (this._gltf.extensionsRequired) {\n            for (const name of this._gltf.extensionsRequired) {\n                const available = this._extensions.some((extension) => extension.name === name && extension.enabled);\n                if (!available) {\n                    throw new Error(`Require extension ${name} is not available`);\n                }\n            }\n        }\n    }\n\n    private _setState(state: GLTFLoaderState): void {\n        this._state = state;\n        this.log(GLTFLoaderState[this._state]);\n    }\n\n    private _createRootNode(): INode {\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        this._rootBabylonMesh = new Mesh(\"__root__\", this._babylonScene);\n        this._babylonScene._blockEntityCollection = false;\n        this._rootBabylonMesh.setEnabled(false);\n\n        const rootNode: INode = {\n            _babylonTransformNode: this._rootBabylonMesh,\n            index: -1\n        };\n\n        switch (this._parent.coordinateSystemMode) {\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\n                if (!this._babylonScene.useRightHandedSystem) {\n                    rootNode.rotation = [0, 1, 0, 0];\n                    rootNode.scale = [1, 1, -1];\n                    GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\n                }\n                break;\n            }\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\n                this._babylonScene.useRightHandedSystem = true;\n                break;\n            }\n            default: {\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\n            }\n        }\n\n        this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\n        return rootNode;\n    }\n\n    /**\n     * Loads a glTF scene.\n     * @param context The context when loading the asset\n     * @param scene The glTF scene property\n     * @returns A promise that resolves when the load is complete\n     */\n    public loadSceneAsync(context: string, scene: IScene): Promise<void> {\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        this.logOpen(`${context} ${scene.name || \"\"}`);\n\n        if (scene.nodes) {\n            for (let index of scene.nodes) {\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);\n                promises.push(this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {\n                    babylonMesh.parent = this._rootBabylonMesh;\n                }));\n            }\n        }\n\n        // Link all Babylon bones for each glTF node with the corresponding Babylon transform node.\n        // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\n        if (this._gltf.nodes) {\n            for (const node of this._gltf.nodes) {\n                if (node._babylonTransformNode && node._babylonBones) {\n                    for (const babylonBone of node._babylonBones) {\n                        babylonBone.linkTransformNode(node._babylonTransformNode);\n                    }\n                }\n            }\n        }\n\n        promises.push(this._loadAnimationsAsync());\n\n        this.logClose();\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    private _forEachPrimitive(node: INode, callback: (babylonMesh: AbstractMesh) => void): void {\n        if (node._primitiveBabylonMeshes) {\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\n                callback(babylonMesh);\n            }\n        }\n    }\n\n    private _getGeometries(): Geometry[] {\n        const geometries = new Array<Geometry>();\n\n        const nodes = this._gltf.nodes;\n        if (nodes) {\n            for (const node of nodes) {\n                this._forEachPrimitive(node, (babylonMesh) => {\n                    const geometry = (babylonMesh as Mesh).geometry;\n                    if (geometry && geometries.indexOf(geometry) === -1) {\n                        geometries.push(geometry);\n                    }\n                });\n            }\n        }\n\n        return geometries;\n    }\n\n    private _getMeshes(): AbstractMesh[] {\n        const meshes = new Array<AbstractMesh>();\n\n        // Root mesh is always first.\n        meshes.push(this._rootBabylonMesh);\n\n        const nodes = this._gltf.nodes;\n        if (nodes) {\n            for (const node of nodes) {\n                this._forEachPrimitive(node, (babylonMesh) => {\n                    meshes.push(babylonMesh);\n                });\n            }\n        }\n\n        return meshes;\n    }\n\n    private _getTransformNodes(): TransformNode[] {\n        const transformNodes = new Array<TransformNode>();\n\n        const nodes = this._gltf.nodes;\n        if (nodes) {\n            for (const node of nodes) {\n                if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\n                    transformNodes.push(node._babylonTransformNode);\n                }\n            }\n        }\n\n        return transformNodes;\n    }\n\n    private _getSkeletons(): Skeleton[] {\n        const skeletons = new Array<Skeleton>();\n\n        const skins = this._gltf.skins;\n        if (skins) {\n            for (const skin of skins) {\n                if (skin._data) {\n                    skeletons.push(skin._data.babylonSkeleton);\n                }\n            }\n        }\n\n        return skeletons;\n    }\n\n    private _getAnimationGroups(): AnimationGroup[] {\n        const animationGroups = new Array<AnimationGroup>();\n\n        const animations = this._gltf.animations;\n        if (animations) {\n            for (const animation of animations) {\n                if (animation._babylonAnimationGroup) {\n                    animationGroups.push(animation._babylonAnimationGroup);\n                }\n            }\n        }\n\n        return animationGroups;\n    }\n\n    private _startAnimations(): void {\n        switch (this._parent.animationStartMode) {\n            case GLTFLoaderAnimationStartMode.NONE: {\n                // do nothing\n                break;\n            }\n            case GLTFLoaderAnimationStartMode.FIRST: {\n                const babylonAnimationGroups = this._getAnimationGroups();\n                if (babylonAnimationGroups.length !== 0) {\n                    babylonAnimationGroups[0].start(true);\n                }\n                break;\n            }\n            case GLTFLoaderAnimationStartMode.ALL: {\n                const babylonAnimationGroups = this._getAnimationGroups();\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\n                    babylonAnimationGroup.start(true);\n                }\n                break;\n            }\n            default: {\n                Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\n                return;\n            }\n        }\n    }\n\n    /**\n     * Loads a glTF node.\n     * @param context The context when loading the asset\n     * @param node The glTF node property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\n     */\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void = () => { }): Promise<TransformNode> {\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        if (node._babylonTransformNode) {\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        this.logOpen(`${context} ${node.name || \"\"}`);\n\n        const loadNode = (babylonTransformNode: TransformNode) => {\n            GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\n            GLTFLoader._LoadTransform(node, babylonTransformNode);\n\n            if (node.camera != undefined) {\n                const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);\n                promises.push(this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {\n                    babylonCamera.parent = babylonTransformNode;\n                }));\n            }\n\n            if (node.children) {\n                for (const index of node.children) {\n                    const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);\n                    promises.push(this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {\n                        childBabylonMesh.parent = babylonTransformNode;\n                    }));\n                }\n            }\n\n            assign(babylonTransformNode);\n        };\n\n        if (node.mesh == undefined) {\n            const nodeName = node.name || `node${node.index}`;\n            this._babylonScene._blockEntityCollection = this._forAssetContainer;\n            node._babylonTransformNode = new TransformNode(nodeName, this._babylonScene);\n            this._babylonScene._blockEntityCollection = false;\n            loadNode(node._babylonTransformNode);\n        }\n        else {\n            const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\n            promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));\n        }\n\n        this.logClose();\n\n        return Promise.all(promises).then(() => {\n            this._forEachPrimitive(node, (babylonMesh) => {\n                if ((babylonMesh as Mesh).geometry && (babylonMesh as Mesh).geometry!.useBoundingInfoFromGeometry) {\n                    // simply apply the world matrices to the bounding info - the extends are already ok\n                    babylonMesh._updateBoundingInfo();\n                } else {\n                    babylonMesh.refreshBoundingInfo(true);\n                }\n            });\n\n            return node._babylonTransformNode!;\n        });\n    }\n\n    private _loadMeshAsync(context: string, node: INode, mesh: IMesh, assign: (babylonTransformNode: TransformNode) => void): Promise<TransformNode> {\n        const primitives = mesh.primitives;\n        if (!primitives || !primitives.length) {\n            throw new Error(`${context}: Primitives are missing`);\n        }\n\n        if (primitives[0].index == undefined) {\n            ArrayItem.Assign(primitives);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\n\n        const name = node.name || `node${node.index}`;\n\n        if (primitives.length === 1) {\n            const primitive = mesh.primitives[0];\n            promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, (babylonMesh) => {\n                node._babylonTransformNode = babylonMesh;\n                node._primitiveBabylonMeshes = [babylonMesh];\n            }));\n        }\n        else {\n            this._babylonScene._blockEntityCollection = this._forAssetContainer;\n            node._babylonTransformNode = new TransformNode(name, this._babylonScene);\n            this._babylonScene._blockEntityCollection = false;\n            node._primitiveBabylonMeshes = [];\n            for (const primitive of primitives) {\n                promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {\n                    babylonMesh.parent = node._babylonTransformNode!;\n                    node._primitiveBabylonMeshes!.push(babylonMesh);\n                }));\n            }\n        }\n\n        if (node.skin != undefined) {\n            const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);\n            promises.push(this._loadSkinAsync(`/skins/${skin.index}`, node, skin));\n        }\n\n        assign(node._babylonTransformNode!);\n\n        this.logClose();\n\n        return Promise.all(promises).then(() => {\n            return node._babylonTransformNode!;\n        });\n    }\n\n    /**\n     * @hidden Define this method to modify the default behavior when loading data for mesh primitives.\n     * @param context The context when loading the asset\n     * @param name The mesh name when loading the asset\n     * @param node The glTF node when loading the asset\n     * @param mesh The glTF mesh when loading the asset\n     * @param primitive The glTF mesh primitive property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\n     */\n    public _loadMeshPrimitiveAsync(context: string, name: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, assign: (babylonMesh: AbstractMesh) => void): Promise<AbstractMesh> {\n        const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        this.logOpen(`${context}`);\n\n        const shouldInstance = (this._disableInstancedMesh === 0) && this._parent.createInstances && (node.skin == undefined && !mesh.primitives[0].targets);\n\n        let babylonAbstractMesh: AbstractMesh;\n        let promise: Promise<any>;\n\n        if (shouldInstance && primitive._instanceData) {\n            babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name) as InstancedMesh;\n            promise = primitive._instanceData.promise;\n        }\n        else {\n            const promises = new Array<Promise<any>>();\n\n            this._babylonScene._blockEntityCollection = this._forAssetContainer;\n            const babylonMesh = new Mesh(name, this._babylonScene);\n            this._babylonScene._blockEntityCollection = false;\n            babylonMesh.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n\n            this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\n            promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh).then((babylonGeometry) => {\n                return this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\n                    this._babylonScene._blockEntityCollection = this._forAssetContainer;\n                    babylonGeometry.applyToMesh(babylonMesh);\n                    this._babylonScene._blockEntityCollection = false;\n                });\n            }));\n\n            const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n            if (primitive.material == undefined) {\n                let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\n                if (!babylonMaterial) {\n                    babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\n                    this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n                    this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\n                }\n                babylonMesh.material = babylonMaterial;\n            }\n            else {\n                const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);\n                promises.push(this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                    babylonMesh.material = babylonMaterial;\n                }));\n            }\n\n            promise = Promise.all(promises);\n\n            if (shouldInstance) {\n                primitive._instanceData = {\n                    babylonSourceMesh: babylonMesh,\n                    promise: promise\n                };\n            }\n\n            babylonAbstractMesh = babylonMesh;\n        }\n\n        GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\n        assign(babylonAbstractMesh);\n\n        this.logClose();\n\n        return promise.then(() => {\n            return babylonAbstractMesh;\n        });\n    }\n\n    private _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Promise<Geometry> {\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const attributes = primitive.attributes;\n        if (!attributes) {\n            throw new Error(`${context}: Attributes are missing`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\n\n        if (primitive.indices == undefined) {\n            babylonMesh.isUnIndexed = true;\n        }\n        else {\n            const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);\n            promises.push(this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                babylonGeometry.setIndices(data);\n            }));\n        }\n\n        const loadAttribute = (attribute: string, kind: string, callback?: (accessor: IAccessor) => void) => {\n            if (attributes[attribute] == undefined) {\n                return;\n            }\n\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n                babylonMesh._delayInfo.push(kind);\n            }\n\n            const accessor = ArrayItem.Get(`${context}/attributes/${attribute}`, this._gltf.accessors, attributes[attribute]);\n            promises.push(this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\n                if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\n                    const mmin = accessor.min as [number, number, number], mmax = accessor.max as [number, number, number];\n                    if (mmin !== undefined && mmax !== undefined) {\n                        const min = TmpVectors.Vector3[0], max = TmpVectors.Vector3[1];\n                        min.copyFromFloats(...mmin);\n                        max.copyFromFloats(...mmax);\n                        babylonGeometry._boundingInfo = new BoundingInfo(min, max);\n                        babylonGeometry.useBoundingInfoFromGeometry = true;\n                    }\n                }\n                babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\n            }));\n\n            if (kind == VertexBuffer.MatricesIndicesExtraKind) {\n                babylonMesh.numBoneInfluencers = 8;\n            }\n\n            if (callback) {\n                callback(accessor);\n            }\n        };\n\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n        loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\n        loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\n            if (accessor.type === AccessorType.VEC4) {\n                babylonMesh.hasVertexAlpha = true;\n            }\n        });\n\n        return Promise.all(promises).then(() => {\n            return babylonGeometry;\n        });\n    }\n\n    private _createMorphTargets(context: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, babylonMesh: Mesh): void {\n        if (!primitive.targets) {\n            return;\n        }\n\n        if (node._numMorphTargets == undefined) {\n            node._numMorphTargets = primitive.targets.length;\n        }\n        else if (primitive.targets.length !== node._numMorphTargets) {\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\n        }\n\n        const targetNames = mesh.extras ? mesh.extras.targetNames : null;\n\n        babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());\n        for (let index = 0; index < primitive.targets.length; index++) {\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\n            const name = targetNames ? targetNames[index] : `morphTarget${index}`;\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));\n            // TODO: tell the target whether it has positions, normals, tangents\n        }\n    }\n\n    private _loadMorphTargetsAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh, babylonGeometry: Geometry): Promise<void> {\n        if (!primitive.targets) {\n            return Promise.resolve();\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        const morphTargetManager = babylonMesh.morphTargetManager!;\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    private _loadMorphTargetVertexDataAsync(context: string, babylonGeometry: Geometry, attributes: { [name: string]: number }, babylonMorphTarget: MorphTarget): Promise<void> {\n        const promises = new Array<Promise<any>>();\n\n        const loadAttribute = (attribute: string, kind: string, setData: (babylonVertexBuffer: VertexBuffer, data: Float32Array) => void) => {\n            if (attributes[attribute] == undefined) {\n                return;\n            }\n\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\n            if (!babylonVertexBuffer) {\n                return;\n            }\n\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);\n            promises.push(this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                setData(babylonVertexBuffer, data);\n            }));\n        };\n\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\n            const positions = new Float32Array(data.length);\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\n                positions[index] = data[index] + value;\n            });\n\n            babylonMorphTarget.setPositions(positions);\n        });\n\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\n            const normals = new Float32Array(data.length);\n            babylonVertexBuffer.forEach(normals.length, (value, index) => {\n                normals[index] = data[index] + value;\n            });\n\n            babylonMorphTarget.setNormals(normals);\n        });\n\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\n            const tangents = new Float32Array(data.length / 3 * 4);\n            let dataIndex = 0;\n            babylonVertexBuffer.forEach(data.length / 3 * 4, (value, index) => {\n                // Tangent data for morph targets is stored as xyz delta.\n                // The vertexData.tangent is stored as xyzw.\n                // So we need to skip every fourth vertexData.tangent.\n                if (((index + 1) % 4) !== 0) {\n                    tangents[dataIndex] = data[dataIndex] + value;\n                    dataIndex++;\n                }\n            });\n            babylonMorphTarget.setTangents(tangents);\n        });\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    private static _LoadTransform(node: INode, babylonNode: TransformNode): void {\n        // Ignore the TRS of skinned nodes.\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n        if (node.skin != undefined) {\n            return;\n        }\n\n        let position = Vector3.Zero();\n        let rotation = Quaternion.Identity();\n        let scaling = Vector3.One();\n\n        if (node.matrix) {\n            const matrix = Matrix.FromArray(node.matrix);\n            matrix.decompose(scaling, rotation, position);\n        }\n        else {\n            if (node.translation) { position = Vector3.FromArray(node.translation); }\n            if (node.rotation) { rotation = Quaternion.FromArray(node.rotation); }\n            if (node.scale) { scaling = Vector3.FromArray(node.scale); }\n        }\n\n        babylonNode.position = position;\n        babylonNode.rotationQuaternion = rotation;\n        babylonNode.scaling = scaling;\n    }\n\n    private _loadSkinAsync(context: string, node: INode, skin: ISkin): Promise<void> {\n        const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const assignSkeleton = (skeleton: Skeleton) => {\n            this._forEachPrimitive(node, (babylonMesh) => {\n                babylonMesh.skeleton = skeleton;\n            });\n        };\n\n        if (skin._data) {\n            assignSkeleton(skin._data.babylonSkeleton);\n            return skin._data.promise;\n        }\n\n        const skeletonId = `skeleton${skin.index}`;\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\n        this._babylonScene._blockEntityCollection = false;\n\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n        babylonSkeleton.overrideMesh = this._rootBabylonMesh;\n\n        this._loadBones(context, skin, babylonSkeleton);\n        assignSkeleton(babylonSkeleton);\n\n        const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\n        });\n\n        skin._data = {\n            babylonSkeleton: babylonSkeleton,\n            promise: promise\n        };\n\n        return promise;\n    }\n\n    private _loadBones(context: string, skin: ISkin, babylonSkeleton: Skeleton): void {\n        const babylonBones: { [index: number]: Bone } = {};\n        for (const index of skin.joints) {\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);\n            this._loadBone(node, skin, babylonSkeleton, babylonBones);\n        }\n    }\n\n    private _loadBone(node: INode, skin: ISkin, babylonSkeleton: Skeleton, babylonBones: { [index: number]: Bone }): Bone {\n        let babylonBone = babylonBones[node.index];\n        if (babylonBone) {\n            return babylonBone;\n        }\n\n        let babylonParentBone: Nullable<Bone> = null;\n        if (node.parent && node.parent._babylonTransformNode !== this._rootBabylonMesh) {\n            babylonParentBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\n        }\n\n        const boneIndex = skin.joints.indexOf(node.index);\n\n        babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, babylonParentBone, this._getNodeMatrix(node), null, null, boneIndex);\n        babylonBones[node.index] = babylonBone;\n\n        node._babylonBones = node._babylonBones || [];\n        node._babylonBones.push(babylonBone);\n\n        return babylonBone;\n    }\n\n    private _loadSkinInverseBindMatricesDataAsync(context: string, skin: ISkin): Promise<Nullable<Float32Array>> {\n        if (skin.inverseBindMatrices == undefined) {\n            return Promise.resolve(null);\n        }\n\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);\n        return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);\n    }\n\n    private _updateBoneMatrices(babylonSkeleton: Skeleton, inverseBindMatricesData: Nullable<Float32Array>): void {\n        for (const babylonBone of babylonSkeleton.bones) {\n            let baseMatrix = Matrix.Identity();\n            const boneIndex = babylonBone._index!;\n            if (inverseBindMatricesData && boneIndex !== -1) {\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\n                baseMatrix.invertToRef(baseMatrix);\n            }\n\n            const babylonParentBone = babylonBone.getParent();\n            if (babylonParentBone) {\n                baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\n            }\n\n            babylonBone.setBindPose(baseMatrix);\n\n            babylonBone.updateMatrix(baseMatrix, false, false);\n            babylonBone._updateDifferenceMatrix(undefined, false);\n        }\n    }\n\n    private _getNodeMatrix(node: INode): Matrix {\n        return node.matrix ?\n            Matrix.FromArray(node.matrix) :\n            Matrix.Compose(\n                node.scale ? Vector3.FromArray(node.scale) : Vector3.One(),\n                node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(),\n                node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());\n    }\n\n    /**\n     * Loads a glTF camera.\n     * @param context The context when loading the asset\n     * @param camera The glTF camera property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\n     */\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void = () => { }): Promise<Camera> {\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        this.logOpen(`${context} ${camera.name || \"\"}`);\n\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);\n        this._babylonScene._blockEntityCollection = false;\n        babylonCamera.ignoreParentScaling = true;\n\n        babylonCamera.rotation = new Vector3(0, Math.PI, 0);\n\n        switch (camera.type) {\n            case CameraType.PERSPECTIVE: {\n                const perspective = camera.perspective;\n                if (!perspective) {\n                    throw new Error(`${context}: Camera perspective properties are missing`);\n                }\n\n                babylonCamera.fov = perspective.yfov;\n                babylonCamera.minZ = perspective.znear;\n                babylonCamera.maxZ = perspective.zfar || Number.MAX_VALUE;\n                break;\n            }\n            case CameraType.ORTHOGRAPHIC: {\n                if (!camera.orthographic) {\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\n                }\n\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\n                babylonCamera.orthoRight = camera.orthographic.xmag;\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\n                babylonCamera.orthoTop = camera.orthographic.ymag;\n                babylonCamera.minZ = camera.orthographic.znear;\n                babylonCamera.maxZ = camera.orthographic.zfar;\n                break;\n            }\n            default: {\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\n            }\n        }\n\n        GLTFLoader.AddPointerMetadata(babylonCamera, context);\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\n        assign(babylonCamera);\n\n        this.logClose();\n\n        return Promise.all(promises).then(() => {\n            return babylonCamera;\n        });\n    }\n\n    private _loadAnimationsAsync(): Promise<void> {\n        const animations = this._gltf.animations;\n        if (!animations) {\n            return Promise.resolve();\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        for (let index = 0; index < animations.length; index++) {\n            const animation = animations[index];\n            promises.push(this.loadAnimationAsync(`/animations/${animation.index}`, animation));\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    /**\n     * Loads a glTF animation.\n     * @param context The context when loading the asset\n     * @param animation The glTF animation property\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\n     */\n    public loadAnimationAsync(context: string, animation: IAnimation): Promise<AnimationGroup> {\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\n        if (promise) {\n            return promise;\n        }\n\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);\n        this._babylonScene._blockEntityCollection = false;\n        animation._babylonAnimationGroup = babylonAnimationGroup;\n\n        const promises = new Array<Promise<any>>();\n\n        ArrayItem.Assign(animation.channels);\n        ArrayItem.Assign(animation.samplers);\n\n        for (const channel of animation.channels) {\n            promises.push(this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, babylonAnimationGroup));\n        }\n\n        return Promise.all(promises).then(() => {\n            babylonAnimationGroup.normalize(0);\n            return babylonAnimationGroup;\n        });\n    }\n\n    /**\n     * @hidden Loads a glTF animation channel.\n     * @param context The context when loading the asset\n     * @param animationContext The context of the animation when loading the asset\n     * @param animation The glTF animation property\n     * @param channel The glTF animation channel property\n     * @param babylonAnimationGroup The babylon animation group property\n     * @param animationTargetOverride The babylon animation channel target override property. My be null.\n     * @returns A void promise when the channel load is complete\n     */\n    public _loadAnimationChannelAsync(context: string, animationContext: string, animation: IAnimation, channel: IAnimationChannel, babylonAnimationGroup: AnimationGroup, animationTargetOverride: Nullable<IAnimatable> = null): Promise<void> {\n        if (channel.target.node == undefined) {\n            return Promise.resolve();\n        }\n\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);\n\n        // Ignore animations that have no animation targets.\n        if ((channel.target.path === AnimationChannelTargetPath.WEIGHTS && !targetNode._numMorphTargets) ||\n            (channel.target.path !== AnimationChannelTargetPath.WEIGHTS && !targetNode._babylonTransformNode)) {\n            return Promise.resolve();\n        }\n\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\n            let targetPath: string;\n            let animationType: number;\n            switch (channel.target.path) {\n                case AnimationChannelTargetPath.TRANSLATION: {\n                    targetPath = \"position\";\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\n                    break;\n                }\n                case AnimationChannelTargetPath.ROTATION: {\n                    targetPath = \"rotationQuaternion\";\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\n                    break;\n                }\n                case AnimationChannelTargetPath.SCALE: {\n                    targetPath = \"scaling\";\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\n                    break;\n                }\n                case AnimationChannelTargetPath.WEIGHTS: {\n                    targetPath = \"influence\";\n                    animationType = Animation.ANIMATIONTYPE_FLOAT;\n                    break;\n                }\n                default: {\n                    throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\n                }\n            }\n\n            let outputBufferOffset = 0;\n            let getNextOutputValue: () => Vector3 | Quaternion | Array<number>;\n            switch (targetPath) {\n                case \"position\": {\n                    getNextOutputValue = () => {\n                        const value = Vector3.FromArray(data.output, outputBufferOffset);\n                        outputBufferOffset += 3;\n                        return value;\n                    };\n                    break;\n                }\n                case \"rotationQuaternion\": {\n                    getNextOutputValue = () => {\n                        const value = Quaternion.FromArray(data.output, outputBufferOffset);\n                        outputBufferOffset += 4;\n                        return value;\n                    };\n                    break;\n                }\n                case \"scaling\": {\n                    getNextOutputValue = () => {\n                        const value = Vector3.FromArray(data.output, outputBufferOffset);\n                        outputBufferOffset += 3;\n                        return value;\n                    };\n                    break;\n                }\n                case \"influence\": {\n                    getNextOutputValue = () => {\n                        const value = new Array<number>(targetNode._numMorphTargets!);\n                        for (let i = 0; i < targetNode._numMorphTargets!; i++) {\n                            value[i] = data.output[outputBufferOffset++];\n                        }\n                        return value;\n                    };\n                    break;\n                }\n            }\n\n            let getNextKey: (frameIndex: number) => IAnimationKey;\n            switch (data.interpolation) {\n                case AnimationSamplerInterpolation.STEP: {\n                    getNextKey = (frameIndex) => ({\n                        frame: data.input[frameIndex],\n                        value: getNextOutputValue(),\n                        interpolation: AnimationKeyInterpolation.STEP\n                    });\n                    break;\n                }\n                case AnimationSamplerInterpolation.LINEAR: {\n                    getNextKey = (frameIndex) => ({\n                        frame: data.input[frameIndex],\n                        value: getNextOutputValue()\n                    });\n                    break;\n                }\n                case AnimationSamplerInterpolation.CUBICSPLINE: {\n                    getNextKey = (frameIndex) => ({\n                        frame: data.input[frameIndex],\n                        inTangent: getNextOutputValue(),\n                        value: getNextOutputValue(),\n                        outTangent: getNextOutputValue()\n                    });\n                    break;\n                }\n            }\n\n            const keys = new Array(data.input.length);\n            for (let frameIndex = 0; frameIndex < data.input.length; frameIndex++) {\n                keys[frameIndex] = getNextKey!(frameIndex);\n            }\n\n            if (targetPath === \"influence\") {\n                for (let targetIndex = 0; targetIndex < targetNode._numMorphTargets!; targetIndex++) {\n                    const animationName = `${babylonAnimationGroup.name}_channel${babylonAnimationGroup.targetedAnimations.length}`;\n                    const babylonAnimation = new Animation(animationName, targetPath, 1, animationType);\n                    babylonAnimation.setKeys(keys.map((key) => ({\n                        frame: key.frame,\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\n                        value: key.value[targetIndex],\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined\n                    })));\n\n                    this._forEachPrimitive(targetNode, (babylonAbstractMesh: AbstractMesh) => {\n                        const babylonMesh = babylonAbstractMesh as Mesh;\n                        const morphTarget = babylonMesh.morphTargetManager!.getTarget(targetIndex);\n                        const babylonAnimationClone = babylonAnimation.clone();\n                        morphTarget.animations.push(babylonAnimationClone);\n                        babylonAnimationGroup.addTargetedAnimation(babylonAnimationClone, morphTarget);\n                    });\n                }\n            }\n            else {\n                const animationName = `${babylonAnimationGroup.name}_channel${babylonAnimationGroup.targetedAnimations.length}`;\n                const babylonAnimation = new Animation(animationName, targetPath, 1, animationType);\n                babylonAnimation.setKeys(keys);\n\n                if (animationTargetOverride != null && animationTargetOverride.animations != null) {\n                    animationTargetOverride.animations.push(babylonAnimation);\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, animationTargetOverride);\n                } else {\n                    targetNode._babylonTransformNode!.animations.push(babylonAnimation);\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, targetNode._babylonTransformNode!);\n                }\n            }\n        });\n    }\n\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSampler): Promise<_IAnimationSamplerData> {\n        if (sampler._data) {\n            return sampler._data;\n        }\n\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\n        switch (interpolation) {\n            case AnimationSamplerInterpolation.STEP:\n            case AnimationSamplerInterpolation.LINEAR:\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\n                break;\n            }\n            default: {\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\n            }\n        }\n\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);\n        sampler._data = Promise.all([\n            this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),\n            this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor)\n        ]).then(([inputData, outputData]) => {\n            return {\n                input: inputData,\n                interpolation: interpolation,\n                output: outputData,\n            };\n        });\n\n        return sampler._data;\n    }\n\n    private _loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Promise<ArrayBufferView> {\n        const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        if (!buffer._data) {\n            if (buffer.uri) {\n                buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);\n            }\n            else {\n                if (!this._bin) {\n                    throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\n                }\n\n                buffer._data = this._bin.readAsync(0, buffer.byteLength);\n            }\n        }\n\n        return buffer._data.then((data) => {\n            try {\n                return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\n            }\n            catch (e) {\n                throw new Error(`${context}: ${e.message}`);\n            }\n        });\n    }\n\n    /**\n     * Loads a glTF buffer view.\n     * @param context The context when loading the asset\n     * @param bufferView The glTF buffer view property\n     * @returns A promise that resolves with the loaded data when the load is complete\n     */\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Promise<ArrayBufferView> {\n        const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        if (bufferView._data) {\n            return bufferView._data;\n        }\n\n        const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);\n        bufferView._data = this._loadBufferAsync(`/buffers/${buffer.index}`, buffer, (bufferView.byteOffset || 0), bufferView.byteLength);\n\n        return bufferView._data;\n    }\n\n    private _loadAccessorAsync(context: string, accessor: IAccessor, constructor: TypedArrayConstructor): Promise<ArrayBufferView> {\n        if (accessor._data) {\n            return accessor._data;\n        }\n\n        const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\n        const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\n        const length = numComponents * accessor.count;\n\n        if (accessor.bufferView == undefined) {\n            accessor._data = Promise.resolve(new constructor(length));\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\n                if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {\n                    return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\n                }\n                else {\n                    const typedArray = new constructor(length);\n                    VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView.byteStride || byteStride, numComponents, accessor.componentType, typedArray.length, accessor.normalized || false, (value, index) => {\n                        typedArray[index] = value;\n                    });\n                    return typedArray;\n                }\n            });\n        }\n\n        if (accessor.sparse) {\n            const sparse = accessor.sparse;\n            accessor._data = accessor._data.then((data) => {\n                const typedArray = data as TypedArrayLike;\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);\n                return Promise.all([\n                    this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),\n                    this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView)\n                ]).then(([indicesData, valuesData]) => {\n                    const indices = GLTFLoader._GetTypedArray(`${context}/sparse/indices`, sparse.indices.componentType, indicesData, sparse.indices.byteOffset, sparse.count) as IndicesArray;\n\n                    const sparseLength = numComponents * sparse.count;\n                    let values: TypedArrayLike;\n\n                    if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized) {\n                        values = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\n                    }\n                    else {\n                        const sparseData = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\n                        values = new constructor(sparseLength);\n                        VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {\n                            values[index] = value;\n                        });\n                    }\n\n                    let valuesIndex = 0;\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\n                        let dataIndex = indices[indicesIndex] * numComponents;\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\n                            typedArray[dataIndex++] = values[valuesIndex++];\n                        }\n                    }\n\n                    return typedArray;\n                });\n            });\n        }\n\n        return accessor._data;\n    }\n\n    /** @hidden */\n    public _loadFloatAccessorAsync(context: string, accessor: IAccessor): Promise<Float32Array> {\n        return this._loadAccessorAsync(context, accessor, Float32Array) as Promise<Float32Array>;\n    }\n\n    private _loadIndicesAccessorAsync(context: string, accessor: IAccessor): Promise<IndicesArray> {\n        if (accessor.type !== AccessorType.SCALAR) {\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\n        }\n\n        if (accessor.componentType !== AccessorComponentType.UNSIGNED_BYTE &&\n            accessor.componentType !== AccessorComponentType.UNSIGNED_SHORT &&\n            accessor.componentType !== AccessorComponentType.UNSIGNED_INT) {\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\n        }\n\n        if (accessor._data) {\n            return accessor._data as Promise<IndicesArray>;\n        }\n\n        if (accessor.sparse) {\n            const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);\n            accessor._data = this._loadAccessorAsync(context, accessor, constructor);\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\n                return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\n            });\n        }\n\n        return accessor._data as Promise<IndicesArray>;\n    }\n\n    private _loadVertexBufferViewAsync(bufferView: IBufferView, kind: string): Promise<Buffer> {\n        if (bufferView._babylonBuffer) {\n            return bufferView._babylonBuffer;\n        }\n\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\n            return new Buffer(this._babylonScene.getEngine(), data, false);\n        });\n\n        return bufferView._babylonBuffer;\n    }\n\n    private _loadVertexAccessorAsync(context: string, accessor: IAccessor, kind: string): Promise<VertexBuffer> {\n        if (accessor._babylonVertexBuffer) {\n            return accessor._babylonVertexBuffer;\n        }\n\n        if (accessor.sparse) {\n            accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                return new VertexBuffer(this._babylonScene.getEngine(), data, kind, false);\n            });\n        }\n        // HACK: If byte offset is not a multiple of component type byte length then load as a float array instead of using Babylon buffers.\n        else if (accessor.byteOffset && accessor.byteOffset % VertexBuffer.GetTypeByteLength(accessor.componentType) !== 0) {\n            Logger.Warn(\"Accessor byte offset is not a multiple of component type byte length\");\n            accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                return new VertexBuffer(this._babylonScene.getEngine(), data, kind, false);\n            });\n        }\n        // Load joint indices as a float array since the shaders expect float data but glTF uses unsigned byte/short.\n        // This prevents certain platforms (e.g. D3D) from having to convert the data to float on the fly.\n        else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {\n            accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                return new VertexBuffer(this._babylonScene.getEngine(), data, kind, false);\n            });\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n            accessor._babylonVertexBuffer = this._loadVertexBufferViewAsync(bufferView, kind).then((babylonBuffer) => {\n                const size = GLTFLoader._GetNumComponents(context, accessor.type);\n                return new VertexBuffer(this._babylonScene.getEngine(), babylonBuffer, kind, false, false, bufferView.byteStride,\n                    false, accessor.byteOffset, size, accessor.componentType, accessor.normalized, true, 1, true);\n            });\n        }\n\n        return accessor._babylonVertexBuffer;\n    }\n\n    private _loadMaterialMetallicRoughnessPropertiesAsync(context: string, properties: IMaterialPbrMetallicRoughness, babylonMaterial: Material): Promise<void> {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        if (properties) {\n            if (properties.baseColorFactor) {\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\n                babylonMaterial.alpha = properties.baseColorFactor[3];\n            }\n            else {\n                babylonMaterial.albedoColor = Color3.White();\n            }\n\n            babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\n            babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\n\n            if (properties.baseColorTexture) {\n                promises.push(this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\n                    texture.name = `${babylonMaterial.name} (Base Color)`;\n                    babylonMaterial.albedoTexture = texture;\n                }));\n            }\n\n            if (properties.metallicRoughnessTexture) {\n                properties.metallicRoughnessTexture.nonColorData = true;\n                promises.push(this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\n                    texture.name = `${babylonMaterial.name} (Metallic Roughness)`;\n                    babylonMaterial.metallicTexture = texture;\n                }));\n\n                babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\n                babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\n                babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\n            }\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    /** @hidden */\n    public _loadMaterialAsync(context: string, material: IMaterial, babylonMesh: Nullable<Mesh>, babylonDrawMode: number, assign: (babylonMaterial: Material) => void = () => { }): Promise<Material> {\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        material._data = material._data || {};\n        let babylonData = material._data[babylonDrawMode];\n        if (!babylonData) {\n            this.logOpen(`${context} ${material.name || \"\"}`);\n\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\n\n            babylonData = {\n                babylonMaterial: babylonMaterial,\n                babylonMeshes: [],\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)\n            };\n\n            material._data[babylonDrawMode] = babylonData;\n\n            GLTFLoader.AddPointerMetadata(babylonMaterial, context);\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n\n            this.logClose();\n        }\n\n        if (babylonMesh) {\n            babylonData.babylonMeshes.push(babylonMesh);\n\n            babylonMesh.onDisposeObservable.addOnce(() => {\n                const index = babylonData.babylonMeshes.indexOf(babylonMesh);\n                if (index !== -1) {\n                    babylonData.babylonMeshes.splice(index, 1);\n                }\n            });\n        }\n\n        assign(babylonData.babylonMaterial);\n\n        return babylonData.promise.then(() => {\n            return babylonData.babylonMaterial;\n        });\n    }\n\n    private _createDefaultMaterial(name: string, babylonDrawMode: number): Material {\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        const babylonMaterial = new PBRMaterial(name, this._babylonScene);\n        this._babylonScene._blockEntityCollection = false;\n        // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n        babylonMaterial.fillMode = babylonDrawMode;\n        babylonMaterial.enableSpecularAntiAliasing = true;\n        babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\n        babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\n        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n        babylonMaterial.metallic = 1;\n        babylonMaterial.roughness = 1;\n        return babylonMaterial;\n    }\n\n    /**\n     * Creates a Babylon material from a glTF material.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonDrawMode The draw mode for the Babylon material\n     * @returns The Babylon material\n     */\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Material {\n        const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const name = material.name || `material${material.index}`;\n        const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\n\n        return babylonMaterial;\n    }\n\n    /**\n     * Loads properties from a glTF material into a Babylon material.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonMaterial The Babylon material\n     * @returns A promise that resolves when the load is complete\n     */\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n\n        if (material.pbrMetallicRoughness) {\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\n        }\n\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    /**\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonMaterial The Babylon material\n     * @returns A promise that resolves when the load is complete\n     */\n    public loadMaterialBasePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\n        if (material.doubleSided) {\n            babylonMaterial.backFaceCulling = false;\n            babylonMaterial.twoSidedLighting = true;\n        }\n\n        if (material.normalTexture) {\n            material.normalTexture.nonColorData = true;\n            promises.push(this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Normal)`;\n                babylonMaterial.bumpTexture = texture;\n            }));\n\n            babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\n            babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\n            if (material.normalTexture.scale != undefined) {\n                babylonMaterial.bumpTexture.level = material.normalTexture.scale;\n            }\n\n            babylonMaterial.forceIrradianceInFragment = true;\n        }\n\n        if (material.occlusionTexture) {\n            material.occlusionTexture.nonColorData = true;\n            promises.push(this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Occlusion)`;\n                babylonMaterial.ambientTexture = texture;\n            }));\n\n            babylonMaterial.useAmbientInGrayScale = true;\n            if (material.occlusionTexture.strength != undefined) {\n                babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\n            }\n        }\n\n        if (material.emissiveTexture) {\n            promises.push(this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Emissive)`;\n                babylonMaterial.emissiveTexture = texture;\n            }));\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    /**\n     * Loads the alpha properties from a glTF material into a Babylon material.\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonMaterial The Babylon material\n     */\n    public loadMaterialAlphaProperties(context: string, material: IMaterial, babylonMaterial: Material): void {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        const alphaMode = material.alphaMode || MaterialAlphaMode.OPAQUE;\n        switch (alphaMode) {\n            case MaterialAlphaMode.OPAQUE: {\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n                break;\n            }\n            case MaterialAlphaMode.MASK: {\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\n                babylonMaterial.alphaCutOff = (material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff);\n                if (babylonMaterial.albedoTexture) {\n                    babylonMaterial.albedoTexture.hasAlpha = true;\n                }\n                break;\n            }\n            case MaterialAlphaMode.BLEND: {\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\n                if (babylonMaterial.albedoTexture) {\n                    babylonMaterial.albedoTexture.hasAlpha = true;\n                    babylonMaterial.useAlphaFromAlbedoTexture = true;\n                }\n                break;\n            }\n            default: {\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\n            }\n        }\n    }\n\n    /**\n     * Loads a glTF texture info.\n     * @param context The context when loading the asset\n     * @param textureInfo The glTF texture info property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\n     */\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void = () => { }): Promise<BaseTexture> {\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        this.logOpen(`${context}`);\n\n        if (textureInfo.texCoord! >= 2) {\n            throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);\n        }\n\n        const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);\n        texture._textureInfo = textureInfo;\n\n        const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\n            GLTFLoader.AddPointerMetadata(babylonTexture, context);\n            this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\n            assign(babylonTexture);\n        });\n\n        this.logClose();\n\n        return promise;\n    }\n\n    /** @hidden */\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void = () => { }): Promise<BaseTexture> {\n        const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        this.logOpen(`${context} ${texture.name || \"\"}`);\n\n        const sampler = (texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler));\n        const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);\n        const promise = this._createTextureAsync(context, sampler, image, assign);\n\n        this.logClose();\n\n        return promise;\n    }\n\n    /** @hidden */\n    public _createTextureAsync(context: string, sampler: ISampler, image: IImage, assign: (babylonTexture: BaseTexture) => void = () => { }, textureLoaderOptions?: any): Promise<BaseTexture> {\n        const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);\n\n        const promises = new Array<Promise<any>>();\n\n        const deferred = new Deferred<void>();\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        const babylonTexture = new Texture(null, this._babylonScene, samplerData.noMipMaps, false, samplerData.samplingMode, () => {\n            if (!this._disposed) {\n                deferred.resolve();\n            }\n        }, (message, exception) => {\n            if (!this._disposed) {\n                deferred.reject(new Error(`${context}: ${(exception && exception.message) ? exception.message : message || \"Failed to load texture\"}`));\n            }\n        }, undefined, undefined, undefined, image.mimeType, textureLoaderOptions);\n        this._babylonScene._blockEntityCollection = false;\n        promises.push(deferred.promise);\n\n        promises.push(this.loadImageAsync(`/images/${image.index}`, image).then((data) => {\n            const name = image.uri || `${this._fileName}#image${image.index}`;\n            const dataUrl = `data:${this._uniqueRootUrl}${name}`;\n            babylonTexture.updateURL(dataUrl, data);\n        }));\n\n        babylonTexture.wrapU = samplerData.wrapU;\n        babylonTexture.wrapV = samplerData.wrapV;\n        assign(babylonTexture);\n\n        return Promise.all(promises).then(() => {\n            return babylonTexture;\n        });\n    }\n\n    private _loadSampler(context: string, sampler: ISampler): _ISamplerData {\n        if (!sampler._data) {\n            sampler._data = {\n                noMipMaps: (sampler.minFilter === TextureMinFilter.NEAREST || sampler.minFilter === TextureMinFilter.LINEAR),\n                samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\n                wrapU: GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\n                wrapV: GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT)\n            };\n        }\n\n        return sampler._data;\n    }\n\n    /**\n     * Loads a glTF image.\n     * @param context The context when loading the asset\n     * @param image The glTF image property\n     * @returns A promise that resolves with the loaded data when the load is complete\n     */\n    public loadImageAsync(context: string, image: IImage): Promise<ArrayBufferView> {\n        if (!image._data) {\n            this.logOpen(`${context} ${image.name || \"\"}`);\n\n            if (image.uri) {\n                image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);\n            }\n            else {\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);\n                image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\n            }\n\n            this.logClose();\n        }\n\n        return image._data;\n    }\n\n    /**\n     * Loads a glTF uri.\n     * @param context The context when loading the asset\n     * @param property The glTF property associated with the uri\n     * @param uri The base64 or relative uri\n     * @returns A promise that resolves with the loaded data when the load is complete\n     */\n    public loadUriAsync(context: string, property: IProperty, uri: string): Promise<ArrayBufferView> {\n        const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        if (!GLTFLoader._ValidateUri(uri)) {\n            throw new Error(`${context}: '${uri}' is invalid`);\n        }\n\n        if (Tools.IsBase64(uri)) {\n            const data = new Uint8Array(Tools.DecodeBase64(uri));\n            this.log(`Decoded ${uri.substr(0, 64)}... (${data.length} bytes)`);\n            return Promise.resolve(data);\n        }\n\n        this.log(`Loading ${uri}`);\n\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\n            return new Promise((resolve, reject) => {\n                this._parent._loadFile(url, this._babylonScene, (data) => {\n                    if (!this._disposed) {\n                        this.log(`Loaded ${uri} (${(data as ArrayBuffer).byteLength} bytes)`);\n                        resolve(new Uint8Array(data as ArrayBuffer));\n                    }\n                }, true, (request) => {\n                    reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\n                });\n            });\n        });\n    }\n\n    /**\n     * Adds a JSON pointer to the metadata of the Babylon object at `<object>.metadata.gltf.pointers`.\n     * @param babylonObject the Babylon object with metadata\n     * @param pointer the JSON pointer\n     */\n    public static AddPointerMetadata(babylonObject: { metadata: any }, pointer: string): void {\n        const metadata = (babylonObject.metadata = babylonObject.metadata || {});\n        const gltf = (metadata.gltf = metadata.gltf || {});\n        const pointers = (gltf.pointers = gltf.pointers || []);\n        pointers.push(pointer);\n    }\n\n    private static _GetTextureWrapMode(context: string, mode: TextureWrapMode | undefined): number {\n        // Set defaults if undefined\n        mode = mode == undefined ? TextureWrapMode.REPEAT : mode;\n\n        switch (mode) {\n            case TextureWrapMode.CLAMP_TO_EDGE: return Texture.CLAMP_ADDRESSMODE;\n            case TextureWrapMode.MIRRORED_REPEAT: return Texture.MIRROR_ADDRESSMODE;\n            case TextureWrapMode.REPEAT: return Texture.WRAP_ADDRESSMODE;\n            default:\n                Logger.Warn(`${context}: Invalid value (${mode})`);\n                return Texture.WRAP_ADDRESSMODE;\n        }\n    }\n\n    private static _GetTextureSamplingMode(context: string, sampler: ISampler): number {\n        // Set defaults if undefined\n        const magFilter = sampler.magFilter == undefined ? TextureMagFilter.LINEAR : sampler.magFilter;\n        const minFilter = sampler.minFilter == undefined ? TextureMinFilter.LINEAR_MIPMAP_LINEAR : sampler.minFilter;\n\n        if (magFilter === TextureMagFilter.LINEAR) {\n            switch (minFilter) {\n                case TextureMinFilter.NEAREST: return Texture.LINEAR_NEAREST;\n                case TextureMinFilter.LINEAR: return Texture.LINEAR_LINEAR;\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST: return Texture.LINEAR_NEAREST_MIPNEAREST;\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST: return Texture.LINEAR_LINEAR_MIPNEAREST;\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR: return Texture.LINEAR_NEAREST_MIPLINEAR;\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR: return Texture.LINEAR_LINEAR_MIPLINEAR;\n                default:\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\n            }\n        }\n        else {\n            if (magFilter !== TextureMagFilter.NEAREST) {\n                Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\n            }\n\n            switch (minFilter) {\n                case TextureMinFilter.NEAREST: return Texture.NEAREST_NEAREST;\n                case TextureMinFilter.LINEAR: return Texture.NEAREST_LINEAR;\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST: return Texture.NEAREST_NEAREST_MIPNEAREST;\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST: return Texture.NEAREST_LINEAR_MIPNEAREST;\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR: return Texture.NEAREST_NEAREST_MIPLINEAR;\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR: return Texture.NEAREST_LINEAR_MIPLINEAR;\n                default:\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\n            }\n        }\n    }\n\n    private static _GetTypedArrayConstructor(context: string, componentType: AccessorComponentType): TypedArrayConstructor {\n        switch (componentType) {\n            case AccessorComponentType.BYTE: return Int8Array;\n            case AccessorComponentType.UNSIGNED_BYTE: return Uint8Array;\n            case AccessorComponentType.SHORT: return Int16Array;\n            case AccessorComponentType.UNSIGNED_SHORT: return Uint16Array;\n            case AccessorComponentType.UNSIGNED_INT: return Uint32Array;\n            case AccessorComponentType.FLOAT: return Float32Array;\n            default: throw new Error(`${context}: Invalid component type ${componentType}`);\n        }\n}\n\n    private static _GetTypedArray(context: string, componentType: AccessorComponentType, bufferView: ArrayBufferView, byteOffset: number | undefined, length: number): TypedArrayLike {\n        const buffer = bufferView.buffer;\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\n\n        const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);\n\n        try {\n            return new constructor(buffer, byteOffset, length);\n        }\n        catch (e) {\n            throw new Error(`${context}: ${e}`);\n        }\n    }\n\n    private static _GetNumComponents(context: string, type: string): number {\n        switch (type) {\n            case \"SCALAR\": return 1;\n            case \"VEC2\": return 2;\n            case \"VEC3\": return 3;\n            case \"VEC4\": return 4;\n            case \"MAT2\": return 4;\n            case \"MAT3\": return 9;\n            case \"MAT4\": return 16;\n        }\n\n        throw new Error(`${context}: Invalid type (${type})`);\n    }\n\n    private static _ValidateUri(uri: string): boolean {\n        return (Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1);\n    }\n\n    /** @hidden */\n    public static _GetDrawMode(context: string, mode: number | undefined): number {\n        if (mode == undefined) {\n            mode = MeshPrimitiveMode.TRIANGLES;\n        }\n\n        switch (mode) {\n            case MeshPrimitiveMode.POINTS: return Material.PointListDrawMode;\n            case MeshPrimitiveMode.LINES: return Material.LineListDrawMode;\n            case MeshPrimitiveMode.LINE_LOOP: return Material.LineLoopDrawMode;\n            case MeshPrimitiveMode.LINE_STRIP: return Material.LineStripDrawMode;\n            case MeshPrimitiveMode.TRIANGLES: return Material.TriangleFillMode;\n            case MeshPrimitiveMode.TRIANGLE_STRIP: return Material.TriangleStripDrawMode;\n            case MeshPrimitiveMode.TRIANGLE_FAN: return Material.TriangleFanDrawMode;\n        }\n\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\n    }\n\n    private _compileMaterialsAsync(): Promise<void> {\n        this._parent._startPerformanceCounter(\"Compile materials\");\n\n        const promises = new Array<Promise<any>>();\n\n        if (this._gltf.materials) {\n            for (const material of this._gltf.materials) {\n                if (material._data) {\n                    for (const babylonDrawMode in material._data) {\n                        const babylonData = material._data[babylonDrawMode];\n                        for (const babylonMesh of babylonData.babylonMeshes) {\n                            // Ensure nonUniformScaling is set if necessary.\n                            babylonMesh.computeWorldMatrix(true);\n\n                            const babylonMaterial = babylonData.babylonMaterial;\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));\n                            if (this._parent.useClipPlane) {\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return Promise.all(promises).then(() => {\n            this._parent._endPerformanceCounter(\"Compile materials\");\n        });\n    }\n\n    private _compileShadowGeneratorsAsync(): Promise<void> {\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\n\n        const promises = new Array<Promise<any>>();\n\n        const lights = this._babylonScene.lights;\n        for (let light of lights) {\n            let generator = light.getShadowGenerator();\n            if (generator) {\n                promises.push(generator.forceCompilationAsync());\n            }\n        }\n\n        return Promise.all(promises).then(() => {\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\n        });\n    }\n\n    private _forEachExtensions(action: (extension: IGLTFLoaderExtension) => void): void {\n        for (const extension of this._extensions) {\n            if (extension.enabled) {\n                action(extension);\n            }\n        }\n    }\n\n    private _applyExtensions<T>(property: IProperty, functionName: string, actionAsync: (extension: IGLTFLoaderExtension) => Nullable<T> | undefined): Nullable<T> {\n        for (const extension of this._extensions) {\n            if (extension.enabled) {\n                const id = `${extension.name}.${functionName}`;\n                const loaderProperty = property as ILoaderProperty;\n                loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\n                const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\n                if (!activeLoaderExtensionFunctions[id]) {\n                    activeLoaderExtensionFunctions[id] = true;\n\n                    try {\n                        const result = actionAsync(extension);\n                        if (result) {\n                            return result;\n                        }\n                    }\n                    finally {\n                        delete activeLoaderExtensionFunctions[id];\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    private _extensionsOnLoading(): void {\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\n    }\n\n    private _extensionsOnReady(): void {\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\n    }\n\n    private _extensionsLoadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\n        return this._applyExtensions(scene, \"loadScene\", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\n    }\n\n    private _extensionsLoadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\n        return this._applyExtensions(node, \"loadNode\", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\n    }\n\n    private _extensionsLoadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\n        return this._applyExtensions(camera, \"loadCamera\", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\n    }\n\n    private _extensionsLoadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\n        return this._applyExtensions(primitive, \"loadVertexData\", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\n    }\n\n    private _extensionsLoadMeshPrimitiveAsync(context: string, name: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, assign: (babylonMesh: AbstractMesh) => void): Nullable<Promise<AbstractMesh>> {\n        return this._applyExtensions(primitive, \"loadMeshPrimitive\", (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign));\n    }\n\n    private _extensionsLoadMaterialAsync(context: string, material: IMaterial, babylonMesh: Nullable<Mesh>, babylonDrawMode: number, assign: (babylonMaterial: Material) => void): Nullable<Promise<Material>> {\n        return this._applyExtensions(material, \"loadMaterial\", (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign));\n    }\n\n    private _extensionsCreateMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\n        return this._applyExtensions(material, \"createMaterial\", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\n    }\n\n    private _extensionsLoadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\n        return this._applyExtensions(material, \"loadMaterialProperties\", (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n    }\n\n    private _extensionsLoadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\n        return this._applyExtensions(textureInfo, \"loadTextureInfo\", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\n    }\n\n    private _extensionsLoadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\n        return this._applyExtensions(texture, \"loadTexture\", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));\n    }\n\n    private _extensionsLoadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\n        return this._applyExtensions(animation, \"loadAnimation\", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\n    }\n\n    private _extensionsLoadSkinAsync(context: string, node: INode, skin: ISkin): Nullable<Promise<void>> {\n        return this._applyExtensions(skin, \"loadSkin\", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));\n    }\n\n    private _extensionsLoadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\n        return this._applyExtensions(property, \"loadUri\", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));\n    }\n\n    private _extensionsLoadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\n        return this._applyExtensions(bufferView, \"loadBufferView\", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));\n    }\n\n    private _extensionsLoadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\n        return this._applyExtensions(buffer, \"loadBuffer\", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));\n    }\n\n    /**\n     * Helper method called by a loader extension to load an glTF extension.\n     * @param context The context when loading the asset\n     * @param property The glTF property to load the extension from\n     * @param extensionName The name of the extension to load\n     * @param actionAsync The action to run\n     * @returns The promise returned by actionAsync or null if the extension does not exist\n     */\n    public static LoadExtensionAsync<TExtension = any, TResult = void>(context: string, property: IProperty, extensionName: string, actionAsync: (extensionContext: string, extension: TExtension) => Nullable<Promise<TResult>>): Nullable<Promise<TResult>> {\n        if (!property.extensions) {\n            return null;\n        }\n\n        const extensions = property.extensions;\n\n        const extension = extensions[extensionName] as TExtension;\n        if (!extension) {\n            return null;\n        }\n\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\n    }\n\n    /**\n     * Helper method called by a loader extension to load a glTF extra.\n     * @param context The context when loading the asset\n     * @param property The glTF property to load the extra from\n     * @param extensionName The name of the extension to load\n     * @param actionAsync The action to run\n     * @returns The promise returned by actionAsync or null if the extra does not exist\n     */\n    public static LoadExtraAsync<TExtra = any, TResult = void>(context: string, property: IProperty, extensionName: string, actionAsync: (extraContext: string, extra: TExtra) => Nullable<Promise<TResult>>): Nullable<Promise<TResult>> {\n        if (!property.extras) {\n            return null;\n        }\n\n        const extras = property.extras;\n\n        const extra = extras[extensionName] as TExtra;\n        if (!extra) {\n            return null;\n        }\n\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\n    }\n\n    /**\n     * Checks for presence of an extension.\n     * @param name The name of the extension to check\n     * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\n     */\n    public isExtensionUsed(name: string): boolean {\n        return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\n    }\n\n    /**\n     * Increments the indentation level and logs a message.\n     * @param message The message to log\n     */\n    public logOpen(message: string): void {\n        this._parent._logOpen(message);\n    }\n\n    /**\n     * Decrements the indentation level.\n     */\n    public logClose(): void {\n        this._parent._logClose();\n    }\n\n    /**\n     * Logs a message\n     * @param message The message to log\n     */\n    public log(message: string): void {\n        this._parent._log(message);\n    }\n\n    /**\n     * Starts a performance counter.\n     * @param counterName The name of the performance counter\n     */\n    public startPerformanceCounter(counterName: string): void {\n        this._parent._startPerformanceCounter(counterName);\n    }\n\n    /**\n     * Ends a performance counter.\n     * @param counterName The name of the performance counter\n     */\n    public endPerformanceCounter(counterName: string): void {\n        this._parent._endPerformanceCounter(counterName);\n    }\n}\n\nGLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader(parent);\n"]}