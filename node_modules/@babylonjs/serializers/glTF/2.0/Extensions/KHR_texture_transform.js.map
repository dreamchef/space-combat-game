{"version":3,"file":"KHR_texture_transform.js","sourceRoot":"","sources":["../../../../../sourceES6/serializers/src/glTF/2.0/Extensions/KHR_texture_transform.ts"],"names":[],"mappings":"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","sourcesContent":["import { ImageMimeType, ITextureInfo } from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\n\r\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport { IKHRTextureTransform } from 'babylonjs-gltf2interface';\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\nimport \"../shaders/textureTransform.fragment\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class KHR_texture_transform implements IGLTFExporterExtensionV2 {\r\n    private _recordedTextures: ProceduralTexture[] = [];\r\n\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n    }\r\n\r\n    public dispose() {\r\n        for (var texture of this._recordedTextures) {\r\n            texture.dispose();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: Texture): void {\r\n        const canUseExtension = babylonTexture && ((babylonTexture.uAng === 0 && babylonTexture.wAng === 0 && babylonTexture.vAng === 0) || (babylonTexture.uRotationCenter === 0 && babylonTexture.vRotationCenter === 0));\r\n\r\n        if (canUseExtension) {\r\n            let textureTransform: IKHRTextureTransform = {};\r\n            let transformIsRequired = false;\r\n\r\n            if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n                textureTransform.offset = [babylonTexture.uOffset, babylonTexture.vOffset];\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n                textureTransform.scale = [babylonTexture.uScale, babylonTexture.vScale];\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.wAng !== 0) {\r\n                textureTransform.rotation = babylonTexture.wAng;\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.coordinatesIndex !== 0) {\r\n                textureTransform.texCoord = babylonTexture.coordinatesIndex;\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (!transformIsRequired) {\r\n                return;\r\n            }\r\n\r\n            this._wasUsed = true;\r\n            if (!textureInfo.extensions) {\r\n                textureInfo.extensions = {};\r\n            }\r\n            textureInfo.extensions[NAME] = textureTransform;\r\n        }\r\n    }\r\n\r\n    public preExportTextureAsync(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Promise<Texture> {\r\n        return new Promise((resolve, reject) => {\r\n            const scene = babylonTexture.getScene();\r\n            if (!scene) {\r\n                reject(`${context}: \"scene\" is not defined for Babylon texture ${babylonTexture.name}!`);\r\n                return;\r\n            }\r\n\r\n            let bakeTextureTransform = false;\r\n\r\n            /*\r\n            * The KHR_texture_transform schema only supports rotation around the origin.\r\n            * the texture must be baked to preserve appearance.\r\n            * see: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates\r\n            */\r\n            if ((babylonTexture.uAng !== 0 || babylonTexture.wAng !== 0 || babylonTexture.vAng !== 0) && (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0)) {\r\n                bakeTextureTransform = true;\r\n            }\r\n\r\n            if (!bakeTextureTransform) {\r\n                resolve(babylonTexture);\r\n                return;\r\n            }\r\n\r\n            return this._textureTransformTextureAsync(babylonTexture, scene)\r\n                .then((proceduralTexture) => {\r\n                    resolve(proceduralTexture);\r\n                })\r\n                .catch((e) => {\r\n                    reject(e);\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Transform the babylon texture by the offset, rotation and scale parameters using a procedural texture\r\n     * @param babylonTexture\r\n     * @param offset\r\n     * @param rotation\r\n     * @param scale\r\n     * @param scene\r\n     */\r\n    private _textureTransformTextureAsync(babylonTexture: Texture, scene: Scene): Promise<Texture> {\r\n        return new Promise((resolve) => {\r\n            const proceduralTexture = new ProceduralTexture(`${babylonTexture.name}`, babylonTexture.getSize(), \"textureTransform\", scene);\r\n            if (!proceduralTexture) {\r\n                Tools.Log(`Cannot create procedural texture for ${babylonTexture.name}!`);\r\n                resolve(babylonTexture);\r\n            }\r\n\r\n            proceduralTexture.reservedDataStore = {\r\n                hidden: true,\r\n                source: babylonTexture\r\n            };\r\n\r\n            this._recordedTextures.push(proceduralTexture);\r\n\r\n            proceduralTexture.coordinatesIndex = babylonTexture.coordinatesIndex;\r\n            proceduralTexture.setTexture(\"textureSampler\", babylonTexture);\r\n            proceduralTexture.setMatrix(\"textureTransformMat\", babylonTexture.getTextureMatrix());\r\n\r\n            // isReady trigger creation of effect if it doesnt exist yet\r\n            if (proceduralTexture.isReady()) {\r\n                proceduralTexture.render();\r\n                resolve(proceduralTexture);\r\n            } else {\r\n                proceduralTexture.getEffect().executeWhenCompiled(() => {\r\n                    proceduralTexture.render();\r\n                    resolve(proceduralTexture);\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_texture_transform(exporter));"]}