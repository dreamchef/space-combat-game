{"version":3,"file":"glTFMaterialExporter.js","sourceRoot":"","sources":["../../../../sourceES6/serializers/src/glTF/2.0/glTFMaterialExporter.ts"],"names":[],"mappings":"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","sourcesContent":["import { ITextureInfo, ImageMimeType, IMaterial, IMaterialPbrMetallicRoughness, MaterialAlphaMode, IMaterialOcclusionTextureInfo, ISampler, TextureMagFilter, TextureMinFilter, TextureWrapMode, ITexture, IImage } from \"babylonjs-gltf2interface\";\r\n\r\nimport { Nullable } from \"@babylonjs/core/types\";\r\nimport { Vector2 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { Scalar } from \"@babylonjs/core/Maths/math.scalar\";\r\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\r\nimport { TextureTools } from \"@babylonjs/core/Misc/textureTools\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { RawTexture } from \"@babylonjs/core/Materials/Textures/rawTexture\";\r\nimport { Material } from \"@babylonjs/core/Materials/material\";\r\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\r\nimport { PBRMetallicRoughnessMaterial } from \"@babylonjs/core/Materials/PBR/pbrMetallicRoughnessMaterial\";\r\nimport { PostProcess } from \"@babylonjs/core/PostProcesses/postProcess\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\n\r\nimport { _Exporter } from \"./glTFExporter\";\r\nimport { Constants } from '@babylonjs/core/Engines/constants';\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @hidden\r\n */\r\ninterface _IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n    */\r\n    diffuseColor: Color3;\r\n    /**\r\n     * Represents the linear specular factors of the material\r\n    */\r\n    specularColor: Color3;\r\n    /**\r\n     * Represents the smoothness of the material\r\n    */\r\n    glossiness: number;\r\n}\r\n\r\n/**\r\n * Interface for storing metallic roughness factors\r\n * @hidden\r\n */\r\ninterface _IPBRMetallicRoughness {\r\n    /**\r\n     * Represents the albedo color of the material\r\n    */\r\n    baseColor: Color3;\r\n    /**\r\n     * Represents the metallness of the material\r\n    */\r\n    metallic: Nullable<number>;\r\n    /**\r\n     * Represents the roughness of the material\r\n    */\r\n    roughness: Nullable<number>;\r\n    /**\r\n     * The metallic roughness texture as a base64 string\r\n    */\r\n    metallicRoughnessTextureBase64?: Nullable<string>;\r\n    /**\r\n     * The base color texture as a base64 string\r\n    */\r\n    baseColorTextureBase64?: Nullable<string>;\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.  This class should only be used internally\r\n * @hidden\r\n */\r\nexport class _GLTFMaterialExporter {\r\n    /**\r\n     * Represents the dielectric specular values for R, G and B\r\n     */\r\n    private static readonly _DielectricSpecular: Color3 = new Color3(0.04, 0.04, 0.04);\r\n\r\n    /**\r\n     * Allows the maximum specular power to be defined for material calculations\r\n     */\r\n    private static readonly _MaxSpecularPower = 1024;\r\n\r\n    /**\r\n     * Mapping to store textures\r\n     */\r\n    private _textureMap: { [textureId: string]: ITextureInfo } = {};\r\n\r\n    /**\r\n     * Numeric tolerance value\r\n     */\r\n    private static readonly _Epsilon = 1e-6;\r\n\r\n    /**\r\n     * Reference to the glTF Exporter\r\n     */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._textureMap = {};\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Specifies if two colors are approximately equal in value\r\n     * @param color1 first color to compare to\r\n     * @param color2 second color to compare to\r\n     * @param epsilon threshold value\r\n     */\r\n    private static FuzzyEquals(color1: Color3, color2: Color3, epsilon: number): boolean {\r\n        return Scalar.WithinEpsilon(color1.r, color2.r, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.g, color2.g, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.b, color2.b, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets the materials from a Babylon scene and converts them to glTF materials\r\n     * @param scene babylonjs scene\r\n     * @param mimeType texture mime type\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param materials array of materials\r\n     * @param imageData mapping of texture names to base64 textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the material\r\n     */\r\n    public _convertMaterialsToGLTFAsync(babylonMaterials: Material[], mimeType: ImageMimeType, hasTextureCoords: boolean) {\r\n        let promises: Promise<IMaterial>[] = [];\r\n        for (let babylonMaterial of babylonMaterials) {\r\n            if (babylonMaterial instanceof StandardMaterial) {\r\n                promises.push(this._convertStandardMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMetallicRoughnessMaterial) {\r\n                promises.push(this._convertPBRMetallicRoughnessMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMaterial) {\r\n                promises.push(this._convertPBRMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else {\r\n                Tools.Warn(`Unsupported material type: ${babylonMaterial.name}`);\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the glTF material without the texture parameters\r\n     * @param originalMaterial original glTF material\r\n     * @returns glTF material without texture parameters\r\n     */\r\n    public _stripTexturesFromMaterial(originalMaterial: IMaterial): IMaterial {\r\n        let newMaterial: IMaterial = {};\r\n        if (originalMaterial) {\r\n            newMaterial.name = originalMaterial.name;\r\n            newMaterial.doubleSided = originalMaterial.doubleSided;\r\n            newMaterial.alphaMode = originalMaterial.alphaMode;\r\n            newMaterial.alphaCutoff = originalMaterial.alphaCutoff;\r\n            newMaterial.emissiveFactor = originalMaterial.emissiveFactor;\r\n            const originalPBRMetallicRoughness = originalMaterial.pbrMetallicRoughness;\r\n            if (originalPBRMetallicRoughness) {\r\n                newMaterial.pbrMetallicRoughness = {};\r\n                newMaterial.pbrMetallicRoughness.baseColorFactor = originalPBRMetallicRoughness.baseColorFactor;\r\n                newMaterial.pbrMetallicRoughness.metallicFactor = originalPBRMetallicRoughness.metallicFactor;\r\n                newMaterial.pbrMetallicRoughness.roughnessFactor = originalPBRMetallicRoughness.roughnessFactor;\r\n            }\r\n        }\r\n        return newMaterial;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material has any texture parameters present\r\n     * @param material glTF Material\r\n     * @returns boolean specifying if texture parameters are present\r\n     */\r\n    public _hasTexturesPresent(material: IMaterial): boolean {\r\n        if (material.emissiveTexture || material.normalTexture || material.occlusionTexture) {\r\n            return true;\r\n        }\r\n        const pbrMat = material.pbrMetallicRoughness;\r\n        if (pbrMat) {\r\n            if (pbrMat.baseColorTexture || pbrMat.metallicRoughnessTexture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon StandardMaterial to a glTF Metallic Roughness Material\r\n     * @param babylonStandardMaterial\r\n     * @returns glTF Metallic Roughness Material representation\r\n     */\r\n    public _convertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n        const P0 = new Vector2(0, 1);\r\n        const P1 = new Vector2(0, 0.1);\r\n        const P2 = new Vector2(0, 0.1);\r\n        const P3 = new Vector2(1300, 0.1);\r\n\r\n        /**\r\n         * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n         * @param t a value between 0 and 1\r\n         * @param p0 first control point\r\n         * @param p1 second control point\r\n         * @param p2 third control point\r\n         * @param p3 fourth control point\r\n         * @returns number result of cubic bezier curve at the specified t\r\n         */\r\n        function _cubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n            return (\r\n                (1 - t) * (1 - t) * (1 - t) * p0 +\r\n                3 * (1 - t) * (1 - t) * t * p1 +\r\n                3 * (1 - t) * t * t * p2 +\r\n                t * t * t * p3\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n         * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n         * and roughness on the ordinant axis (y-axis)\r\n         * @param specularPower specular power of standard material\r\n         * @returns Number representing the roughness value\r\n         */\r\n        function _solveForRoughness(specularPower: number): number {\r\n            var t = Math.pow(specularPower / P3.x, 0.333333);\r\n            return _cubicBezierCurve(t, P0.y, P1.y, P2.y, P3.y);\r\n        }\r\n\r\n        let diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace().scale(0.5);\r\n        let opacity = babylonStandardMaterial.alpha;\r\n        let specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, _GLTFMaterialExporter._MaxSpecularPower);\r\n\r\n        const roughness = _solveForRoughness(specularPower);\r\n\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n            baseColorFactor: [\r\n                diffuse.r,\r\n                diffuse.g,\r\n                diffuse.b,\r\n                opacity\r\n            ],\r\n            metallicFactor: 0,\r\n            roughnessFactor: roughness,\r\n        };\r\n\r\n        return glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Computes the metallic factor\r\n     * @param diffuse diffused value\r\n     * @param specular specular value\r\n     * @param oneMinusSpecularStrength one minus the specular strength\r\n     * @returns metallic value\r\n     */\r\n    public static _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n        if (specular < this._DielectricSpecular.r) {\r\n            this._DielectricSpecular;\r\n            return 0;\r\n        }\r\n\r\n        const a = this._DielectricSpecular.r;\r\n        const b = diffuse * oneMinusSpecularStrength / (1.0 - this._DielectricSpecular.r) + specular - 2.0 * this._DielectricSpecular.r;\r\n        const c = this._DielectricSpecular.r - specular;\r\n        const D = b * b - 4.0 * a * c;\r\n        return Scalar.Clamp((-b + Math.sqrt(D)) / (2.0 * a), 0, 1);\r\n    }\r\n\r\n    /**\r\n     * Sets the glTF alpha mode to a glTF material from the Babylon Material\r\n     * @param glTFMaterial glTF material\r\n     * @param babylonMaterial Babylon material\r\n     */\r\n    private static _SetAlphaMode(glTFMaterial: IMaterial, babylonMaterial: Material & { alphaCutOff: number }): void {\r\n        if (babylonMaterial.needAlphaBlending()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n        }\r\n        else if (babylonMaterial.needAlphaTesting()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n            glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon Standard Material to a glTF Material\r\n     * @param babylonStandardMaterial BJS Standard Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const promises = [];\r\n        const glTFPbrMetallicRoughness = this._convertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const glTFMaterial: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonStandardMaterial.diffuseTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.diffuseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.bumpTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonStandardMaterial.bumpTexture != null && babylonStandardMaterial.bumpTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonStandardMaterial.bumpTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.emissiveTexture) {\r\n                glTFMaterial.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.emissiveTexture, mimeType).then((glTFEmissiveTexture) => {\r\n                    if (glTFEmissiveTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFEmissiveTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.ambientTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                            index: glTFTexture.index\r\n                        };\r\n                        glTFMaterial.occlusionTexture = occlusionTexture;\r\n                        occlusionTexture.strength = 1.0;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {\r\n                glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n            }\r\n            else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n        if (babylonStandardMaterial.emissiveColor && !_GLTFMaterialExporter.FuzzyEquals(babylonStandardMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n        _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonStandardMaterial);\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonStandardMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonStandardMaterial, mimeType);\r\n    }\r\n\r\n    private _finishMaterial<T>(promises: Promise<T>[], glTFMaterial: IMaterial, babylonMaterial: Material, mimeType: ImageMimeType) {\r\n        return Promise.all(promises).then(() => {\r\n\r\n            const textures = this._exporter._extensionsPostExportMaterialAdditionalTextures(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n            let tasks: Nullable<Promise<Nullable<ITextureInfo>>[]> = null;\r\n\r\n            for (var texture of textures) {\r\n                if (!tasks) {\r\n                    tasks = [];\r\n                }\r\n                tasks.push(this._exportTextureAsync(texture, mimeType));\r\n            }\r\n\r\n            if (!tasks) {\r\n                tasks = [Promise.resolve(null)];\r\n            }\r\n\r\n            return Promise.all(tasks).then(() => {\r\n                let extensionWork = this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n                if (!extensionWork) {\r\n                    return glTFMaterial;\r\n                }\r\n                return extensionWork.then(() => glTFMaterial);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMetalRoughMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMetallicRoughnessMaterialAsync(babylonPBRMetalRoughMaterial: PBRMetallicRoughnessMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises: Promise<void>[] = [];\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        if (babylonPBRMetalRoughMaterial.baseColor) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [\r\n                babylonPBRMetalRoughMaterial.baseColor.r,\r\n                babylonPBRMetalRoughMaterial.baseColor.g,\r\n                babylonPBRMetalRoughMaterial.baseColor.b,\r\n                babylonPBRMetalRoughMaterial.alpha\r\n            ];\r\n        }\r\n\r\n        if (babylonPBRMetalRoughMaterial.metallic != null && babylonPBRMetalRoughMaterial.metallic !== 1) {\r\n            glTFPbrMetallicRoughness.metallicFactor = babylonPBRMetalRoughMaterial.metallic;\r\n        }\r\n        if (babylonPBRMetalRoughMaterial.roughness != null && babylonPBRMetalRoughMaterial.roughness !== 1) {\r\n            glTFPbrMetallicRoughness.roughnessFactor = babylonPBRMetalRoughMaterial.roughness;\r\n        }\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMetalRoughMaterial.name\r\n        };\r\n        if (babylonPBRMetalRoughMaterial.doubleSided) {\r\n            glTFMaterial.doubleSided = babylonPBRMetalRoughMaterial.doubleSided;\r\n        }\r\n        _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonPBRMetalRoughMaterial);\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMetalRoughMaterial.baseTexture != null) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.baseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.normalTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.normalTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.normalTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonPBRMetalRoughMaterial.normalTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.occlusionTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.occlusionTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.occlusionTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.occlusionStrength != null) {\r\n                            glTFMaterial.occlusionTexture.strength = babylonPBRMetalRoughMaterial.occlusionStrength;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.emissiveTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n\r\n        }\r\n\r\n        if (_GLTFMaterialExporter.FuzzyEquals(babylonPBRMetalRoughMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonPBRMetalRoughMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonPBRMetalRoughMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonPBRMetalRoughMaterial, mimeType);\r\n    }\r\n\r\n    /**\r\n     * Converts an image typed array buffer to a base64 image\r\n     * @param buffer typed array buffer\r\n     * @param width width of the image\r\n     * @param height height of the image\r\n     * @param mimeType mimetype of the image\r\n     * @returns base64 image string\r\n     */\r\n    private _createBase64FromCanvasAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            let hostingScene: Scene;\r\n\r\n            const textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            const engine = this._exporter._getLocalEngine();\r\n\r\n            hostingScene = new Scene(engine);\r\n\r\n            // Create a temporary texture with the texture buffer data\r\n            const tempTexture = engine.createRawTexture(buffer, width, height, Constants.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n            const postProcess = new PostProcess(\"pass\", \"pass\", null, null, 1, null, Texture.NEAREST_SAMPLINGMODE, engine, false, undefined, Constants.TEXTURETYPE_UNSIGNED_INT, undefined, null, false);\r\n            postProcess.getEffect().executeWhenCompiled(() => {\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                };\r\n\r\n                // Set the size of the texture\r\n                engine.setSize(width, height);\r\n                hostingScene.postProcessManager.directRender([postProcess], null);\r\n                postProcess.dispose();\r\n                tempTexture.dispose();\r\n\r\n                // Read data from WebGL\r\n                const canvas0 = engine.getRenderingCanvas();\r\n\r\n                let canvas: Nullable<HTMLCanvasElement> = document.createElement(\"canvas\");\r\n\r\n                canvas.width = canvas0?.width ?? 0;\r\n                canvas.height = canvas0?.height ?? 0;\r\n\r\n                var destCtx = canvas.getContext('2d');\r\n                destCtx!.drawImage(canvas0!, 0, 0);\r\n\r\n                if (canvas) {\r\n                    if (!canvas.toBlob) { // fallback for browsers without \"canvas.toBlob\"\r\n                        const dataURL = canvas.toDataURL();\r\n                        resolve(dataURL);\r\n                    }\r\n                    else {\r\n                        Tools.ToBlob(canvas, (blob) => {\r\n                            canvas = null;\r\n                            if (blob) {\r\n                                let fileReader = new FileReader();\r\n                                fileReader.onload = (event: any) => {\r\n                                    let base64String = event.target.result as string;\r\n                                    hostingScene.dispose();\r\n                                    resolve(base64String);\r\n                                };\r\n                                fileReader.readAsDataURL(blob);\r\n                            }\r\n                            else {\r\n                                reject(\"gltfMaterialExporter: Failed to get blob from image canvas!\");\r\n                            }\r\n                        }, mimeType);\r\n                    }\r\n                }\r\n                else {\r\n                    reject(\"Engine is missing a canvas!\");\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a white texture based on the specified width and height\r\n     * @param width width of the texture in pixels\r\n     * @param height height of the texture in pixels\r\n     * @param scene babylonjs scene\r\n     * @returns white texture\r\n     */\r\n    private _createWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n        const data = new Uint8Array(width * height * 4);\r\n\r\n        for (let i = 0; i < data.length; i = i + 4) {\r\n            data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xFF;\r\n        }\r\n\r\n        const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: BaseTexture, texture2: BaseTexture, scene: Scene): { \"texture1\": BaseTexture, \"texture2\": BaseTexture } {\r\n        let texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        let texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1;\r\n        let resizedTexture2;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture1 = this._createWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2;\r\n        }\r\n        else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture2 = this._createWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1;\r\n        }\r\n        else {\r\n            resizedTexture1 = texture1;\r\n            resizedTexture2 = texture2;\r\n        }\r\n\r\n        return {\r\n            \"texture1\": resizedTexture1,\r\n            \"texture2\": resizedTexture2\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts an array of pixels to a Float32Array\r\n     * Throws an error if the pixel format is not supported\r\n     * @param pixels - array buffer containing pixel values\r\n     * @returns Float32 of pixels\r\n     */\r\n    private _convertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n        if (pixels instanceof Uint8Array) {\r\n            const length = pixels.length;\r\n            const buffer = new Float32Array(pixels.length);\r\n            for (let i = 0; i < length; ++i) {\r\n                buffer[i] = pixels[i] / 255;\r\n            }\r\n            return buffer;\r\n        }\r\n        else if (pixels instanceof Float32Array) {\r\n            return pixels;\r\n        }\r\n        else {\r\n            throw new Error('Unsupported pixel format!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(diffuseTexture: BaseTexture, specularGlossinessTexture: BaseTexture, factors: _IPBRSpecularGlossiness, mimeType: ImageMimeType): Promise<_IPBRMetallicRoughness> {\r\n        let promises = [];\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return Promise.reject('_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!');\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            let diffuseSize = resizedTextures.texture1.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            let diffusePixels = resizedTextures.texture1.readPixels();\r\n            let specularPixels = resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = this._convertPixelArrayToFloat32(diffusePixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = this._convertPixelArrayToFloat32(specularPixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Color3.Black();\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2]).toLinearSpace().multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2]).toLinearSpace().multiply(factors.specularColor);\r\n                    const glossiness = (specularGlossinessBuffer[offset + 3]) * factors.glossiness;\r\n\r\n                    const specularGlossiness: _IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: _IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(baseColorBuffer[destinationOffset], baseColorBuffer[destinationOffset + 1], baseColorBuffer[destinationOffset + 2]);\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace();\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(sRGBBaseColorPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(metallicRoughnessPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(metallicRoughnessBuffer, width, height, mimeType).then((metallicRoughnessBase64) => {\r\n                    metallicRoughnessFactors.metallicRoughnessTextureBase64 = metallicRoughnessBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(baseColorBuffer, width, height, mimeType).then((baseColorBase64) => {\r\n                    metallicRoughnessFactors.baseColorTextureBase64 = baseColorBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        }\r\n        else {\r\n            return Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: _IPBRSpecularGlossiness): _IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _GLTFMaterialExporter._SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - _GLTFMaterialExporter._DielectricSpecular.r) / Math.max(1 - metallic, _GLTFMaterialExporter._Epsilon));\r\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(_GLTFMaterialExporter._DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, _GLTFMaterialExporter._Epsilon));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        const promises = [];\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: babylonPBRMaterial.albedoColor,\r\n            metallic: babylonPBRMaterial.metallic,\r\n            roughness: babylonPBRMaterial.roughness\r\n        };\r\n\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMaterial.albedoTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.albedoTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMaterial.metallicTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.metallicTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            return metallicRoughness;\r\n        });\r\n    }\r\n\r\n    private _getGLTFTextureSampler(texture: BaseTexture): ISampler {\r\n        const sampler = this._getGLTFTextureWrapModesSampler(texture);\r\n\r\n        let samplingMode = texture instanceof Texture ? texture.samplingMode : null;\r\n        if (samplingMode != null) {\r\n            switch (samplingMode) {\r\n                case Texture.LINEAR_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGLTFTextureWrapModesSampler(texture: BaseTexture): ISampler {\r\n        let wrapS = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapU : Texture.WRAP_ADDRESSMODE);\r\n        let wrapT = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapV : Texture.WRAP_ADDRESSMODE);\r\n\r\n        if (wrapS === TextureWrapMode.REPEAT && wrapT === TextureWrapMode.REPEAT) { // default wrapping mode in glTF, so omitting\r\n            return {};\r\n        }\r\n\r\n        return { wrapS: wrapS, wrapT: wrapT };\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        return Promise.resolve().then(() => {\r\n            const samplers = this._exporter._samplers;\r\n            const textures = this._exporter._textures;\r\n            const specGloss: _IPBRSpecularGlossiness = {\r\n                diffuseColor: babylonPBRMaterial.albedoColor || Color3.White(),\r\n                specularColor: babylonPBRMaterial.reflectivityColor || Color3.White(),\r\n                glossiness: babylonPBRMaterial.microSurface || 1,\r\n            };\r\n            let samplerIndex: Nullable<number> = null;\r\n            const sampler = this._getGLTFTextureSampler(babylonPBRMaterial.albedoTexture);\r\n            if (sampler.magFilter != null && sampler.minFilter != null && sampler.wrapS != null && sampler.wrapT != null) {\r\n                samplers.push(sampler);\r\n                samplerIndex = samplers.length - 1;\r\n            }\r\n            if (babylonPBRMaterial.reflectivityTexture && !babylonPBRMaterial.useMicroSurfaceFromReflectivityMapAlpha) {\r\n                return Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n            }\r\n            if ((babylonPBRMaterial.albedoTexture || babylonPBRMaterial.reflectivityTexture) && hasTextureCoords) {\r\n                return this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(babylonPBRMaterial.albedoTexture, babylonPBRMaterial.reflectivityTexture, specGloss, mimeType).then((metallicRoughnessFactors) => {\r\n                    if (metallicRoughnessFactors.baseColorTextureBase64) {\r\n                        const glTFBaseColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.baseColorTextureBase64, \"bjsBaseColorTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.albedoTexture ? babylonPBRMaterial.albedoTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFBaseColorTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFBaseColorTexture;\r\n                        }\r\n                    }\r\n                    if (metallicRoughnessFactors.metallicRoughnessTextureBase64) {\r\n                        const glTFMRColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.metallicRoughnessTextureBase64, \"bjsMetallicRoughnessTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.reflectivityTexture ? babylonPBRMaterial.reflectivityTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFMRColorTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFMRColorTexture;\r\n                        }\r\n                    }\r\n\r\n                    return metallicRoughnessFactors;\r\n                });\r\n            }\r\n            else {\r\n                return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMaterialAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name\r\n        };\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            if (babylonPBRMaterial.albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    babylonPBRMaterial.albedoColor.r,\r\n                    babylonPBRMaterial.albedoColor.g,\r\n                    babylonPBRMaterial.albedoColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n            return this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n        else {\r\n            return this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n    }\r\n\r\n    private setMetallicRoughnessPbrMaterial(metallicRoughness: Nullable<_IPBRMetallicRoughness>, babylonPBRMaterial: PBRMaterial, glTFMaterial: IMaterial, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises = [];\r\n        if (metallicRoughness) {\r\n            _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonPBRMaterial);\r\n            if (!(_GLTFMaterialExporter.FuzzyEquals(metallicRoughness.baseColor, Color3.White(), _GLTFMaterialExporter._Epsilon) && babylonPBRMaterial.alpha >= _GLTFMaterialExporter._Epsilon)) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    metallicRoughness.baseColor.r,\r\n                    metallicRoughness.baseColor.g,\r\n                    metallicRoughness.baseColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n\r\n            if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n                glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n            }\r\n            if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n                glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n            }\r\n\r\n            if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n                if (!babylonPBRMaterial.twoSidedLighting) {\r\n                    Tools.Warn(babylonPBRMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n                }\r\n                glTFMaterial.doubleSided = true;\r\n            }\r\n\r\n            if (hasTextureCoords) {\r\n                if (babylonPBRMaterial.bumpTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (babylonPBRMaterial.bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = babylonPBRMaterial.bumpTexture.level;\r\n                            }\r\n                        }\r\n                    }\r\n                    );\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.ambientTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            let occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                                texCoord: glTFTexture.texCoord\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n\r\n                            if (babylonPBRMaterial.ambientTextureStrength) {\r\n                                occlusionTexture.strength = babylonPBRMaterial.ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.emissiveTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n            if (!_GLTFMaterialExporter.FuzzyEquals(babylonPBRMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n                glTFMaterial.emissiveFactor = babylonPBRMaterial.emissiveColor.asArray();\r\n            }\r\n\r\n            glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n            materials.push(glTFMaterial);\r\n            materialMap[babylonPBRMaterial.uniqueId] = materials.length - 1;\r\n        }\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonPBRMaterial, mimeType);\r\n    }\r\n\r\n    private getPixelsFromTexture(babylonTexture: BaseTexture): Nullable<Uint8Array | Float32Array> {\r\n        const pixels = babylonTexture.textureType === Constants.TEXTURETYPE_UNSIGNED_INT ? babylonTexture.readPixels() as Uint8Array : babylonTexture.readPixels() as Float32Array;\r\n        return pixels;\r\n    }\r\n\r\n    /**\r\n     * Extracts a texture from a Babylon texture into file data and glTF data\r\n     * @param babylonTexture Babylon texture to extract\r\n     * @param mimeType Mime Type of the babylonTexture\r\n     * @return glTF texture info, or null if the texture format is not supported\r\n     */\r\n    public _exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return extensionPromise.then((texture) => {\r\n            if (!texture) {\r\n                return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    public _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        return Promise.resolve().then(() => {\r\n            const textureUid = babylonTexture.uid;\r\n            if (textureUid in this._textureMap) {\r\n                return this._textureMap[textureUid];\r\n            }\r\n            else {\r\n                const pixels = this.getPixelsFromTexture(babylonTexture);\r\n                if (!pixels) {\r\n                    return null;\r\n                }\r\n\r\n                const samplers = this._exporter._samplers;\r\n                const sampler = this._getGLTFTextureSampler(babylonTexture);\r\n                let samplerIndex: Nullable<number> = null;\r\n\r\n                //  if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n                let foundSamplerIndex: Nullable<number> = null;\r\n                for (let i = 0; i < samplers.length; ++i) {\r\n                    let s = samplers[i];\r\n                    if (s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter &&\r\n                        s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT) {\r\n                        foundSamplerIndex = i;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (foundSamplerIndex == null) {\r\n                    samplers.push(sampler);\r\n                    samplerIndex = samplers.length - 1;\r\n                }\r\n                else {\r\n                    samplerIndex = foundSamplerIndex;\r\n                }\r\n                const size = babylonTexture.getSize();\r\n\r\n                // Preserve texture mime type if defined\r\n                if ((babylonTexture as Texture).mimeType) {\r\n                    switch ((babylonTexture as Texture).mimeType) {\r\n                        case \"image/jpeg\":\r\n                            mimeType = ImageMimeType.JPEG;\r\n                            break;\r\n                        case \"image/png\":\r\n                            mimeType = ImageMimeType.PNG;\r\n                            break;\r\n                    }\r\n\r\n                }\r\n\r\n                return this._createBase64FromCanvasAsync(pixels, size.width, size.height, mimeType).then((base64Data) => {\r\n                    const textureInfo = this._getTextureInfoFromBase64(base64Data, babylonTexture.name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\"), mimeType, babylonTexture.coordinatesIndex, samplerIndex);\r\n                    if (textureInfo) {\r\n                        this._textureMap[textureUid] = textureInfo;\r\n                        this._exporter._extensionsPostExportTextures(\"linkTextureInfo\", textureInfo, babylonTexture);\r\n                    }\r\n\r\n                    return textureInfo;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Builds a texture from base64 string\r\n     * @param base64Texture base64 texture string\r\n     * @param baseTextureName Name to use for the texture\r\n     * @param mimeType image mime type for the texture\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param imageData map of image data\r\n     * @returns glTF texture info, or null if the texture format is not supported\r\n     */\r\n    private _getTextureInfoFromBase64(base64Texture: string, baseTextureName: string, mimeType: ImageMimeType, texCoordIndex: Nullable<number>, samplerIndex: Nullable<number>): Nullable<ITextureInfo> {\r\n        const textures = this._exporter._textures;\r\n        const images = this._exporter._images;\r\n        const imageData = this._exporter._imageData;\r\n        let textureInfo: Nullable<ITextureInfo> = null;\r\n\r\n        const glTFTexture: ITexture = {\r\n            source: images.length,\r\n            name: baseTextureName\r\n        };\r\n        if (samplerIndex != null) {\r\n            glTFTexture.sampler = samplerIndex;\r\n        }\r\n\r\n        const binStr = atob(base64Texture.split(',')[1]);\r\n        let arrBuff = new ArrayBuffer(binStr.length);\r\n        const arr = new Uint8Array(arrBuff);\r\n        for (let i = 0, length = binStr.length; i < length; ++i) {\r\n            arr[i] = binStr.charCodeAt(i);\r\n        }\r\n        const imageValues = { data: arr, mimeType: mimeType };\r\n\r\n        let extension = mimeType === ImageMimeType.JPEG ? '.jpeg' : '.png';\r\n        let textureName = baseTextureName + extension;\r\n        let originalTextureName = textureName;\r\n        if (textureName in imageData) {\r\n            textureName = `${baseTextureName}_${Tools.RandomId()}${extension}`;\r\n        }\r\n\r\n        imageData[textureName] = imageValues;\r\n        if (mimeType === ImageMimeType.JPEG || mimeType === ImageMimeType.PNG) {\r\n            const glTFImage: IImage = {\r\n                name: baseTextureName,\r\n                uri: textureName\r\n            };\r\n            let foundIndex: Nullable<number> = null;\r\n            for (let i = 0; i < images.length; ++i) {\r\n                if (images[i].uri === originalTextureName) {\r\n                    foundIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (foundIndex == null) {\r\n                images.push(glTFImage);\r\n                glTFTexture.source = images.length - 1;\r\n            }\r\n            else {\r\n                glTFTexture.source = foundIndex;\r\n\r\n            }\r\n            textures.push(glTFTexture);\r\n            textureInfo = {\r\n                index: textures.length - 1\r\n            };\r\n            if (texCoordIndex != null) {\r\n                textureInfo.texCoord = texCoordIndex;\r\n            }\r\n        }\r\n        else {\r\n            Tools.Error(`Unsupported texture mime type ${mimeType}`);\r\n        }\r\n\r\n        return textureInfo;\r\n    }\r\n}"]}