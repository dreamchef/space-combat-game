{"version":3,"file":"glTFSerializer.js","sourceRoot":"","sources":["../../../../sourceES6/serializers/src/glTF/2.0/glTFSerializer.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAoC3C;;GAEG;AACH;IAAA;IAuDA,CAAC;IAtDG;;;;;;;OAOG;IACW,qBAAS,GAAvB,UAAwB,KAAY,EAAE,UAAkB,EAAE,OAAwB;QAC9E,OAAO,KAAK,CAAC,cAAc,EAAE,CAAC,IAAI,CAAC;YAC/B,IAAM,UAAU,GAAG,UAAU,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;YACvD,IAAM,aAAa,GAAG,IAAI,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YACpD,OAAO,aAAa,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;QACxD,CAAC,CAAC,CAAC;IACP,CAAC;IAEc,2BAAe,GAA9B,UAA+B,KAAY,EAAE,OAAwB;QACjE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC;YAC1B,IAAI,OAAO,IAAI,OAAO,CAAC,4BAA4B,EAAE;gBACjD,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;aAC5B;iBACI;gBACD,OAAO,KAAK,CAAC,cAAc,EAAE,CAAC;aACjC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAEc,4BAAgB,GAA/B,UAAgC,KAAY,EAAE,QAAkB,EAAE,OAAwB;QACtF,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC;YAC1B,IAAI,OAAO,IAAI,OAAO,CAAC,4BAA4B,EAAE;gBACjD,OAAO,QAAQ,CAAC;aACnB;iBACI;gBACD,OAAO,QAAQ,CAAC;aACnB;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;OAMG;IACW,oBAAQ,GAAtB,UAAuB,KAAY,EAAE,UAAkB,EAAE,OAAwB;QAAjF,iBAQC;QAPG,OAAO,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,IAAI,CAAC;YAC7C,IAAM,UAAU,GAAG,UAAU,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;YACvD,IAAM,aAAa,GAAG,IAAI,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YACpD,OAAO,aAAa,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,UAAC,QAAQ;gBAC7D,OAAO,KAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YAC3D,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;IACP,CAAC;IACL,kBAAC;AAAD,CAAC,AAvDD,IAuDC","sourcesContent":["import { Node } from \"@babylonjs/core/node\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _Exporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon node should be exported or not\r\n     * @param node source Babylon node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the node should be exported (true) or not (false)\r\n     */\r\n    shouldExportNode?(node: Node): boolean;\r\n\r\n    /**\r\n     * Function used to extract the part of node's metadata that will be exported into glTF node extras\r\n     * @param metadata source metadata to read from\r\n     * @returns the data to store to glTF node extras\r\n     */\r\n    metadataSelector?(metadata: any): any;\r\n\r\n    /**\r\n     * The sample rate to bake animation curves\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n\r\n    /**\r\n     * Indicates if coordinate system swapping root nodes should be included in export\r\n     */\r\n    includeCoordinateSystemConversionNodes?: boolean;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the geometry of the scene to .gltf file format asynchronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating the glTF file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .gltf file and associates texture names\r\n     * as keys and their data and paths as values\r\n     */\r\n    public static GLTFAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return scene.whenReadyAsync().then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLTFAsync(glTFPrefix);\r\n        });\r\n    }\r\n\r\n    private static _PreExportAsync(scene: Scene, options?: IExportOptions): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return Promise.resolve();\r\n            }\r\n            else {\r\n                return scene.whenReadyAsync();\r\n            }\r\n        });\r\n    }\r\n\r\n    private static _PostExportAsync(scene: Scene, glTFData: GLTFData, options?: IExportOptions): Promise<GLTFData> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return glTFData;\r\n            }\r\n            else {\r\n                return glTFData;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Exports the geometry of the scene to .glb file format asychronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating glb file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .glb filename as key and data as value\r\n     */\r\n    public static GLBAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return this._PreExportAsync(scene, options).then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLBAsync(glTFPrefix).then((glTFData) => {\r\n                return this._PostExportAsync(scene, glTFData, options);\r\n            });\r\n        });\r\n    }\r\n}\r\n"]}