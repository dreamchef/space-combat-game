import { Vector3, Matrix } from "@babylonjs/core/Maths/math.vector";
/**
 * @hidden
 */
var _GLTFUtilities = /** @class */ (function () {
    function _GLTFUtilities() {
    }
    /**
     * Creates a buffer view based on the supplied arguments
     * @param bufferIndex index value of the specified buffer
     * @param byteOffset byte offset value
     * @param byteLength byte length of the bufferView
     * @param byteStride byte distance between conequential elements
     * @param name name of the buffer view
     * @returns bufferView for glTF
     */
    _GLTFUtilities._CreateBufferView = function (bufferIndex, byteOffset, byteLength, byteStride, name) {
        var bufferview = { buffer: bufferIndex, byteLength: byteLength };
        if (byteOffset) {
            bufferview.byteOffset = byteOffset;
        }
        if (name) {
            bufferview.name = name;
        }
        if (byteStride) {
            bufferview.byteStride = byteStride;
        }
        return bufferview;
    };
    /**
     * Creates an accessor based on the supplied arguments
     * @param bufferviewIndex The index of the bufferview referenced by this accessor
     * @param name The name of the accessor
     * @param type The type of the accessor
     * @param componentType The datatype of components in the attribute
     * @param count The number of attributes referenced by this accessor
     * @param byteOffset The offset relative to the start of the bufferView in bytes
     * @param min Minimum value of each component in this attribute
     * @param max Maximum value of each component in this attribute
     * @returns accessor for glTF
     */
    _GLTFUtilities._CreateAccessor = function (bufferviewIndex, name, type, componentType, count, byteOffset, min, max) {
        var accessor = { name: name, bufferView: bufferviewIndex, componentType: componentType, count: count, type: type };
        if (min != null) {
            accessor.min = min;
        }
        if (max != null) {
            accessor.max = max;
        }
        if (byteOffset != null) {
            accessor.byteOffset = byteOffset;
        }
        return accessor;
    };
    /**
     * Calculates the minimum and maximum values of an array of position floats
     * @param positions Positions array of a mesh
     * @param vertexStart Starting vertex offset to calculate min and max values
     * @param vertexCount Number of vertices to check for min and max values
     * @returns min number array and max number array
     */
    _GLTFUtilities._CalculateMinMaxPositions = function (positions, vertexStart, vertexCount, convertToRightHandedSystem) {
        var min = [Infinity, Infinity, Infinity];
        var max = [-Infinity, -Infinity, -Infinity];
        var positionStrideSize = 3;
        var indexOffset;
        var position;
        var vector;
        if (vertexCount) {
            for (var i = vertexStart, length_1 = vertexStart + vertexCount; i < length_1; ++i) {
                indexOffset = positionStrideSize * i;
                position = Vector3.FromArray(positions, indexOffset);
                if (convertToRightHandedSystem) {
                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(position);
                }
                vector = position.asArray();
                for (var j = 0; j < positionStrideSize; ++j) {
                    var num = vector[j];
                    if (num < min[j]) {
                        min[j] = num;
                    }
                    if (num > max[j]) {
                        max[j] = num;
                    }
                    ++indexOffset;
                }
            }
        }
        return { min: min, max: max };
    };
    /**
     * Converts a new right-handed Vector3
     * @param vector vector3 array
     * @returns right-handed Vector3
     */
    _GLTFUtilities._GetRightHandedPositionVector3 = function (vector) {
        return new Vector3(vector.x, vector.y, -vector.z);
    };
    /**
     * Converts a Vector3 to right-handed
     * @param vector Vector3 to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedPositionVector3FromRef = function (vector) {
        vector.z *= -1;
    };
    /**
     * Converts a three element number array to right-handed
     * @param vector number array to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedPositionArray3FromRef = function (vector) {
        vector[2] *= -1;
    };
    /**
     * Converts a new right-handed Vector3
     * @param vector vector3 array
     * @returns right-handed Vector3
     */
    _GLTFUtilities._GetRightHandedNormalVector3 = function (vector) {
        return new Vector3(vector.x, vector.y, -vector.z);
    };
    /**
     * Converts a Vector3 to right-handed
     * @param vector Vector3 to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedNormalVector3FromRef = function (vector) {
        vector.z *= -1;
    };
    /**
     * Converts a three element number array to right-handed
     * @param vector number array to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedNormalArray3FromRef = function (vector) {
        vector[2] *= -1;
    };
    /**
     * Converts a Vector4 to right-handed
     * @param vector Vector4 to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedVector4FromRef = function (vector) {
        vector.z *= -1;
        vector.w *= -1;
    };
    /**
     * Converts a Vector4 to right-handed
     * @param vector Vector4 to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedArray4FromRef = function (vector) {
        vector[2] *= -1;
        vector[3] *= -1;
    };
    /**
     * Converts a Quaternion to right-handed
     * @param quaternion Source quaternion to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedQuaternionFromRef = function (quaternion) {
        quaternion.x *= -1;
        quaternion.y *= -1;
    };
    /**
     * Converts a Quaternion to right-handed
     * @param quaternion Source quaternion to convert to right-handed
     */
    _GLTFUtilities._GetRightHandedQuaternionArrayFromRef = function (quaternion) {
        quaternion[0] *= -1;
        quaternion[1] *= -1;
    };
    _GLTFUtilities._NormalizeTangentFromRef = function (tangent) {
        var length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);
        if (length > 0) {
            tangent.x /= length;
            tangent.y /= length;
            tangent.z /= length;
        }
    };
    _GLTFUtilities._GetRightHandedMatrixFromRef = function (matrix) {
        var m = matrix.m;
        Matrix.FromValuesToRef(m[0], m[1], -m[2], m[3], m[4], m[5], -m[6], m[7], -m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15], matrix);
    };
    _GLTFUtilities._GetDataAccessorElementCount = function (accessorType) {
        switch (accessorType) {
            case "MAT2" /* MAT2 */:
                return 4;
            case "MAT3" /* MAT3 */:
                return 9;
            case "MAT4" /* MAT4 */:
                return 16;
            case "SCALAR" /* SCALAR */:
                return 1;
            case "VEC2" /* VEC2 */:
                return 2;
            case "VEC3" /* VEC3 */:
                return 3;
            case "VEC4" /* VEC4 */:
                return 4;
        }
    };
    return _GLTFUtilities;
}());
export { _GLTFUtilities };
//# sourceMappingURL=glTFUtilities.js.map