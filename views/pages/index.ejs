<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Space Game</title>
    <style>
        html,body,canvas { margin: 0; padding: 0; width: 100%; height: 100%; font-size: 0; }
    </style>
</head>
<body>
<script src="libraries/babylon.max.js"></script>
<script src="libraries/babylon.objFileLoader.js"></script>
<canvas id="render-canvas"></canvas>
<script>

    //////////////////////////////////
    //     GAME CONFIG VARIABLES    //
    //////////////////////////////////

    let numPieces = 5;
    let boardRadius = 15;
    let pieceSize = 1;


    //////////////////////////////////
    //     GAME-STATE VARIABLES     //
    //////////////////////////////////

    let groupSelect = false;
    let mouseControl = false;


    //////////////////////////////////
    //  SCENE, SKYBOX, & LIGHTING   //
    //////////////////////////////////
    
    var canvas = document.getElementById("render-canvas");
    var engine = new BABYLON.Engine(canvas);
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.8, 0.8, 0.8);

    var light = new BABYLON.PointLight("light", new BABYLON.Vector3(10, 10, 0), scene);

    var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
    var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("assets/textures/skybox/darkred", scene);
    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    skybox.material = skyboxMaterial;


    //////////////////////////////////
    //  MODEL MATERIALS & TEXTURES  //
    //////////////////////////////////

    var playerPieceMat = new BABYLON.StandardMaterial("playerPieceMat", scene);
    playerPieceMat.emissiveColor = new BABYLON.Color3(0, 0.58, 0.86);

    var AIPieceMat = new BABYLON.StandardMaterial("AIPieceMat", scene);
    AIPieceMat.emissiveColor = new BABYLON.Color3(0.86, 0.3, 0);


    //////////////////////////////////
    //      FIRST-PERSON CAMERA     //
    //////////////////////////////////

    var camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 0, -boardRadius), scene);


    //////////////////////////////////
    //     GAMEPIECE SPAWNING       //
    //////////////////////////////////

    // Player pieces
    let playerPieces = [];
    for(let i = 0; i < numPieces; i++) {
        playerPieces.push(BABYLON.Mesh.CreateBox("playerPiece", pieceSize, scene));
        playerPieces[i].material = playerPieceMat;
        playerPieces[i].position.y = -2;
        playerPieces[i].position.x = (i/(numPieces-1))*boardRadius*2 - boardRadius; // Interpolate board size by number of pieces
        playerPieces[i].position.z = -boardRadius/2; // Interpolate board size by number of pieces
        playerPieces[i].isPickable;
        playerPieces[i].edgesWidth = 4;
        playerPieces[i].edgesColor = new BABYLON.Color4(1, 1, 1, 1);
    }

    // AI pieces
    let AIPieces = [];
    for(let i = 0; i < numPieces; i++) {
        AIPieces.push(BABYLON.Mesh.CreateBox("AIPiece", pieceSize, scene));
        AIPieces[i].material = AIPieceMat;
        AIPieces[i].position.y = -2;
        AIPieces[i].position.x = (i/(numPieces-1))*boardRadius*2 - boardRadius; // Interpolate board size by number of pieces
        AIPieces[i].position.z = boardRadius/2; // Interpolate board size by number of pieces
    }


    //////////////////////////////////
    //  PLAYER-CONTROLLED EVENTS    //
    //////////////////////////////////

    function keyDown(key) {
        // Group-select while shift held down
        if(key.code == 'ShiftLeft') {
            groupSelect = true;
            console.log('group select');
        }
        // WSAD movement
        // else if(key.code == 'KeyD') {
        //     console.log('right');
        //     scene.activeCamera.position.x++;
        // }
        // else if(key.code == 'KeyA') {
        //     console.log('moving player...');
        //     scene.activeCamera.position.x--;
        // }
        // else if(key.code == 'KeyW') {
        //     console.log('moving player...');
        //     scene.activeCamera.position.z++;
        // }
        // else if(key.code == 'KeyS') {
        //     scene.activeCamera.position.z--;
        // }
    }

    function keyUp(key) {
        // Individual-select while shift up
        if(key.code == 'ShiftLeft') {
            groupSelect = false;
            console.log('single select');
        }
        // Toggle mouse camera control
        else if(key.code == 'KeyT') {
            mouseControl = !mouseControl;
        }
        // Exit mouse camera
        else if(key.code == 'Escape') {
            mouseControl = false;
        }
        // Move selected gamepieces
        else if(key.code == 'KeyE') {
            // TODO
        }
    }

    function orientCam(event) {
        // Set look direction based on cursor position
        if(mouseControl) {
            scene.activeCamera.rotation.y = (event.offsetX/canvas.width)*6 - 3;
            scene.activeCamera.rotation.x = (event.offsetY/canvas.height)*2 - 1;
        }
    }

    // Start all listeners
    document.addEventListener('keydown', keyDown);
    document.addEventListener('keyup', keyUp);
    document.addEventListener('mousemove', orientCam);

    // Select gamepieces with left mouse-click
    scene.onPointerDown = function (evt, pickResult) {
        if (pickResult.hit) {
            if( !groupSelect || pickResult.pickedMesh.name != 'playerPiece') {
                for(let i = 0; i < numPieces; i++) {
                        playerPieces[i].state = 'selected';
                        playerPieces[i].enableEdgesRendering(0);
                }
            }
            if(pickResult.pickedMesh.name == 'playerPiece') {
                pickResult.pickedMesh.state = 'deselected';
                pickResult.pickedMesh.enableEdgesRendering();
            }
        }
    };


    //////////////////////////////////
    //           RENDER LOOP        //
    //////////////////////////////////
    
    var renderLoop = function () {
        scene.render();
    };
    engine.runRenderLoop(renderLoop);


    

    
    


 


</script>
</body>
</html>
