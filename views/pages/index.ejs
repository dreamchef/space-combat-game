<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Space Game</title>
    <style>
        html,body,canvas { margin: 0; padding: 0; width: 100%; height: 100%; font-size: 0; }
    </style>
</head>
<body>
<script src="libraries/babylon.max.js"></script>
<script src="libraries/babylon.objFileLoader.js"></script>
<canvas id="render-canvas"></canvas>
<script>
    console.log('-------------------------------\n ---- Initializing game... ---- \n ------------------------------');

    console.log('initializing game variables... ');
    //////////////////////////////////
    //     GAME CONFIG VARIABLES    //
    //////////////////////////////////

    let numPieces = 5;
    let boardRadius = 15;
    let pieceSize = 1;
    let pieceSpeed = 1;
    let moveTargetError = 1;


    //////////////////////////////////
    //     GAME-STATE VARIABLES     //
    //////////////////////////////////

    let groupSelect = false;
    let mouseControl = false;


    console.log('creating scene, skybox, and lights... ');
    //////////////////////////////////
    //  SCENE, SKYBOX, & LIGHTING   //
    //////////////////////////////////
    
    let canvas = document.getElementById("render-canvas");
    let engine = new BABYLON.Engine(canvas);
    let scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.8, 0.8, 0.8);

    let light = new BABYLON.PointLight("light", new BABYLON.Vector3(10, 10, 0), scene);

    let skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
    let skyboxMat = new BABYLON.StandardMaterial("skyBox", scene);
    skyboxMat.backFaceCulling = false;
    skyboxMat.reflectionTexture = new BABYLON.CubeTexture("assets/textures/skybox/darkred", scene);
    skyboxMat.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skyboxMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
    skyboxMat.specularColor = new BABYLON.Color3(0, 0, 0);
    skybox.material = skyboxMat;


    console.log('creating model materials and textures... ');
    //////////////////////////////////
    //  MODEL MATERIALS & TEXTURES  //
    //////////////////////////////////

    let playerPieceMat = new BABYLON.StandardMaterial("playerPieceMat", scene);
    playerPieceMat.emissiveColor = new BABYLON.Color3(0, 0.58, 0.86);

    let AIPieceMat = new BABYLON.StandardMaterial("AIPieceMat", scene);
    AIPieceMat.emissiveColor = new BABYLON.Color3(0.86, 0.3, 0);

    let planarCursorMat = new BABYLON.StandardMaterial("planarCursorMat", scene);
    planarCursorMat.emissiveColor = new BABYLON.Color3(0, 1, 0);

    console.log('creating cameras... ');
    //////////////////////////////////
    //      FIRST-PERSON CAMERA     //
    //////////////////////////////////

    let camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, boardRadius/2, -boardRadius), scene);

    console.log('spawning gamepieces... ');
    //////////////////////////////////
    //     GAMEPIECE SPAWNING       //
    //////////////////////////////////

    // Player pieces
    let playerPieces = [];
    for(let i = 0; i < numPieces; i++) {

        // Mesh location, size, and appearance
        let piece = BABYLON.Mesh.CreateBox('playerPiece', pieceSize, scene);
        piece.material = playerPieceMat;
        piece.position.x = (i/(numPieces-1))*boardRadius*2 - boardRadius; // Interpolate board size by number of pieces
        piece.position.z = -boardRadius/2; // Interpolate board size by number of pieces
        piece.isPickable = true;
        piece.edgesWidth = 4;
        piece.edgesColor = new BABYLON.Color4(1, 1, 1, 1);

        // Gamepiece state variables
        piece.metadata = {
            health: 1,
            moving: false,
            target: null,
            selected: false
        }

        playerPieces.push(piece);
        console.log('   player gamepiece instance material: ' + piece.material.emissiveColor);
    }

    // AI pieces
    let AIPieces = [];
    for(let i = 0; i < numPieces; i++) {
        let piece = BABYLON.Mesh.CreateBox('AIPiece', pieceSize, scene);
        piece.material = AIPieceMat;
        piece.position.x = (i/(numPieces-1))*boardRadius*2 - boardRadius; // Interpolate board size by number of pieces
        piece.position.z = boardRadius/2; // Interpolate board size by number of pieces

        // Gamepiece state variables
        piece.metadata = {
            health: 1,
            moving: false,
            target: null
        }

        AIPieces.push(piece);
        console.log('   AI gamepiece instance pos: ' + AIPieces[i].position);
    }

    console.log('creating planar cursor... ');
    //////////////////////////////////
    //  PLANAR CURSOR (COMMANDS)    //
    //////////////////////////////////

    let planarCursor = BABYLON.MeshBuilder.CreatePlane("planarCursor", scene);
    planarCursor.material = planarCursorMat;
    planarCursor.rotation.x = Math.PI/2;
    planarCursor.isPickable = false;

    //////////////////////////////////
    //          GAME BOARD          //
    //////////////////////////////////

    let board = BABYLON.MeshBuilder.CreatePlane('board', {size: 2*boardRadius},scene);
    board.visibility = 0;
    board.rotation.x = Math.PI/2;
    board.isPickable = false;

    console.log('listening for player-controlled events... ');
    //////////////////////////////////
    //  PLAYER-CONTROLLED EVENTS    //
    //////////////////////////////////

    function keyDown(key) {
        // Group-select while shift held down
        if(key.code == 'ShiftLeft') {
            groupSelect = true;
            console.log('group select');
        }
        // WSAD movement
        // else if(key.code == 'KeyD') {
        //     console.log('right');
        //     scene.activeCamera.position.x++;
        // }
        // else if(key.code == 'KeyA') {
        //     console.log('moving player...');
        //     scene.activeCamera.position.x--;
        // }
        // else if(key.code == 'KeyW') {
        //     console.log('moving player...');
        //     scene.activeCamera.position.z++;
        // }
        // else if(key.code == 'KeyS') {
        //     scene.activeCamera.position.z--;
        // }
    }

    function keyUp(key) {
        // Individual-select while shift up
        if(key.code == 'ShiftLeft') {
            groupSelect = false;
            console.log('single select');
        }
        // Toggle mouse camera control
        else if(key.code == 'KeyT') {
            mouseControl = !mouseControl;
        }
        // Exit mouse camera
        else if(key.code == 'Escape') {
            mouseControl = false;
        }
        // Set move targets of selected gamepieces
        else if(key.code == 'KeyE') {
            let mainRay = scene.pick(scene.pointerX, scene.pointerY);
            // let boardRay = scene.createPickingRay(scene.pointerX, scene.pointerY);
            // let boardIntersection = ray.intersectsMesh(board);
            if(mainRay.hit) {
                if(mainRay.pickedMesh.name == 'AIPiece') {
                    console.log('attacking AI piece');
                    // TODO: attack pickedMesh piece
                }
                else {
                    console.log('setting move targets');
                    let boardRay = scene.createPickingRay(scene.pointerX, scene.pointerY);
                    let boardIntersection = boardRay.intersectsMesh(board);
                    if(boardIntersection.hit) {
                        for(let i = 0; i < numPieces; i++) {
                            if (playerPieces[i].metadata.selected = true) {
                                playerPieces[i].metadata.moving = true;
                                playerPieces[i].metadata.target = boardIntersection.pickedPoint;
                                console.log(playerPieces[i].metadata.target);
                            }
                        }
                    }
                }
            }
        }
    }

    scene.activeCamera.rotation.x = Math.PI/6;
    function orientCam(event) {
        // Set look direction based on cursor position
        if(mouseControl) {
            scene.activeCamera.rotation.y = (event.offsetX/canvas.width)*6 - 3;
            scene.activeCamera.rotation.x = (event.offsetY/canvas.height)*2 - 1;
        }
    }

    // Start all listeners
    document.addEventListener('keydown', keyDown);
    document.addEventListener('keyup', keyUp);
    document.addEventListener('mousemove', orientCam);

    // Select gamepieces with left mouse-click
    scene.onPointerDown = function (evt, pickResult) {
        if (pickResult.hit) {
            if( !groupSelect || pickResult.pickedMesh.name != 'playerPiece') {
                for(let i = 0; i < numPieces; i++) {
                        playerPieces[i].metadata.selected = true;
                        playerPieces[i].enableEdgesRendering(0);
                }
            }
            if(pickResult.pickedMesh.name == 'playerPiece') {
                pickResult.pickedMesh.metadata.selected = false;
                pickResult.pickedMesh.enableEdgesRendering();
            }
        }
    };

    console.log('starting render loop... ');
    //////////////////////////////////
    //           MAIN LOOP          //
    //////////////////////////////////
    
    scene.registerBeforeRender(function () {
        // Place planar cursor under mouse pointer
        if(mouseControl) {
            let ray = scene.createPickingRay(scene.pointerX, scene.pointerY);
            let boardIntersection = ray.intersectsMesh(board);

            if(boardIntersection.hit) {
                planarCursor.position = boardIntersection.pickedPoint;
            }
        }

        // Move pieces to their targets
        let toTarget;
        for(let i = 0; i < numPieces; i++) {
            if(playerPieces[i].selected == true && playerPieces[i].moving == true) {
                console.log('moving piece');
                toTarget = playerPieces[i].position - playerPieces[i].metadata.target;  
                if(Math.abs(toTarget.length) > moveTargetError) {
                    playerPieces[i].position += toTarget.normalize()*pieceSpeed*scene.getEngine().getDeltaTime();
                }   
            }
        }
    });

    let renderLoop = function () {
        scene.render();
    };
    engine.runRenderLoop(renderLoop);

    console.log('-------------------------------\n ----      Finished!       ---- \n ------------------------------');
    

    
    


 


</script>
</body>
</html>
